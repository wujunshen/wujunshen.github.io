<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ElasticSearch插件开发示例</title>
    <link href="/posts/2158921611.html"/>
    <url>/posts/2158921611.html</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>项目配置</p><p><a href="http://www.wujunshen.cn/posts/877356228.html">JAVA GraalVM 17</a></p><p>ElasticSearch 8.3.3</p><h1 id="插件开发目的"><a href="#插件开发目的" class="headerlink" title="插件开发目的"></a>插件开发目的</h1><p>让更多的开发者增强ElasticSearch功能</p><h1 id="插件类型"><a href="#插件类型" class="headerlink" title="插件类型"></a>插件类型</h1><table><thead><tr><th align="left">类型</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">ActionPlugin</td><td align="left">rest命令请求，定制化符合自身需求的rest命令</td></tr><tr><td align="left">AnalysisPlugin</td><td align="left">分析，弥补es自身分析功能不足</td></tr><tr><td align="left">ClusterPlugin</td><td align="left">集群</td></tr><tr><td align="left">DiscoveryPlugin</td><td align="left">发现</td></tr><tr><td align="left">IngestPlugin</td><td align="left">预处理</td></tr><tr><td align="left">MapperPlugin</td><td align="left">映射，增加强es数据类型</td></tr><tr><td align="left">NetworkPlugin</td><td align="left">网络</td></tr><tr><td align="left">RepositoryPlugin</td><td align="left">存储，提供快照和恢复</td></tr><tr><td align="left">ScriptPlugin</td><td align="left">脚本，调用任何语言写的自定义脚本</td></tr><tr><td align="left">SearchPlugin</td><td align="left">查询，扩展es本身的查询功能</td></tr></tbody></table><p>表格中插件类型都是java接口类，具体可见github上ElasticSearch的<a href="https://github.com/elastic/elasticsearch/tree/main/server/src/main/java/org/elasticsearch/plugins">源码</a></p><h1 id="插件开发举例"><a href="#插件开发举例" class="headerlink" title="插件开发举例"></a>插件开发举例</h1><h2 id="自定义开发插件类路径"><a href="#自定义开发插件类路径" class="headerlink" title="自定义开发插件类路径"></a>自定义开发插件类路径</h2><p>见下图</p><p><img src="/img/es/304aee05.png" alt="开发目录结构"></p><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><h3 id="新建plugin-descriptor-properties"><a href="#新建plugin-descriptor-properties" class="headerlink" title="新建plugin-descriptor.properties"></a>新建plugin-descriptor.properties</h3><p>在reousrces目录下新建plugin-descriptor.properties，内容如下</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">name</span><span class="token punctuation">=</span><span class="token value attr-value">$&#123;elasticsearch.plugin.name&#125;</span><span class="token key attr-name">version</span><span class="token punctuation">=</span><span class="token value attr-value">$&#123;project.version&#125;</span><span class="token key attr-name">description</span><span class="token punctuation">=</span><span class="token value attr-value">$&#123;project.description&#125;</span><span class="token key attr-name">classname</span><span class="token punctuation">=</span><span class="token value attr-value">$&#123;elasticsearch.plugin.classname&#125;</span><span class="token key attr-name">java.version</span><span class="token punctuation">=</span><span class="token value attr-value">$&#123;maven.compiler.target&#125;</span><span class="token key attr-name">elasticsearch.version</span><span class="token punctuation">=</span><span class="token value attr-value">$&#123;elasticsearch.version&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>properties文件中各属性含义见下列表格</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">插件名字</td></tr><tr><td align="left">version</td><td align="left">插件版本</td></tr><tr><td align="left">description</td><td align="left">插件功能描述</td></tr><tr><td align="left">classname</td><td align="left">插件入口class，完整路径</td></tr><tr><td align="left">java.version</td><td align="left">jdk版本</td></tr><tr><td align="left">elasticsearch.version</td><td align="left">elasticsearch版本</td></tr></tbody></table><h3 id="定义pom文件，绑定properties中的配置项"><a href="#定义pom文件，绑定properties中的配置项" class="headerlink" title="定义pom文件，绑定properties中的配置项"></a>定义pom文件，绑定properties中的配置项</h3><p>properties中的配置项值在pom.xml文件中定义。如下</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elasticsearch.plugin.name</span><span class="token punctuation">></span></span>plugin develop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elasticsearch.plugin.name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elasticsearch.plugin.classname</span><span class="token punctuation">></span></span>com.wujunshen.plugin.PrintPlugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elasticsearch.plugin.classname</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.target</span><span class="token punctuation">></span></span>17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.target</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elasticsearch.version</span><span class="token punctuation">></span></span>8.3.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elasticsearch.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elasticsearch.assembly.descriptor</span><span class="token punctuation">></span></span>$&#123;project.basedir&#125;/src/main/assemblies/plugin.xml        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elasticsearch.assembly.descriptor</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意</p><p>其中elasticsearch.version配置项的值</p><p>也就是ElasticSearch的版本号必须和你将要发布插件包的ElasticSearch安装版本号一致。</p><p>上述我写了8.3.3，打包后也必须解压到8.3.3版本的ElasticSearch中，否则插件执行效果会无效化</p></blockquote><h3 id="自定义plugin类型类"><a href="#自定义plugin类型类" class="headerlink" title="自定义plugin类型类"></a>自定义plugin类型类</h3><p>假设我们自定义的插件类型是ActionPlugin，则自定义一个plugin类型类，继承抽象类Plugin，然后实现ActionPlugin接口</p><p>代码示例</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>wujunshen<span class="token punctuation">.</span>plugin</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>wujunshen<span class="token punctuation">.</span>plugin<span class="token punctuation">.</span>handler<span class="token punctuation">.</span></span><span class="token class-name">PrintPluginHandler</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span>metadata<span class="token punctuation">.</span></span><span class="token class-name">IndexNameExpressionResolver</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span>node<span class="token punctuation">.</span></span><span class="token class-name">DiscoveryNodes</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>common<span class="token punctuation">.</span>settings<span class="token punctuation">.</span></span><span class="token class-name">ClusterSettings</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>common<span class="token punctuation">.</span>settings<span class="token punctuation">.</span></span><span class="token class-name">IndexScopedSettings</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>common<span class="token punctuation">.</span>settings<span class="token punctuation">.</span></span><span class="token class-name">Settings</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>common<span class="token punctuation">.</span>settings<span class="token punctuation">.</span></span><span class="token class-name">SettingsFilter</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span></span><span class="token class-name">ActionPlugin</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span></span><span class="token class-name">Plugin</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>rest<span class="token punctuation">.</span></span><span class="token class-name">RestController</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>rest<span class="token punctuation">.</span></span><span class="token class-name">RestHandler</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Collections</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span></span><span class="token class-name">Supplier</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintPlugin</span> <span class="token keyword">extends</span> <span class="token class-name">Plugin</span> <span class="token keyword">implements</span> <span class="token class-name">ActionPlugin</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> ACTION_PREFIX <span class="token operator">=</span> <span class="token string">"print"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">PrintPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; 插件实例化......"</span><span class="token punctuation">,</span> ACTION_PREFIX<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RestHandler</span><span class="token punctuation">></span></span> <span class="token function">getRestHandlers</span><span class="token punctuation">(</span><span class="token class-name">Settings</span> settings<span class="token punctuation">,</span> <span class="token class-name">RestController</span> restController<span class="token punctuation">,</span>                                             <span class="token class-name">ClusterSettings</span> clusterSettings<span class="token punctuation">,</span> <span class="token class-name">IndexScopedSettings</span> indexScopedSettings            <span class="token punctuation">,</span> <span class="token class-name">SettingsFilter</span> settingsFilter<span class="token punctuation">,</span> <span class="token class-name">IndexNameExpressionResolver</span> indexNameExpressionResolver<span class="token punctuation">,</span>                                             <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DiscoveryNodes</span><span class="token punctuation">></span></span> nodesInCluster<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrintPluginHandler</span><span class="token punctuation">(</span>restController<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="实现具体handler类"><a href="#实现具体handler类" class="headerlink" title="实现具体handler类"></a>实现具体handler类</h3><p>ElasticSearch插件真正要做的事情，需要实现的逻辑我们放在具体的handler类中，比如这个例子中，我们实现一个PrintPluginHandler类，打印消耗时间，请求参数，插件名等一些信息</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>wujunshen<span class="token punctuation">.</span>plugin<span class="token punctuation">.</span>handler</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>client<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>node<span class="token punctuation">.</span></span><span class="token class-name">NodeClient</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>common<span class="token punctuation">.</span>inject<span class="token punctuation">.</span></span><span class="token class-name">Inject</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>rest<span class="token punctuation">.</span></span><span class="token class-name">BaseRestHandler</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>rest<span class="token punctuation">.</span></span><span class="token class-name">BytesRestResponse</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>rest<span class="token punctuation">.</span></span><span class="token class-name">RestController</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>rest<span class="token punctuation">.</span></span><span class="token class-name">RestRequest</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>rest<span class="token punctuation">.</span></span><span class="token class-name">RestRequest</span><span class="token punctuation">.</span><span class="token class-name">Method</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>rest<span class="token punctuation">.</span></span><span class="token class-name">RestStatus</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>xcontent<span class="token punctuation">.</span></span><span class="token class-name">XContentBuilder</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span><span class="token comment">/** * @author wujunshen */</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintPluginHandler</span> <span class="token keyword">extends</span> <span class="token class-name">BaseRestHandler</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> PRINT_NAME <span class="token operator">=</span> <span class="token string">"printPluginTest"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Inject</span>    <span class="token keyword">public</span> <span class="token class-name">PrintPluginHandler</span><span class="token punctuation">(</span><span class="token class-name">RestController</span> restController<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 注册</span>        restController<span class="token punctuation">.</span><span class="token function">registerHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Route</span><span class="token punctuation">(</span><span class="token class-name">Method</span><span class="token punctuation">.</span>GET<span class="token punctuation">,</span> <span class="token string">"/print-plugin"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> PRINT_NAME<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span><span class="token punctuation">></span></span> <span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 处理业务逻辑     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">RestChannelConsumer</span> <span class="token function">prepareRequest</span><span class="token punctuation">(</span><span class="token class-name">RestRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">NodeClient</span> client<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 接收的参数</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"params==&#123;&#125;"</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">params</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> cost <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">;</span>        <span class="token comment">// 返回内容，这里返回消耗时间 请求参数 插件名称</span>        <span class="token keyword">return</span> channel <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token class-name">XContentBuilder</span> builder <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            builder<span class="token punctuation">.</span><span class="token function">startObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            builder<span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">"cost"</span><span class="token punctuation">,</span> cost<span class="token punctuation">)</span><span class="token punctuation">;</span>            builder<span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>            builder<span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">"time"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            builder<span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">"pluginName"</span><span class="token punctuation">,</span> PRINT_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>            builder<span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">"print"</span><span class="token punctuation">,</span> <span class="token string">"this is print plugin test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            builder<span class="token punctuation">.</span><span class="token function">endObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">sendResponse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BytesRestResponse</span><span class="token punctuation">(</span><span class="token class-name">RestStatus</span><span class="token punctuation">.</span>OK<span class="token punctuation">,</span> builder<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>通过上述4步，我们完成了插件开发过程，接下来需要发布，使其生效</p><h1 id="发布插件"><a href="#发布插件" class="headerlink" title="发布插件"></a>发布插件</h1><h2 id="插件配置文件定义"><a href="#插件配置文件定义" class="headerlink" title="插件配置文件定义"></a>插件配置文件定义</h2><p>首先在assemblies目录下新建plugin.xml中，配置好打包需要的各项属性，如下</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assembly</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>plugin-develop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>formats</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>format</span><span class="token punctuation">></span></span>zip<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>format</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>formats</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includeBaseDirectory</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includeBaseDirectory</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSets</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>$&#123;project.basedir&#125;/config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSets</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>files</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>$&#123;project.basedir&#125;/src/main/resources/plugin-descriptor.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtered</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtered</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>files</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencySets</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencySet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>useProjectArtifact</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>useProjectArtifact</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>useTransitiveFiltering</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>useTransitiveFiltering</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>excludes</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>org.elasticsearch:elasticsearch<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>excludes</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencySet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencySet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>useProjectArtifact</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>useProjectArtifact</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>useTransitiveFiltering</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>useTransitiveFiltering</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>org.apache.httpcomponents:httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencySet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencySets</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assembly</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>指定了打包成zip格式，并把需要打入插件包的依赖包和文件全部做好了声明。接下来我们就可以执行maven打包命令进行打包</p><h2 id="maven命令打包"><a href="#maven命令打包" class="headerlink" title="maven命令打包"></a>maven命令打包</h2><p>在maven的pom.xml中定义好build步骤</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">。。。    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.encoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.encoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.source.version</span><span class="token punctuation">></span></span>17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.source.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.target.version</span><span class="token punctuation">></span></span>17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.target.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elasticsearch.version</span><span class="token punctuation">></span></span>8.3.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elasticsearch.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.target</span><span class="token punctuation">></span></span>17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.target</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elasticsearch.assembly.descriptor</span><span class="token punctuation">></span></span>$&#123;project.basedir&#125;/src/main/assemblies/plugin.xml        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elasticsearch.assembly.descriptor</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elasticsearch.plugin.name</span><span class="token punctuation">></span></span>plugin develop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elasticsearch.plugin.name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elasticsearch.plugin.classname</span><span class="token punctuation">></span></span>com.wujunshen.plugin.PrintPlugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elasticsearch.plugin.classname</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>。。。    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>excludes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>*.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>excludes</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-assembly-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appendAssemblyId</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appendAssemblyId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>$&#123;project.build.directory&#125;/releases/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptors</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptor</span><span class="token punctuation">></span></span>$&#123;basedir&#125;/src/main/assemblies/plugin.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptor</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptors</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>single<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.8.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>$&#123;maven.compiler.target&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>$&#123;maven.compiler.target&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span><span class="token punctuation">></span></span>$&#123;project.build.sourceEncoding&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoding</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span>。。。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>通过maven命令</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mvn clean install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>打包已开发完成的源码。</p><h2 id="发布插件包"><a href="#发布插件包" class="headerlink" title="发布插件包"></a>发布插件包</h2><p>将打包成zip格式的插件包(在&#x2F;target&#x2F;releases目录下)</p><p>解压到ElasticSearch下的plugins子目录下，这样就发布完成了</p><h1 id="运行插件"><a href="#运行插件" class="headerlink" title="运行插件"></a>运行插件</h1><h2 id="启动ElasticSearch"><a href="#启动ElasticSearch" class="headerlink" title="启动ElasticSearch"></a>启动ElasticSearch</h2><p>在ElasticSearch目录下的bin子目录启动ElasticSearch</p><blockquote><p>注意</p><p>不能用root账号启动</p><p>需要新建账号并赋权，然后启动ElasticSearch</p></blockquote><h2 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h2><p>浏览器中输入  <code>http://127.0.0.1:9200/print-plugin?name=wujunshen</code></p><p>效果如下</p><p><img src="/img/es/251f4c4e.png" alt="效果图"></p><p>以上这些内容即我们开发一个ElasticSearch插件包的完整示例</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://gitee.com/darkranger/elasticsearch-plugin-devlop-example">本文源码</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>ElasticSearch</tag>
      
      <tag>GraalVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>亚马逊领导力原则学习笔记</title>
    <link href="/posts/2931781604.html"/>
    <url>/posts/2931781604.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-客户至上"><a href="#1-客户至上" class="headerlink" title="1.客户至上"></a>1.客户至上</h1><h2 id="客户至上"><a href="#客户至上" class="headerlink" title="客户至上"></a>客户至上</h2><blockquote><p>领导者从客户入手，再反向推动工作。他们努力工作，赢得并维系客户对他们的信任。虽然领导者会关注竞争对手，但是他们更关注客户。</p></blockquote><h2 id="Customer-Obsession"><a href="#Customer-Obsession" class="headerlink" title="Customer Obsession"></a>Customer Obsession</h2><blockquote><p>Leaders start with the customer and work backwards. They work vigorously to earn and keep customer trust. Although leaders pay attention to competitors, they obsess over customers.</p></blockquote><h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>“客户至上”是亚马逊最为重要的行事原则。亚马逊的创始人贝佐斯曾在公开场合多次强调客户的重要性，并将其列为最基础的工作准则。换句话说，如果与其他准则相悖，则优先遵循“客户至上”准则。</p><p>为什么贝佐斯将这条准则视作第一准则？如果你也不太清楚，2017 年 7 月贝佐斯在给股东的年度公开信中再一次强调了“客户至上”的重要性，或许你能从中一窥究竟。</p><p>公开信里大体是这样说的:</p><blockquote><p>有很多方法可以成为做生意的核心。企业可以以竞争对手为核心，也可以以产品为核心。企业还可以聚焦于技术，或者以业务模式为核心等等。但在我看来，以客户为中心是最为有利的方式。</p></blockquote><blockquote><p>为什么呢？以客户为中心的方法有很多优点。其中很大的一个优点是：客户总是非常不满足。即便他们说他们很满足，公司业务很好。客户总是想要更好的东西，甚至他们都没有意识到这一点。遵循着让客户满意的意图将驱使企业代表客户去发明和创造。没有客户曾经要求亚马逊创建 Prime 会员计划，然而我们发明了这项服务。最后确实证明客户是想要这个计划的。类似这样的例子，我可以列举很多。</p></blockquote><p>这封信里提到了亚马逊的 Prime 会员，这是一项定价 95 美元的年收费服务项目。这一项目的性价比很高，用户可以享受到包括免费隔日送达货物、免费视频等多项便利服务。</p><p>该项目在初推之时，亚马逊内部并不是一片和谐，很多人都提出了反对意见。反对 Prime 会员计划有很多原因，其中比较重要的有两点.</p><ul><li>第一点是这个计划成本昂贵。亚马逊做这个生意，非但不能赚到钱，还可能赔进去很多钱。比如说隔日免费寄送这项服务，用户每年只要下 4 单，邮费就超过 95 美元了。如果用户购买较多，亚马逊就会赔本。</li><li>第二点是这一项目需要收取年费，用户是否愿意为此买单，也是未知数。万一投入大量成本去开发，用户却不买账，那么会前功尽弃。</li></ul><p>贝佐斯在推行项目之初，问了团队一个问题：“如果你是客户，是否愿意掏钱去享受这种服务？” 如果回答是肯定的，那么哪怕亚马逊会为此付出许多代价，甚至不能短期获利，这项服务也值得推出。</p><p><strong>急客户所需，想客户所想，才是“客户至上”的基本体现。坚持这样的理念，客户便会越来越愿意在亚马逊上消费，最后的规模效应才会形成良性循环。</strong> 团队的回答当然是正面的，于是项目得以顺利推行。</p><p>事后的发展印证了贝佐斯的想法。Prime 会员制度推行之后，亚马逊上的购物量迅速增加，亚马逊的会员们对两天内送达这一服务表现出极大的热情。因为制度的推出，亚马逊迅速战胜了 eBay 和沃尔玛这样的传统零售商。</p><p>亚马逊固然没有从邮费上赚到钱，但其规模效应带来的收入却远远大于在邮费上的支出。这种规模效应的结果是：亚马逊的各方面都得到提升，客户对亚马逊的忠诚度也极大地提高了。</p><p>贝佐斯多次引用这个故事，告诉员工，也告诉亚马逊的客户与投资人，“客户至上”这一准则对于亚马逊到底意味着什么。</p><p>贝佐斯表示，<strong>在创新的时候，是不是真正以客户为中心，这一点至关重要。否则，所谓的发明创造必然会陷入对成本的计较和对利益的追逐，当这些成为创新的目的，客户也就不可能发自内心地满意了。</strong></p><p>没有了客户支持的企业，即便短期内可以获得高利润，也不可能长久。换句话说，是不是真的对客户好，客户不是傻瓜，有鉴别能力的。</p><p>在美国各行各业里，创新并非为客户服务的例子有很多，将赚钱作为第一企业要义的案例也不胜枚举。</p><p>美国有一家非常有名的生物制药厂商吉利德科学公司（Gilead Sciences），以生产抗病毒药物著称，艾滋病的“鸡尾酒疗法”治疗药物就出自这里。这家厂商发明了一种可以彻底治愈丙型肝炎的药物，这在抗病毒技术上是一个极大的突破，在此之前，丙型肝炎最多也只能控制而不能被彻底治愈。</p><p>然而，人们对于这家企业一直有顾虑，他们不知道到底要花多少钱才能获得治疗。因为在美国的制药业里，新药开出天价来，是非常常见的敛财方式。所以在这个药出来之前，就有人觉得定价会很高，比如高达 3 万美元。</p><p>然而大家还是低估了这个数字。药价公布的时候，七万五千美元一个人的治疗费用，不但吓坏了“吃瓜群众”，也吓坏了媒体和保险公司。</p><p>这种高价“敛财”的手段甚至惊动了美国国会议员调查其企业定价的合理性。一些第三世界的国家，比如印度，看到如此高昂的价格，干脆就不想搭理这家企业，自己开始仿制药物。</p><p>最后的结果是，这家企业并没有获利很多，因为世界各地都在仿制这个药物。而且，很多得了丙肝却非特别严重的人，也不愿意花那么一大笔钱去治疗。我想，这就是一个非常典型的，不以客户为中心的例子。</p><p>“以客户为中心”并非放之四海而皆准的真理，但是在贝佐斯的观念中却是如此。贝佐斯要求他的每位员工，无论何时都必须将这条领导力准则执行到实处。这造就了亚马逊“客户至上”的服务理念：任何事情只要是对客户有利的，哪怕暂时牺牲企业的一些收益，也应该去做。</p><p>外界对于亚马逊推崇的以客户为中心的这条准则并非没有争议，因为极端地以客户为中心，完全可能牺牲掉企业的全部利益。外界对其各种揣测，说到底拿不准的恰恰是这个度。</p><p>我们经常可以看到各种各样的讨论，不能否认，这种讨论有它合理的一面。在我接触到的亚马逊内部人员中，也有人心存困惑。在他们实际的工作中，以客户为中心这一服务准则的具体界限十分难以判断。但是，相信贝佐斯自己心中是有界限的，只是这个界限，并不容易表达。因此，他人是否真正能够做到通晓“客户至上”准则，就要看各自的悟性了。</p><h1 id="2-主人翁精神"><a href="#2-主人翁精神" class="headerlink" title="2.主人翁精神"></a>2.主人翁精神</h1><h2 id="主人翁精神"><a href="#主人翁精神" class="headerlink" title="主人翁精神"></a>主人翁精神</h2><blockquote><p>领导者是主人翁。他们会从长远考虑，不会为了短期业绩而牺牲长期价值。他们不仅仅代表自己的团队，而且代表整个公司行事。他们绝不会说“那不是我的工作”。</p></blockquote><h2 id="Ownership"><a href="#Ownership" class="headerlink" title="Ownership"></a>Ownership</h2><blockquote><p>Leaders are owners. They think long term and don’t sacrifice long-term value for short-term results. They act on behalf of the entire company, beyond just their own team. They never say “that’s not my job.”</p></blockquote><h2 id="讲解-1"><a href="#讲解-1" class="headerlink" title="讲解"></a>讲解</h2><p>主人翁精神其实是一个老生常谈的话题。但是在亚马逊的领导力准则里，主人翁精神有比较明确的定义。简单来说，是两个方面：</p><ol><li>在长期利益和短期利益面前，要从长远考虑，不能因为短期利益杀鸡取卵，牺牲长期利益；</li><li>在小团体和公司的整体利益面前，要代表整个公司的利益，而不是小团体的利益。</li></ol><p>细化成这两条内容之后，亚马逊的主人翁精神也就显得比较清晰具体了。</p><h3 id="2-1-长期利益与短期利益"><a href="#2-1-长期利益与短期利益" class="headerlink" title="2.1 长期利益与短期利益"></a>2.1 长期利益与短期利益</h3><p>先看一下第一条，即长期利益和短期利益之间的关系。对此你应该并不陌生，我们的老祖宗早就已经用“杀鸡取卵”来形容这种做法了。但是不可否认，现实社会里杀鸡取卵的现象比比皆是，要做到为了长期利益去牺牲短期利益，是非常艰难的。</p><p>为什么会这样呢？其实很简单，因为人终究是利益驱动的，短期利益变现容易，而长期利益显得虚无缥缈。</p><p>从企业经营的角度来看，如果一项投入需要企业长期赔钱，即使未来一定会赚钱，这种投入对于很多企业来说也都是不切实际的。赚不到钱，可能直接就意味着破产，所以企业一定是要获得短期盈利，才能考虑长期发展的，这是做企业的正常逻辑。</p><p>当然有些企业已经有了可持续盈利的业务，所以可以拿出一部分盈利资金去投资未来可能带来收益的新领域，然而这依然没有摆脱企业坚持“短期利益为主，长期利益为辅”的路线。至少在亚马逊之前，我从来没见过一家企业不担心盈利问题的。如果盈利不好，那么股票就不好看，股票不好看，大家的日子也就不好过了。</p><p>这种做企业的“正常逻辑”在贝佐斯看来却并不正确。贝佐斯认为，企业就需要集中关注长期利益，而不应该为短期利益所左右，每个雇员作为企业的主人翁，都应该为企业的长期利益服务。所以，如果我们去看亚马逊的盈利模式，它长期十余年如一日不赚钱，每次有了钱之后就投入到新的领域里面去，这是一般人不能理解的企业经营模式。</p><p><strong>在贝佐斯看来，如果一项投入是长期有意义的，那么五到七年不赚钱并不是问题，无法赚钱而导致公司股票短期内很难看，更不是问题。因为最终投资人会发现，集中精力去服务长期利益所带来的效益，将远远超过短期效益。</strong></p><p>由于秉承这样的理念，一段时间里，华尔街并不看好亚马逊，他们的股价一度表现得不尽人意。然而随着亚马逊的长期效益不断体现，这种理念现在得到了投资人越来越多的肯定。</p><h3 id="2-2-公司利益与团体利益"><a href="#2-2-公司利益与团体利益" class="headerlink" title="2.2 公司利益与团体利益"></a>2.2 公司利益与团体利益</h3><p><strong>主人翁精神的第二条，要求每个员工代表整个公司的利益，</strong> 而不是某个小团体的利益。这一点相对来说会好理解一些。</p><p>贝佐斯最不喜欢的就是湖对岸的老牌软件帝国：微软。在他看来，这个帝国里部门间各自为政，相互坑害，并不能为公司的整体利益很好地服务。</p><p>在某次采访中，贝佐斯说过早年他透过办公室望向外面的华盛顿湖，想着自己的公司如何才能避免重蹈湖对岸那家公司以及其他无数大公司的覆辙。</p><p>他能想到的，就是公司的每个员工在考虑问题时，都关注整个公司的利益，而不是只关注自己这个小团体的利益。他认为，部门之间不应该为小团体利益而互相倾轧。</p><p>主人翁精神就意味着，一个项目的主导者，不但要解决自己组内的问题，也要解决所有依赖关系中存在的麻烦。为了项目的推进和公司的整体利益，部门的局限不应成为一个人不推动项目前进的借口。</p><p>同样的，如果为了一个项目需要不同组织之间协调把事情做好，这个项目里涉及的所有人都要努力配合把事情解决好。大家都是为了公司整体利益、长期利益服务，而不是为了某个部门的小团体的利益服务，基于这个前提，没有解决不了的问题，只有不正确的解决问题的态度。</p><p>贝佐斯认为，只有所有的人都在为公司的整体利益服务时，才可能避免官僚主义，避免自己的公司最终成为湖对岸那个臃肿而又内耗严重的公司。</p><p>亚马逊一贯以来以执行力著称，任何事情在亚马逊里面推动，并不会受到莫名其妙的阻力。没有任何组织和个人可以以“这个事情是我的，不是你的”为由来阻止事情的推动。这些都是主人翁精神的体现。</p><p>当然，利益驱动始终都是组织和个人行动的基础，我们不能否认利益驱动的作用。如何构建一个合理的利益驱动体系，从而使大家都自觉地做主人翁，是这条领导力准则里面非常重要的一环。我想贝佐斯肯定反复思考过可行方案，最后才决定这样做。</p><p>既然是主人翁精神，那么个人所得必然和公司业绩的发展密切相关。而能够体现这种相关性的，首先必须是股票。公司业绩好了，股票价格上扬，所有的“主人翁”都应该受益，反之亦然。</p><p><strong>基于这样一条原则，贝佐斯建立的薪酬体系和理念与很多公司都不一样：在亚马逊，现金作为整个薪酬体系的一部分，只占到了很低的比例；与之相反，个人股票在整个薪酬体系里占据的比例很高，对于亚马逊的高管来说，这个比例尤其高。</strong></p><p>比如，贝佐斯自己只拿 16 万 5 千的现金，在众多 CEO 中这个比例不是一般得低，基本上可以说只有很多 CEO 的 10%。这种做法为整个亚马逊的人员设置了一个现金上限。</p><p>在这样的薪酬体系设置下，一个人能够获得的收入和股票的价格就密切相关了。所以大家为了公司的长远利益和整体利益去考虑，公司的股票自然就会涨，进而会让每个人的收入增加。这种强调股票的重要性和比例的薪酬体系，可以说是亚马逊首创。</p><p>从实际结果上看，亚马逊的股票从 2009 年经济危机以来，现在已经涨了不止 10 倍。那些当年拿着股票的人，如果没有把亚马逊的股票卖掉，时至今日也是衣食无忧了。</p><p>贝佐斯认为，正是这种薪酬体系，把每个人的收益和公司的成长紧密地绑在了一起。这种方式会让人更加注重长期利益、整体利益，而不是局部利益、短期利益。这无疑是很聪明的一种做法，也是贝佐斯提出的主人翁精神对企业发展贡献的最直观体现。</p><p>理解主人翁精神在亚马逊里是如何指导企业发展和每个人的日常工作的，这对于理解亚马逊很多独特的企业文化与特质，都有着至关重要的作用。</p><h1 id="3-创新简化"><a href="#3-创新简化" class="headerlink" title="3.创新简化"></a>3.创新简化</h1><h2 id="创新简化"><a href="#创新简化" class="headerlink" title="创新简化"></a>创新简化</h2><blockquote><p>领导者期望并要求自己的团队进行创新和发明，并始终寻求使工作简化的方法。他们了解外界动态，四处寻找新的创意，并且不局限于“非我发明”的观念。当我们开展新事物时，我们要接受被长期误解的可能。</p></blockquote><h2 id="Invent-and-Simplify"><a href="#Invent-and-Simplify" class="headerlink" title="Invent and Simplify"></a>Invent and Simplify</h2><blockquote><p>Leaders expect and require innovation and invention from their teams and always find ways to simplify. They are externally aware, look for new ideas from everywhere, and are not limited by “not invented here.” As we do new things, we accept that we may be misunderstood for long periods of time.</p></blockquote><h2 id="讲解-2"><a href="#讲解-2" class="headerlink" title="讲解"></a>讲解</h2><p>这条领导力准则主要由“创新”与“简化”两部分组成。具体来说，我们可以分解成下面几点：</p><ol><li>简化和创新是密不可分的；</li><li>创新的时候不要受到局限；</li><li>创新要接受长期被误解。</li></ol><p><strong>在贝佐斯看来，创新的重要一步就是简化。假如创新产生了一个复杂的结果，这在创新刚起步时是被允许的；但如果在这种复杂的结果上停滞不前，就不是亚马逊所寻求的创新。</strong></p><p>某位亚马逊前高管接受访谈时提到过这样一件事。在亚马逊网站成立初期，公司内部就如何为客户提供服务展开了讨论，讨论的主题是：亚马逊是否需要像传统零售商那样构建庞大的客服队伍？</p><p>公司内部觉得这种庞大的客服队伍不但消耗资源，而且不利于客户真正解决问题，所以亚马逊不构建庞大的客服队伍。亚马逊的创新理念是尽可能让一切自动化，从而达成简化工作的目的。</p><p>这种自动化体现在很多方面，比如在亚马逊的退货流程不需要客服参与，再比如在亚马逊上可以自动追踪货物的定位。这在今天的电商环境下司空见惯，但在亚马逊刚成立时绝对不是整个业界的主流解决方案。</p><p>这种方案的好处显而易见。</p><ul><li>首先，不需要客服，就降低了成本，亚马逊可以提供更加低廉的价格。</li><li>其次，不需要客服，就没有了所谓的瓶颈，用户需要进行各种操作时，就不会因为联系客服而等待耽搁时间。因此，整个网站的吞吐量上升，亚马逊可以更好地服务客户。</li></ul><p><strong>贝佐斯认为，不断简化，创造出更加简单的问题解决方式，才是创新的根本。</strong> 任何创新，倘若无法让事情变得更简单、更自动化，就难免进入“为了创新而创新”的僵局。</p><p>这个观点其实非常值得深思。在创新或者强调创新的过程里，如何去判断创造出来的新事物是合理的？如果没有一些基本准则，难免陷入各执一词的状态。以“简化”作为创新的基本准则，是一个很有指导意义的做法。</p><p>亚马逊创新简化准则的另一部分，是要求员工可以做任何尝试，不局限于亚马逊内部的创意：任何好的想法，不论出处如何，只要它有益于亚马逊的发展，都可以拿来使用和尝试。这和微软的作风很不一样。</p><p>亚马逊的一位朋友告诉我，他从微软去亚马逊之后，明显感觉到了两家公司的很多差异。其中非常重要的一项是，当他尝试做一些创新的时候，在微软往往阻力重重，领导会问你这个创新是怎么来的，是不是符合微软的传统等等，在尝试之前他需要再三准备。</p><p>在亚马逊，这些从来不是问题。亚马逊鼓励创新、鼓励尝试，至于想法是外来的，还是内部诞生的，都不应该是阻止创新和尝试的理由。亚马逊的领导者鼓励每个人去创新，而且不愿创新是不符合领导力准则的行为，亚马逊并不喜欢这样的员工，也不鼓励这样的行为。</p><p><strong>这条领导力准则还强调了一点：但凡是创新的东西，都可能在一段时间，乃至很长一段时间内无法让人理解</strong>。亚马逊认为这其实是很正常的，而且他们鼓励员工接受这种无法被外界理解的情况，并继续创新。</p><p>这种做法的好处是，亚马逊的员工可以不用局限在眼前的利益，能够做一些更加长远的、有变革性的创新。很多成功的创新不是小修小补，而是颠覆性的、变革性的，历史也告诉我们，很多时候“真理掌握在少数人手中”。如果说因为大众不能理解就停止创新，也就不会有颠覆性的变革出现了。</p><p>我曾经读过一篇亚马逊前高管写的文章，其中提到了亚马逊第一次从在线售书转向在线售卖家电的过程。在那个年代，只有大卖场里才能售出家电，因为每个人需要去现场触摸操作才愿意掏钱，毕竟家电和书比起来是一大笔消费。</p><p>那么在网上仅仅凭借几张图片和列表，能卖成家电吗？亚马逊内部的很多人心里都有这个疑问，这在二十年前也是很正常的反应。</p><p>亚马逊还是决定做了，不过在很长一段时间里，这种做法并没有客户买账。因为商品看不到也摸不到就寄到家里，客户总是有很多不安全感。家电生意在最初表现非常不好。</p><p><strong>然而贝佐斯觉得，这其实是因为客户不理解创新。而创新，尤其是大的创新，一段时间内不被接受也是正常的。但如果因此就停止创新了，那才是真正的问题。</strong></p><p>面对家电生意不成功一事，贝佐斯对他的队伍说，我们需要继续创新。</p><ul><li>首先，亚马逊专门对原本卖书的网站做了很多改动，包括在网站上提供从各个角度拍摄的高精度图片。</li><li>其次，亚马逊构建了非常完备的货物追踪查询系统，让用户可以轻松查阅所购货物的位置。</li><li>再次，亚马逊强化了退货体系，使网购产品和在店里买东西一样可以方便地退货。用户只要通过网上的服务，自助的生成包含运费的单据，就可以直接去邮局或者快递公司退货了，全程无需打客服电话，无需和亚马逊进行人工交流。</li></ul><p>久而久之，人们也渐渐发现了在线购买家电的好处：可以足不出户，而且物美价廉。亚马逊的家电售卖业务也就这样做了起来，而网购家电今天也早已不是一个让人存疑的问题了。但在亚马逊网上销售家电的整个过程里，我们可以明确地看到：他人对创新会存在误解，接受误解才能真正推动创新。</p><h1 id="4-决策正确"><a href="#4-决策正确" class="headerlink" title="4.决策正确"></a>4.决策正确</h1><h2 id="决策正确"><a href="#决策正确" class="headerlink" title="决策正确"></a>决策正确</h2><blockquote><p>领导者在大多数情况下都能做出正确的决定。他们拥有卓越的业务判断能力和敏锐的直觉.他们寻求多样的视角，并挑战自己的观念。</p></blockquote><h2 id="Are-Right-A-Lot"><a href="#Are-Right-A-Lot" class="headerlink" title="Are Right, A Lot"></a>Are Right, A Lot</h2><blockquote><p>Leaders are right a lot. They have strong judgment and good instincts. They seek diverse perspectives and work to disconfirm their beliefs.</p></blockquote><h2 id="讲解-3"><a href="#讲解-3" class="headerlink" title="讲解"></a>讲解</h2><p>这条领导力准则并不像它看上去那样浅显易懂。如果仅仅关注字面意思，你很容易陷入一种茫然不解的境地。</p><p>这种情况并非你我独有。在亚马逊里面，对于这条领导力准则同样感到困惑的大有人在。不过，亚马逊创始人贝佐斯在很多场合，都从不同角度解释过这条领导力准则。今天，我就来和你聊一聊他对这条准则的多重解释。</p><p>首先来看第一句话：“领导者在大多数情况下都能做出正确的决定。”从字面上来看，这比较容易理解。也就是说，在亚马逊里面，犯错误是可以的，但是如果一个人犯错误的比例高于正确决定的比例，那肯定是不被允许的。</p><p>在贝佐斯的观点里看来，一个领导者首先是一个人，因此不可避免地要犯一些错误。但是，一个领导者必须具备卓越的判断能力和敏锐的直觉，这样才能保证在大部分情况下都做出正确的决策。反之，如果一个人无法在大部分情况下保证决策正确，他就不符合亚马逊的领导力准则。</p><p><strong>因此，能够做出正确的决策，是一个领导者必备的素质。</strong> 亚马逊不会允许它的雇员常常犯错。犯错多了，考核自然不会好。考核不好的话，轻则奖金飞了，重则需要自谋出路。这就对一个领导者提出了较高的要求。</p><p>人非圣贤，不可能不犯错，但是亚马逊又要求领导者在大部分情况下都能做出正确的决定。那么 <strong>，一个人如何才能够保证在大部分情况下做出正确的决定呢？这就是领导力准则的第二部分，也是对第一部分这个问题的回答：寻求多样的视角，并挑战自己的观念。</strong></p><p>贝佐斯自己解释过他的见解。一个在大部分情况下可以做出正确决定的人，往往经常性地改变自己的想法。<strong>一个不善变的人，不一定是好的领导者</strong>。很多领导者都会呈现出这样一种状态：今天有这样的想法，明天却有一个和今天截然不同的想法。这种状态看起来很不合理，但是实际上不但是健康的，而且是值得鼓励的。</p><p>贝佐斯在自己和他人的交往过程中发现，<strong>最聪明的人都经常修正自己对事物的理解和决策。</strong> 哪怕是一个已经考虑过的问题，他们也会拿出来重新思考。这样的人往往能够很好地接纳新的观点、新的信息、新的想法哪怕这些想法和他们自己现有的认知是抵触的、矛盾的，他们依然会去接纳、思考和吸收。</p><p>然而需要注意的是，贝佐斯也强调，这并不意味着这个人不需要有自己的观点，或者说不需要让自己的观点足够完善。实际上，贝佐斯要求每个领导者在每次做决策的时候都经过深思熟虑。领导者应该基于现有的信息，谨慎地做出决策，因为这种深思熟虑本身，就是保证决策正确的基础。</p><p><strong>如果决策以后就一成不变了，往往会出问题。</strong> 所以，任何一个人，哪怕有了完善的观点，也应该把这种观点当作一个临时的，或者是一段时期内的，而不是永久的观点。因为新的信息会进来，情况会变，看问题可能会有新的角度与高度。哪怕领导者在一件事情上已经非常有经验，并且做得非常好，一旦他固化了思维，在新的条件下仍会产生错误的决定。</p><p>因此 <strong>，如果一个领导者可以做到在大多数情况下都做出正确的决策，那么他必然不会拘泥于细节和自己熟悉的范围。</strong></p><p>这个领导者需要审时度势，经常性地反思自己已经做出的决定和形成的观点；他还需要有随时随地接受新观点、新事物、新信息，乃至从新的角度去看待问题的能力；而且，在每个特定的时刻，他都需要基于现有的信息，经过深思熟虑来做出决策。只有这样，一个领导者才有可能在长期的、持续的决策过程中，在大部分情况下都做出正确的决策。</p><p>贝佐斯的观点有很多值得我们学习和深思的地方。从目的出发，一个人如果能够在大部分情况下都做出正确的决策，或者在当前已知条件下做出最好的决策，这个人确实很了不起。而一个公司如果是由这样的人组成的，也必然可以取得令人刮目相看的成就。这一点看起来非常有道理。</p><p>但是我觉得这只是目的， <strong>这条领导力准则精辟的地方在于，它还告诉了我们如何达到这个目的。</strong></p><p>如何达到这个目的，需要一分为二地看：</p><ul><li>首先，每次做决策的时候，一个领导者需要形成一个经过深思熟虑的观点，这个观点可以被自己所掌握的东西有效地支持；</li><li>其次，一个领导者又需要能够跳出自己已经形成的观点，随时吸纳新的东西。</li></ul><p>前者保证了每次决策都不是轻易做出的，每个决定都是深思熟虑的结果。后者又保证在下一次做决策时，他的信息得以更新，因而不会陷于自己已经形成的窠臼。</p><p>第一次看到这条领导力准则时，我感觉一头雾水，因为它真的非常不好理解。但是当我看到贝佐斯向他的团队进行的解释时，颇有一种恍然大悟的感觉。不得不说，任何一个人，如果既能够做到在决策时认真思考、慎重考虑，又可以保持开放的心态，随时随地更新自己的见地和信息，那么我真的很难想象他做出来的决定会错很多、经常错。</p><p>亚马逊出来的高管写过很多文章，其中或多或少都探讨过这条领导力准则。有些人把它放大到亚马逊这家公司的决策上来看，用来解释为什么亚马逊有很多明显不同于其他公司的地方。</p><p>举例来说，亚马逊作为一家公司，推出来的产品和服务失败的案例屈指可数。目前为止，大家熟知的只有一个 Fire Phone。和其他公司比起来，这是亚马逊的一个显著优势。比如，谷歌推出并高调宣传的产品，失败的比例就相对高很多；微软的表现同样如此。</p><p>我们还可以举其他很多公司的例子，但恐怕在美国，的确很难再找到第二家公司，其推出来的产品和服务的成功率如此之高了。</p><p><strong>亚马逊推出来的产品和服务大部分都很成功，这在一定程度上就可以论证：亚马逊在大部分情况下都做出了正确的决策。</strong></p><p>为什么亚马逊可以在大部分情况下做出正确的决策呢？很多在亚马逊待过的高管都认为，这条领导力准则在其中起到了非常重要的作用。</p><p>因为亚马逊做决策的时候，一方面一定会非常慎重地基于已有信息，做出一个仔细思考过的决定，一方面又随时随地根据新信息来重新审视已经做出的决定。所以很多时候，一个产品或者服务尚未公开推向市场时，亚马逊已经在迭代的决策中，做出了最为符合市场预期的正确决策。</p><p>我必须说，这看起来就像一个神话。可是仔细想想，又尽在情理之中。<strong>我们要学习这条领导力准则，不但要理解其目的是尽量做出正确的决策，更需要明白：如何做才能达到这样的结果。</strong></p><h1 id="5-好奇求知"><a href="#5-好奇求知" class="headerlink" title="5.好奇求知"></a>5.好奇求知</h1><h2 id="好奇求知"><a href="#好奇求知" class="headerlink" title="好奇求知"></a>好奇求知</h2><blockquote><p>领导者从不停止学习，并不断寻找机会以提升自己。领导者对各种可能性充满好奇并付于行动加以探索。</p></blockquote><h2 id="Learn-and-Be-Curious"><a href="#Learn-and-Be-Curious" class="headerlink" title="Learn and Be Curious"></a>Learn and Be Curious</h2><blockquote><p>Leaders are never done learning and always seek to improve themselves. They are curious about new possibilities and act to explore them.</p></blockquote><h2 id="讲解-4"><a href="#讲解-4" class="headerlink" title="讲解"></a>讲解</h2><p>我们大致上可以这样来理解这条领导力准则：</p><ol><li>持续学习，不断提升；</li><li>对各种可能性都保持好奇心并且付诸行动。</li></ol><p>贝佐斯强调领导者要保持学习习惯，他自己就经常以身作则，不断进入新的领域展开新的业务。持续学习不仅是领导者的必备技能，从提高个人能力和素质的角度来说，它和不断提升一样也是每个人都应有的状态。</p><p>但是，持续学习作为一条对所有人都大有裨益的通用准则，在互联网公司里面尤为重要。互联网行业的技术和业务发展日新月异，你必须持续学习才能够跟上行业的发展，这对于每个互联网人都是一样的。以我个人经验来看，很多东西我不去接触，过个三五年就改头换面了，老旧的知识完全跟不上时代的需求。</p><p>“好奇求知”的第二部分又可以从两个方面来看，首先是充满好奇心，其次是要付诸行动。这就和其他亚马逊领导力准则相呼应了，比如说亚马逊要求领导者能够全方位、多角度地思考问题，从而做出决策，再比如亚马逊是一个崇尚行动高于讨论的公司，这两点在这条领导力准则上都有反映。</p><p>为什么行动比较重要？关于这一点，“崇尚行动”这条领导力准则可以给出启示。简单回顾一下，贝佐斯认为速度很重要，任何决定和行为，哪怕是不正确的，只要有速度，快速试错，是可以迅速纠正的。所以说，与其浪费时间细化决策，不如果断采取行动，这一点我觉得非常有道理。</p><p>充满好奇心又是对行动力的补充，它使领导者并不只专注于目前行动的某一种可能性，而是对其他事项都保持热情和求知的态度。两者共同组成了贝佐斯对“好奇求知”的完整认识。</p><p>此外，“创新简化”这条准则，其实也是和充满好奇心相呼应的：创新离不开好奇心，只有保持好奇心才能够始终保持创新精神。</p><p>亚马逊领导力准则是一个统一的整体，组成部分间此唱彼和、相得益彰。一条准则里经常可以连带出其他准则的内容，所以我们不应该孤立地解读。</p><p>“好奇求知”要求领导者不断对外部世界进行探索，学习外在的知识，充实自己并付诸行动。但这还不够，亚马逊领导力准则中的“赢得信任”，还要求大家通过“批评和自我批评”来不断反思自身以及他人已经采取的行动，反省内在，自我提高。</p><h1 id="6-选贤育能"><a href="#6-选贤育能" class="headerlink" title="6.选贤育能"></a>6.选贤育能</h1><h2 id="选贤育能"><a href="#选贤育能" class="headerlink" title="选贤育能"></a>选贤育能</h2><blockquote><p>领导者不断提升招聘和晋升员工的标准。他们表彰杰出的人才，并乐于在组织中通过轮岗磨砺他们。领导者培养领导人才，他们严肃地对待自己育才树人的职责。领导者从员工角度出发，创建职业发展机制。</p></blockquote><h2 id="Hire-and-Develop-the-Best"><a href="#Hire-and-Develop-the-Best" class="headerlink" title="Hire and Develop the Best"></a>Hire and Develop the Best</h2><blockquote><p>Leaders raise the performance bar with every hire and promotion. They recognize exceptional talent, and willingly move them throughout the organization. Leaders develop leaders and take seriously their role in coaching others. We work on behalf of our people to invent mechanisms for development like Career Choice.</p></blockquote><h2 id="讲解-5"><a href="#讲解-5" class="headerlink" title="讲解"></a>讲解</h2><p>亚马逊的招聘原则和很多公司不太一样。贝佐斯认为，新员工的加入应该有助于提高亚马逊员工的整体素质，新员工的水平需要高于整体员工的平均水平，只有这样亚马逊的员工素质才会越来越高。</p><p><strong>贝佐斯在接受采访时曾经说过，那些上一年加入亚马逊的人应该为自己感到庆幸。因为如果晚一点来面试，他们很可能无法加入亚马逊。</strong></p><p>简单来说，亚马逊招聘的都应该是最杰出的人才，这一点体现了这项领导力准则的核心思想。在亚马逊，一个员工只有是真正优秀的人才，才能在各岗位的轮岗中生存并且更好地发展。</p><p>亚马逊领导的职责是把这种“选拔天才”的思想，贯彻到每个方面，为优秀的人才创造最合理的职业发展途径。相反，那些并不优秀的人才，又无法在整体环境中得到提升的，随着亚马逊整体素质的渐渐提高，只能被淘汰。</p><p>亚马逊最初进行招聘的时候，贝佐斯严格审查了每一个被雇用的员工，他自己来拍板，来做是否聘用的决定。随着公司规模的扩张，这种办法变得不切实际。但是，贝佐斯在无法亲力亲为的时候想出了一个办法，他找到一群和他保持同样观念的人，然后让这些人按照他的标准参与面试做好把关。这就是亚马逊面试里面特别有特色的 Bar Raiser。</p><p>这种做法，无形中拔高了面试的难度。在亚马逊的面试过程中，这些代表了创始人的面试官有很大的权限，包括可以一票否决整个面试结果。而且他们参与的面试，代表的是整个公司，他们并不对某个特定的组负责，只对公司负责。</p><p>这种做法的主要优点在于，这群人在客观上保证了面试选拔的是最优秀的人才。当然这种选拔并不是没有代价，有时甚至还很严重。比如说因为这种选拨机制，一个人有特定的专长，但综合素质不是太高，很有可能就无法进入亚马逊。因此，如果一个特定的组需要有技术专长的人，很快就会陷入有人却招不进来的状态。</p><p>Bar Raiser 既然有这么重要的权力，要想成为一个 Bar Raiser 自然是非常不易的事情。不管是不是经理，他必须是各方面都非常优秀，并已在公司里面工作多年。除此之外，他需要充分理解创始人的选人标准，能够严格执行公司的招聘原则。所以在亚马逊，如果一个人可以成为一个 Bar Raiser，是一种很大的荣誉。</p><p>Bar Raiser 的一票否决制度，也决定了很多时候 Bar Raiser 会和招人的经理产生冲突，这就非常考验这个人是不是能够在压力面前真正代表公司，为公司招聘到合适的人选。</p><p>我认识很多亚马逊的人，包括在亚马逊里面做经理和总监的人，他们都抱怨过这条制度带来的弊端：招人不容易。在亚马逊，如果一个组刚成立，这时招人是相对容易的。因为很容易招到高于组内平均水平的员工。</p><p>但如果是一个在亚马逊已存在多年的工作组，组内本身已有了很多水平很高的人。在此基础上，要招聘一名高于平均水平的新员工，符合条件的候选人不会很多，而在这些本就不多的人里，通过层层筛选并且成功加入的，这个比例就更少。</p><p>在这种情况下，招人的经理如果严格按标准去做，就会面临无人可招的尴尬局面。而如果不严格执行标准，又违背了这条重要的领导力准则。</p><p>当然，“上有政策，下有对策”。有的领导者把平均水平的考量放到更大的环境下评价。如果说原来是在小组内测评，现在就直接讨论这个人进来对大组的平均水平的影响。所以实际上的问题是，在亚马逊里那些成名的大组，人才济济的，招人对于领导者的挑战非常大。这无疑是这条领导力准则带给领导者的烦恼。</p><p>那么这个制度是否执行得一切顺利呢？如果果真如此，那么现在亚马逊必然网罗到了世界上最优秀的人才，员工的平均水平与日俱增。</p><p>然而，实际情况却是，大家对亚马逊的评价更多集中在领导层面的战略眼光和执行力上；而一旦我们将目光聚焦到普通员工这一层面，大家通常都会认为谷歌、Facebook 的基层人员在素质上要强于亚马逊。这又是为什么呢？</p><p>贝佐斯百密一疏，他没有考虑到优秀人才是会离开的，业务的扩张需要更多的新人补充进来。那么在这一走一留之间，是不是会产生一些问题呢？答案是肯定的。</p><p>因为亚马逊的领导力准则要求，不但要选拔最优秀的员工，而且这些最优秀的员工被招聘进来之后，在内部还需要面临非常严苛和高标准的竞争和培训。</p><p>我们可以想象，作为一个刚从学校毕业，初入职场的人来说，有很多的东西要学。这个时候直接被投入到高标准严要求的环境里，对很多人来说挑战过于巨大。因此进入亚马逊的人，在进去的前 18 个月离开的比例相当高，而且这个比例比全美国大部分互联网企业都高。</p><p>然而占据亚马逊底层员工主力的，很多就是这样一些入职不到 18 个月的员工。整体来说，这个标准不一定适用于衡量基层员工的质量，因为亚马逊里面一些有经验的人离职了，这导致整体队伍的质量自动下降了。招到高于平均水平的新员工，也不能弥补更为有经验更为优秀的老员工流失带来的问题。</p><p>不过，如果我们把这条标准提高一些，去衡量那些在亚马逊工作多年以上的，或者说级别较高的人的素质，会发现亚马逊的中高层领导鲜有庸才，更不用说是尸位素餐的人了。</p><p>中高层领导者素质高的原因是，亚马逊业务扩张非常迅猛，每天都有新的挑战出现，这就促使了新职位的产生。所以那些优秀的员工很大程度上被公司内部消化，在其中磨砺得更为出色，从而成为杰出的中高层领导者。而且相对于基层的流动性，亚马逊的中高层领导者的流动性就不是那么大了。</p><p>亚马逊领导力准则之选贤育能就介绍到这里。贝佐斯对于亚马逊员工的要求是每招进来一个新员工，都要在公司已有员工的平均水平之上。早年贝佐斯亲自参与招聘，后来公司也通过 Bar Raiser 来代表贝佐斯来完成亚马逊的招聘。</p><p>应该说这个领导力准则的初衷是非常好的，但是实际执行的时候则喜忧参半。一方面是这条严苛的制度会导致中低层的员工无人可招，所以就导致上有政策下有对策。另外一方面，人员会流失，优秀的人流失以后，这条制度并不能有效地保证员工素质不下降。</p><p>但是我们可以发现，主要的问题出在中低层的员工上，亚马逊的中高层领导者的素质的确是相当高的。</p><h1 id="7-最高标准"><a href="#7-最高标准" class="headerlink" title="7.最高标准"></a>7.最高标准</h1><h2 id="最高标准"><a href="#最高标准" class="headerlink" title="最高标准"></a>最高标准</h2><blockquote><p>领导者有着近乎严苛的高标准 — 这些标准在很多人看来可能高得不可理喻。领导者不断提高标准，激励自己的团队提供优质产品、服务和流程。领导者会确保任何问题不会蔓延，及时彻底解决问题并确保问题不再出现。</p></blockquote><h2 id="Insist-on-the-Highest-Standards"><a href="#Insist-on-the-Highest-Standards" class="headerlink" title="Insist on the Highest Standards"></a>Insist on the Highest Standards</h2><blockquote><p>Leaders have relentlessly high standards—many people may think these standards are unreasonably high. Leaders are continually raising the bar and drive their teams to deliver high-quality products, services, and processes. Leaders ensure that defects do not get sent down the line and that problems are fixed so they stay fixed.</p></blockquote><h2 id="讲解-6"><a href="#讲解-6" class="headerlink" title="讲解"></a>讲解</h2><p>这条标准从字面上理解，有两个要点：</p><ol><li>领导者要有近乎严苛的高标准，并不断提高标准；</li><li>领导人要确保问题不蔓延，及时解决而且使之不会再现。</li></ol><p>关于什么是“高标准”，贝佐斯给了我们一个评判的基准：这条标准需要在大多数人看来高得不可理喻。</p><p>既然对于大部分人来说，这种标准高得不可理喻，那么普通人肯定不是那么容易达到的。上次讲到，亚马逊就是要选拔最优秀的人才来为己所用，其实这两者是相呼应的：如果没有最优秀的人，也就无法实现最高标准。</p><p>此外，这条领导力准则更要求领导者不断提高这个本来就高到离谱的标准，因为更严苛的标准可以敦促团队为客户提供更优秀的产品、服务和流程。</p><p>在常人看来不可理喻的高标准之上继续推进，这对领导者和团队成员无疑都是巨大的挑战。虽然我们常说“天外有天 “，但也必须承认：人力有穷尽。尽管如此，对高标准的推进依然不可或缺，因为这与人才的选拔、培训以及淘汰机制都密切相关。</p><p>当我第一次读到这个领导力准则时，确实是一种非常严苛的感觉，这需要是一群多么优秀的人才能满足这条领导力准则啊。</p><p>因此，起初我对亚马逊能不能够真正实施这条准则也是感到十分好奇。但亚马逊的市值在过去十年间翻了十倍有余，我想亚马逊在坚持最高标准这条准则上也是卓有成效吧。或许，正是因为亚马逊坚持了最高标准，所以才发展得越来越迅猛。</p><p>而这条领导力准则，或许也可以解释亚马逊基层员工流动率很高的问题。贝佐斯在接受采访时多次提到，他并不在乎亚马逊的高离职率。他认为，只有那些符合公司价值观、自身非常优秀，且能不断提高自己以跟上公司发展节奏的人，才能够长期留在亚马逊；那些因为各类原因无法跟上公司发展节奏的人，在公司的发展过程中被淘汰，其实也是正常的事儿。</p><p>在贝佐斯看来，一个公司要壮大，就需要用到在大部分人看来无法理喻的严苛标准，并在这样的标准上持续提高，以保证公司的持续发展。更新血液，保持进步，这或许就是亚马逊发展势头迅猛的一个原因。</p><p>这条领导力准则的第二部分，专门针对遇到的问题进行了阐述，是很明确的“三步走”程序：领导者要确保问题不会蔓延，要及时解决问题，要确保问题不会再现。我觉得，这种方法非常高明。</p><ul><li><strong>在问题发生之初，及时控制问题，使之不蔓延是非常关键的一步。</strong> 如果我们对于云计算和互联网服务有实践经验的话，但凡出现问题，第一步都是先止血，而不是先追究问题的根源。这种原则同样适用于公司管理，概括来说就是：有问题，先止血，确保问题不蔓延。</li><li><strong>保证问题不蔓延的基础是解决问题。</strong> 解决问题的方式五花八门，然而都离不开对问题的快速定位和反应。之所以这部分内容会出现在这项准则里，我的理解是问题的出现和解决，与标准的执行密切相关。越是严苛的标准就越容易避免问题；而问题出现以后能否迅速反馈，也体现了是不是有一套严苛的标准和成熟的问题解决方案存在。<br>然而我们都知道，当问题出现，尤其是复杂问题出现的时候，无论是控制它，还是迅速解决它，其实都是非常有挑战的事情。此时，标准和流程很大程度上决定了能否有效并迅速地诊断出问题在哪、如何解决。这种先控制问题，再解决问题的步骤，非常具有指导意义。</li><li><strong>最后一部分，是确保问题不会再现。</strong> 如何才能保证问题不再出现？这需要深入分析、了解问题，获知出现问题的原因和内外部条件，找到制度上的疏漏、程序上的缺失，等等。这点其实和“决策正确”这条领导力准则密切相关，有异曲同工之妙。为什么这么说呢？“决策正确”是说在亚马逊，领导者可以偶尔错，但不能一直错，他们需要从一次错误里面吸取教训。没有人可以屏蔽问题，然而一个问题出现一次以后，亚马逊的领导者就应该有能力杜绝再发生同类问题。</li></ul><p>亚马逊的高标准体现在很多方面。举个例子，亚马逊 AWS 的存储服务 S3 在高标准的要求下，故障率比我们自己买一块磁盘存数据出故障的几率还要低。所以久而久之，用户默认 S3 是一个“永远都不会坏的东西”，根本不需要担心 S3 坏掉了应该怎么办的问题。</p><p>要在数目庞大的用户群中建立起“无故障”的印象，这意味着亚马逊要坚持十年如一日执行严格的标准，达到这一点可是相当不易。</p><p>但是很遗憾，亚马逊的 S3 在保持多年不坏的纪录后，终于还是出现了一次大面积的事故。一个程序员本来想关停一部分机器的服务，但是却关停了所有的服务。这次人为事故导致很多网站都无法访问。人们突然才意识到：原来 S3 也是可能出错的，原来“S3 永远稳定”是潜移默化中形成的印象而已，他们在直觉上都把不可思议的事情当成了理所应当。这次事故让大家从这个状态里清醒过来。</p><p>然而正是因为这样，我才真正意识到，亚马逊在十余年如一日地稳定运行 S3 这个服务。这个在大部分人看来不可思议的事情亚马逊做到了。</p><p>按照亚马逊的这条领导力准则，S3 这种问题出现一次以后，领导者就要采取措施避免同类问题再次发生。尽管我们还需要更多事实，来证明这条领导力准则真的被严格贯彻了，但我本人对此非常有信心。</p><h1 id="8-远见卓识"><a href="#8-远见卓识" class="headerlink" title="8.远见卓识"></a>8.远见卓识</h1><h2 id="远见卓识"><a href="#远见卓识" class="headerlink" title="远见卓识"></a>远见卓识</h2><blockquote><p>局限性思考只能带来局限性的结果。领导者大胆提出并阐明大局策略，由此激发良好的成果。他们从不同角度考虑问题，并广泛寻找服务客户的方式。</p></blockquote><h2 id="Think-Big"><a href="#Think-Big" class="headerlink" title="Think Big"></a>Think Big</h2><blockquote><p>Thinking small is a self-fulfilling prophecy. Leaders create and communicate a bold direction that inspires results. They think differently and look around corners for ways to serve customers.</p></blockquote><h2 id="讲解-7"><a href="#讲解-7" class="headerlink" title="讲解"></a>讲解</h2><p>这条领导力原则主要关注领导者的思维方式。贝佐斯要求领导者不拘泥于局限性的思考，要保持脑洞大开的状态。领导者可以从不同的角度去思考问题，发现别人不能发现的，想到别人不能想到的。这种远见对于一家公司的成长来说非常重要。</p><p>早在 2004 年，贝佐斯就开始思索一个问题：随着亚马逊业务的扩张，哪些企业会成为亚马逊最可怕的竞争对手？</p><p>请注意，这里使用了“最可怕的竞争对手”这样的表述，说明“普通的竞争对手”并不在贝佐斯思考范畴之内。这个问题在贝佐斯的脑子里徘徊许久，以至于他开始组织会议讨论这个问题。</p><p>当贝佐斯和他著名的 S-team 讨论竞争对手问题时，首先出现在讨论名单中的主要是包括 BestBuy、Target 在内的电商，当然也包括全球最大的连锁超市沃尔玛这样的传统零售企业。</p><p>这是大多数人的第一反应，S-team 的人也不能免俗。然而在贝佐斯看来，这都属于局限性的思考。道理很简单，这种竞争对手，连一个亚马逊普通员工都能想到，作为杰出的领导层，其实根本不需要去关注。</p><p>贝佐斯认为，这些所谓的竞争对手，哪怕是最牛的沃尔玛，其实都会被亚马逊扫进历史的故纸堆里。毕竟传统的厂商们并不知道如何高效地进行经营和买卖，亚马逊的电商服务才代表了未来。</p><p>这样来讲，如果亚马逊最大的竞争对手还是他们，这不只是对自己缺乏信心，而是杞人忧天了。这显然不符合贝佐斯对亚马逊高管的要求，毕竟他对管理层要求非常严苛，肯定不会满足于只提供这类应答的领导者。贝佐斯对于 S-team 提出的竞争对手表示了不满，这不是他想要的答案。</p><p>这时，S-team 中有人“脑洞大开”地提出了一家公司：谷歌。为什么说是“脑洞大开”呢？因为在 2004 年的时候，谷歌还远非如今这样知名。它作为一个搜索引擎提供商，虽然有全球最厉害的搜索引擎技术，但却一直专注于搜索引擎领域。</p><p>没有上市，又没有那么多钱，无论从什么角度来看，谷歌和亚马逊的电商都没有太多联系。如果一定要说有，谷歌和亚马逊更像是互补的关系，一个厉害的搜索引擎给亚马逊的用户提供了方便之门。正常的逻辑来说，这家企业其实有益无害。</p><p>S-team 中的其他人望着提出想法的人一头雾水。只有贝佐斯像发现新大陆一样，让这个“脑洞大开”的领导者详细阐述他的看法。</p><p>这个人的看法大致上有这么几点。</p><ul><li>首先，搜索这个东西天然就具备了门户的特点，如果用户都使用谷歌去搜索要购买的产品，那么谷歌的导流作用就可以对亚马逊的业务产生实质的威胁。</li><li>其次，谷歌在搜索的过程里面，掌握了大量的用户数据，这些数据足以让谷歌有效分析出亚马逊至关重要的商业机密。</li><li>最后，谷歌作为需要给全球互联网提供搜索服务的公司，大规模计算和分析的能力非常强，所有的这些东西既为谷歌直接进入电商市场，提供了非常坚实的基础，又为谷歌给其他传统企业和电商提供增值服务，提供了非常有效的资源。也就是说，被谷歌技术武装起来的传统厂商们的杀伤力将不可忽略。若一时不慎, 亚马逊的根基都会被掀翻。</li></ul><p>至于谷歌会不会拿着这些技术和信息，自己进入电商市场，或者和其他企业结合，帮助其他企业一起发展业务对抗亚马逊呢？</p><p>这个问题其实很容易回答，谷歌的技术表明了这家公司的优秀水平，谷歌的扩展空间表明了谷歌一定会全方位出击，某天谷歌和亚马逊很可能会短兵相接。如果亚马逊不做好防范，对谷歌潜在的威胁视而不见，等到威胁真的发生时，在亚马逊购物的人已经严重依赖于谷歌的搜索功能了，亚马逊就很难有反抗之力，这显然会危及亚马逊的发展。</p><p>贝佐斯非常赞同这个“脑洞大开”的想法，尽管谷歌在当时看来那么人畜无害，它的搜索引擎又如此好用，帮助亚马逊获得了大量客户。但贝佐斯觉得，亚马逊网站对于谷歌的依赖性已经开始出现了，而有了这种依赖性，天知道会发生什么事情。于是，防范谷歌的威胁，减少亚马逊客户对谷歌的依赖，就成为了这次会议的决策。</p><p>在这个决策的基础上, 亚马逊开展了一项脱离谷歌的计划，这项计划的筹备长达数年。</p><ul><li><strong>首先，亚马逊在它们的全资子公司 A9 上花了大价钱，A9 的主要任务就是做亚马逊网站上商品的搜索和广告技术。</strong>  如果用户能够在亚马逊网站上方便地搜索想要的商品，就用不着额外使用搜索引擎了，所以提高自己网站的搜索能力是非常重要的一步。</li><li><strong>此外，亚马逊同时采取技术手段，避免搜索引擎随意抓取自己网站上的数据。</strong> 这样一来，谷歌这样的搜索引擎，就无法通过抓取为用户提供商品的精准数据，这也就杜绝了谷歌给亚马逊提供搜索的可能。<br>亚马逊觉得自己网站上商品的信息，有着重要的商业价值，如果搜索引擎可以随意获取到数据的话，无疑是把自己非常有价值的东西拱手送人，对于自家的长远发展是非常不利的。</li></ul><p>贝佐斯曾在内部将此事作为脑洞大开的例子提及。他认为，一个管理者只在舒适区内思考问题是不够的，管理者不应该局限自己的思维方式、角度和层次。</p><p><strong>只有眼界足够开阔的管理者，才可能从不同的角度去思考问题，从而为公司的发展提供正确的决策和独特的竞争力。</strong></p><p>这一点对于管理者的要求无疑非常高，因为每个人的思维都有局限性。能够脑洞大开走出思维局限的人，某种程度上不仅是一个管理者，更是具备很强创新能力的人，这在很多时候是种天分。</p><p>在我看来，这个世界上只有一个乔布斯，只有一个通过发明手机改变全世界的人，也只有一个苹果公司。</p><p>亚马逊要求领导者做到这些，却没有说明如何才可以做到。这也表露出贝佐斯的用人原则：我告诉你亚马逊需要什么样的人，如果你是，欢迎加入；如果你不是，无论是天资所限还是努力不够，那么也只能是无缘了。</p><p>这条领导力准则所提出的要求非常之高，并非是靠努力就能达到的。这也侧面反映了满足亚马逊领导力准则的不易。</p><h1 id="9-崇尚行动"><a href="#9-崇尚行动" class="headerlink" title="9.崇尚行动"></a>9.崇尚行动</h1><h2 id="崇尚行动"><a href="#崇尚行动" class="headerlink" title="崇尚行动"></a>崇尚行动</h2><blockquote><p>速度对业务影响至关重要。很多决策和行动都可以改变，因此不需要进行过于广泛的推敲。我们提倡在深思熟虑前提下进行冒险。</p></blockquote><h2 id="Bias-for-Action"><a href="#Bias-for-Action" class="headerlink" title="Bias for Action"></a>Bias for Action</h2><blockquote><p>Speed matters in business. Many decisions and actions are reversible and do not need extensive study. We value calculated risk taking.</p></blockquote><h2 id="讲解-8"><a href="#讲解-8" class="headerlink" title="讲解"></a>讲解</h2><p>贝佐斯认为对于业务来说，速度至关重要。有很多行动和决定，如果觉得是错的，在将来都是可以更改的。如果我们花费很多时间去研究、学习，可能因此耽误速度。而且很可能这一耽误，情况就发生了变化，让竞争对手跑在我们的前面，从而错失良机。所以经过适当考虑后，我们应该尽快采取行动，哪怕这些行动存有风险。</p><p>对于这条领导力准则，我们应该分三部分来看。</p><ol><li>速度对于业务的影响非常非常重要。很多时候业务错失良机，主要就是因为没有采取合适的速度。</li><li>决定和行为都是可以改变的，只要行动足够快，就可以足够灵活。不要担心犯错，足够快了之后，犯了错也是可以迅速纠正的。</li><li>冒险很有必要，尤其是在深思熟虑之后。在风险可控的情况下，冒险是非常有必要的。</li></ol><p>我们先看第一部分。我和亚马逊的朋友交流时得知，在亚马逊一个提案通常不会被反复讨论。哪怕这个提案还不明朗，大家甚至不知道最佳的执行方案，如果经过几轮论证，大家对比了风险和收益，觉得值得尝试，就会立刻转入执行阶段。</p><p><strong>贝佐斯的名言是：速度就是一切。</strong> 能够迅速执行，本身就是成功的一个关键。</p><p>不可否认，现实中一些公司确实是在关键时刻通过深思熟虑来获得成功的，速度本身反而不是最重要的。但在互联网企业和电商的背景下，这种理念就容易理解了。</p><p>“反应迅速敏捷”有时正是特定行业成功的要义。互联网行业以前所未有的速度发展，任何新事物的出现到成熟，往往都远远快过传统行业。这条领导力准则首先就关注“速度”，因为<strong>一个企业能够迅速反应并行动，才是在互联网时代屡战屡胜的不二法门。</strong></p><p>从这一点来说，我们必须承认贝佐斯领会到了互联网企业的精髓，并使其在亚马逊中传承。</p><p>亚马逊是一家非常崇尚实际行动的公司。在亚马逊里，“做出行动”重要无比，速度就是一切。所以一个方案能不能迅速从模拟讨论推进到具体实施，也是对亚马逊员工能力的一个衡量标准。</p><p>再来看第二部分，它是说在速度足够快的情况下，决策或者行动出现了错误可以纠正。只有执行了，你才能知道决策是正确的还是错误的，一开始讨论很多，也许并没有意义。<strong>具体来说，让市场告诉自己是不是犯错了，然后去纠正，是这条领导力准则很重要的组成部分。</strong></p><p>我们放到整个互联网的大环境下来看。亚马逊作为一个互联网公司，其公布出来的产品的失败率非常低，而微软或者谷歌的产品失败率则明显高出一截儿。这是不是说迅速行动了，反而降低了错误呢？其实不是。</p><p>如果和亚马逊里面的人聊天就会知道，亚马逊会很快进入实施阶段，并在小范围内进行尝试。这种小范围的客户可能是内部的其他组，也可能是外部客户，而尝试的主要目的是迅速否定掉没有意义的错误想法和实现。我们看到亚马逊出来的产品成功率很高，其实是因为很多产品在实施阶段后就迅速夭折在内部了。</p><p><strong>这种大量尝试，大量失败，然后纠正决策，继续前进的风格，是非常典型的亚马逊风格。</strong>  外面看见的失败率低，是以内部的大量失败为代价的。</p><p>然而我们应该清楚地认识到一点，一个产品迅速实施失败调整的成本，往往低于将一个产品反复论证后再拿出来，却发现重大缺陷的情况。所以从某种程度上来说，一个崇尚通过行动去证明对错，并能迅速接受反馈、调整行动的企业，本身是非常可怕的。</p><p>而这条领导力准则告诉我们，决策本身的正确性不是无比重要，我们应该提高速度多做尝试，要适当地减少论证。</p><p>第三部分同样值得深思，通俗点说就是：亚马逊鼓励冒险，但前提是心里有数。</p><p>这在某种程度上和“决策正确”这条领导力准则遥相呼应：犯错误是可以的，但是持续犯错误是不行的。领导者需要在大部分情况下保持决策正确。</p><p>换句话说，<strong>如果可以管理好风险，亚马逊鼓励冒险。</strong></p><p>但是如何做到“管理好风险”呢？这既需要审视其他领导力准则的指导和对领导者的要求，又要深刻理解这条领导力准则里“行动比讨论更有意义”这一要义。</p><p>“风险管理”是每个领导者都需要思考的问题。亚马逊既然提倡行动力，那么在执行过程中如何能够迅速判断行动正确与否，并及时去纠正，其实又对领导者的其他能力提出了挑战。</p><p><strong>我想，如何平衡“崇尚行动”和“思考的深度与广度”之间的关系，这是一个很大的挑战。</strong></p><p>亚马逊领导力准则并不否定领导者的思维深度和广度，也未否定对决策能力的严格要求，而且明确表示任何决策都可能出错，所以无休止地讨论思索，还不如早点采取行动更为实际。</p><p>这些不同的要求放在一起，对于一个领导者的挑战是非常巨大的。能够做到这些的人，实可谓是领导者里面的精英了。</p><p>我经常想，如果这么多的要求加诸于我身上，我能做好吗？很难。人和人终究是不同的，每个人擅长的领域不尽相同，总有人更擅长严谨的思维，有人则能够从快速试错里面学习成长。</p><p>所以当你看待领导力准则的时候，不仅要理解亚马逊准则要求领导者如何去工作，更应该明白这个领导力准则其实更像是一个工具，用于筛选出贝佐斯需要的人才。</p><p>与其他领导力准则一样，“崇尚行动”这条准则罗列了亚马逊要的是什么，却没有说如何才能够做到。所以，我们需要结合自身的优缺点，以及已经学习的其他亚马逊领导力准则，去好好思考这样一个问题：亚马逊在找的到底是具备何种综合素质的一类人，这些人被亚马逊招进去以后，又会诞生什么样的企业呢？</p><h1 id="10-勤俭节约"><a href="#10-勤俭节约" class="headerlink" title="10.勤俭节约"></a>10.勤俭节约</h1><h2 id="勤俭节约"><a href="#勤俭节约" class="headerlink" title="勤俭节约"></a>勤俭节约</h2><blockquote><p>力争以更少的投入实现更大的产出。勤俭节约可以让我们开动脑筋、自给自足并不断创新。增加人力、预算以及固定支出并不会为你赢得额外加分。</p></blockquote><h2 id="Frugality"><a href="#Frugality" class="headerlink" title="Frugality"></a>Frugality</h2><blockquote><p>Accomplish more with less. Constraints breed resourcefulness, self-sufficiency and invention. There are no extra points for growing headcount, budget size, or fixed expense.</p></blockquote><h2 id="讲解-9"><a href="#讲解-9" class="headerlink" title="讲解"></a>讲解</h2><p>这条领导力准则对于我们中国人来说非常熟悉了，通俗一点讲就是“勤俭致富”，用尽可能少的投入获得尽可能多的产出。<strong>对于高调宣扬勤俭的亚马逊来说，这条领导力准则确实表现不俗，这里我引用两个例子。</strong></p><p><strong>第一个例子是价廉物美的亚马逊电子商务。</strong> 它的核心就是如何降低成本，从而尽可能地降低物价，来给广大用户提供实惠。</p><p>打个比方，亚马逊在美国是物流做得最好的公司，但是其做物流的原因之一，是公司认为物流做好了才能够做到“节俭”，才是真正的勤俭节约。</p><p>而做到了勤俭节约，自然就有可能做到价廉物美，从而让公司销售上台阶，让用户也得到实惠，形成非常良性的循环。</p><p><strong>第二个例子，我想说说亚马逊目前最红火的、全球最牛的云计算。</strong> 很多人都知道亚马逊的云计算牛，很多人都提到这种“牛”体现在了技术上，但亚马逊公认的“牛”有一点就是对成本的控制。</p><p>怎样做到既可以提供同等的虚拟化计算能力，同时又使自己消耗的物力资源最少，这个事情上只有亚马逊在多年如一日地努力。其结果就是，亚马逊的云计算平台相比其他厂商价格都更便宜；而更牛的是，虽然价格比别人更低廉，但是盈利却比别人多。能够做到这种程度的勤俭节约，不是一般公司可以轻易与其竞争的。</p><p><strong>勤俭节约这条领导力准则的实行，当然也并非没有争议。</strong></p><p><strong>首先，其工作环境无法与其他公司类比</strong>。比如，谷歌和 Facebook 等很多 IT 企业都为员工提供了很好的午餐、晚餐、饮料等福利，而微软虽然不提供午餐、晚餐，但饮料起码是免费的。相较之下，亚马逊只提供很普通的水和咖啡，其他任何东西都要花钱购买。</p><p>有人会说，这其实不是真的勤俭节约，因为只有福利好了，员工才更愿意努力干活，形成良性循环。这到底是不是一种合适的勤俭节约方式，无论在亚马逊内部还是外部都存在争议。</p><p>相较于办公环境，仓库里面的勤俭节约争议性更大。曾有报纸报道，亚马逊在宾夕法尼亚州的仓库里没有安装空调，并因此导致了一次工人热晕，然后被送医院抢救的事件。此事之后被各大媒体争相报道，并受到了美国政府部门的控告，最后亚马逊不得不花钱在仓库里装上了空调。</p><p><strong>此外，为了贯彻勤俭节约的准则，亚马逊还经常会研究公司在哪里成本高了，以及怎样能节约。</strong></p><p>有人就发现，招聘本身就是一个非常耗费资源的事情。比如说，招人时会让这个人飞过来面试，还要提供酒店住宿，但是面试很多个人也许只能招进来一个，这让亚马逊的面试成本一直居高不下。再加上亚马逊非常高的人员离职率，如何降低招聘成本自然成了一个需要考虑的问题。</p><p>不知何时起，对于应届毕业生的招聘，亚马逊不再需要让人飞过来，而是先在网上做几个测试题，合格后再和招人的领导视频聊半小时，就可以了。这种招聘方法一推出，就受到了亚马逊领导们的表扬，毕竟能够迅速地节省招人成本，是一件很好的事情。只是慢慢地，弊端就开始显现了：这样招来的人很多是干不来活的，并不符合实际需求。</p><p>在节省成本上，亚马逊还有一个争议更大的行为。在美国，除非是开除，否则要辞退一个人的话，一般还要象征性地给几个月工资。而且美国的公司在开人上一向比较谨慎。那么，在这方面亚马逊又是怎么做的呢？</p><p><strong>它创新地采用了一个早就有的办法：员工绩效提高计划。</strong></p><p>这个计划的基本思想是，员工表现不好就要放到一个绩效提高计划里去，如果表现还是不行就要辞退了。在美国的公司里，亚马逊是对绩效考核计划用得最频繁的，无论其原意为何，这都为其“开人”降低了成本，也避免了公司按照惯例必须发离职包裹的情况。</p><p>当招聘的创新和绩效考评计划结合起来的时候，问题就来了。在亚马逊，有一段时间一个人入职还不到 3 个月，就可以被领导放进绩效考核计划。这件事情对于刚从学校毕业的大学生们来说，绝对是巨大的挑战。</p><p>于是有人想不开，跳楼了，万幸跳楼的人并没有死。但是事情闹大了。</p><p>被放入员工绩效提高计划的员工可能确实是不合格的，但是这也恰好暴露了招聘程序从简的弊端，即人员筛选不到位。而随后的绩效考核计划，又来得太早，两者相加共同导致了跳楼的悲剧。我们是不是可以说，这也是“节俭”导致的问题呢？</p><p>从实际情况来看，“节俭”这个领导力准则，让亚马逊在方方面面上都考虑成本问题。这种执着于不断优化和降低成本的态度，让亚马逊的很多东西都非常得价廉物美，这不仅仅对用户是好事情，对亚马逊占领更大的市场显然也是好事情。可以说，“节俭”在很大程度上促成了亚马逊的发展，给亚马逊带来了更多的客户。</p><p>但是，我们也能看到很多问题，而争议比较多的事情更多地发生在对待员工方面。员工本身很多时候都希望拥有很好的福利，而且不需要为工作以外的事情烦心。很多公司也都相信，好的福利有助于员工更好地工作和创造价值。但是在亚马逊里面，因为勤俭节约这个领导力准则，员工的福利成本同样被节约了。这其中的利弊，值得你我每个人深思。</p><p>然而不管怎样，勤俭节约的亚马逊给我们带来了方便的物流、便宜的货物和服务，价格优势是亚马逊战胜线上线下竞争对手的利器。而勤俭节约，对于亚马逊获得今天的市场地位同样功不可没。</p><h1 id="11-赢得信任"><a href="#11-赢得信任" class="headerlink" title="11.赢得信任"></a>11.赢得信任</h1><h2 id="赢得信任"><a href="#赢得信任" class="headerlink" title="赢得信任"></a>赢得信任</h2><blockquote><p>领导者专注倾听，坦诚沟通，尊重他人。领导者敢于自我批评，即便这样做会令自己尴尬或难堪。他们并不认为自己或其团队总是对的。领导者会以最佳领导者和团队为标准来要求自己及其团队。</p></blockquote><h2 id="Earn-Trust"><a href="#Earn-Trust" class="headerlink" title="Earn Trust"></a>Earn Trust</h2><blockquote><p>Leaders listen attentively, speak candidly, and treat others respectfully. They are vocally self-critical, even when doing so is awkward or embarrassing. Leaders do not believe their or their team’s body odor smells of perfume. They benchmark themselves and their teams against the best.</p></blockquote><h2 id="讲解-10"><a href="#讲解-10" class="headerlink" title="讲解"></a>讲解</h2><p>这条领导力准则可以解读为三点内容：</p><ol><li>领导者能够倾听，坦诚沟通以及尊重他人；</li><li>领导者善于自我批评；</li><li>领导者对于自己和团队都要有高要求。</li></ol><p><strong>“赢得信任”这条准则的第一部分主要是沟通的态度和方式，“倾听”是很重要的一部分。</strong> 贝佐斯非常痛恨办公室政治，他有次开会时提到，每次站在自己的办公室窗口，望着隔湖相对的微软就在想：当自己的公司壮大了，绝不能成为湖对岸那个政治气氛浓厚的公司。</p><p>他理想的状态是：公司的每个人都是领导者，每个人都能够倾听别人，坦诚沟通，并尊重其他人的见解。只有这样状态下的公司，才是高效率、低内耗的，才能够实现更好的发展。</p><p>达到这种理想状态非常不易。但是，贝佐斯觉得人和人之间的信任非常重要，没有了信任，公司就容易滋生小团体，就会因为人员各怀鬼胎而分崩离析。微软在从一个小软件公司成长为全球最大软件公司的过程中，小团体的内斗已经上演了。贝佐斯肯定是对这种文化十分了解，所以才会多次极力表示，他所创立的企业，不应该存在这种病态。</p><p>而具体到领导者，要赢得他人信任并学会坦诚和尊重十分必要，要能听进别人的意见。这在贝佐斯的谈话中反复被强调。</p><p><strong>第二部分是“自我批评”。</strong> 中华文化的传统美德里比较强调自我批评，这些东西对于我们来说可能是习以为常了，但西方社会更强调个人价值的实现。所以如果在美国待久了，一个人往往会呈现出一种“自我表扬”的状态，我在微软工作时对此就感觉十分明显。</p><p>在职场上印度人非常成功，其中一个原因也是他们比较擅长自我表扬。在美国职场上，奖励自我表扬，而不奖励自我批评是常态。贝佐斯会把自我批评放进领导力准则，这一点实在出人意料。</p><p>不过，仔细想来，贝佐斯的做法也在情理之中。一个擅长自我表扬的环境坏处是很明显的，每个人都在讲述自己的功绩，展现自己的成就，没有人去审视自己做的事情，反省自己做得是否合适。</p><p>这样一来，企业难免会浮躁，管理层也很容易变得张扬。这种问题不仅仅在初创企业中出现，在大企业中也同样存在。谷歌上市之后就有一段时间自我膨胀，妄图在各个领域同时出击，以至于后来全方位败退以后，才开始考虑自己到底擅长什么。这说明即便是优秀的企业，如果失去了自我反省能力，也是非常可怕的。</p><p>在西方思维的大环境下，贝佐斯依然将“自我批评”这点写进企业的领导力准则，实在值得敬佩，这说明贝佐斯对于西方传统文化里的弊端有着深刻的思考和见解。这些领导力准则造就了亚马逊，使它有别于很多典型的西方企业。从某种程度上来讲，亚马逊在很多方面的成功，确实是很多西方企业所没有达到的。</p><p><strong>第三部分，其实是对其他领导力准则的重复了。简单来说，领导者对自己也好对团队也罢，都应该执行最严格的标准，这一点在亚马逊得到了全方位的体现。</strong> 作为领导者，严格要求自己和团队，也是必不可少的基础内容。试想，若无法以最严格的标准去要求自己和团队，一个领导者怎么才能获得工作伙伴的信任呢？</p><p>“赢得信任”要求你学会倾听与沟通，要在自我批评和自我审视中寻求改进的可能性，并通过严要求获得同事、下属以及上级的信任。</p><p>总结来说，领导者需要有“好奇求知”的精神，和“赢得信任”的能力，他需要不断探索外部世界，不断学习提高并能够付诸行动，在“批评与自我批评”中不断反思和完善自己。</p><h1 id="12-刨根问底"><a href="#12-刨根问底" class="headerlink" title="12.刨根问底"></a>12.刨根问底</h1><h2 id="刨根问底"><a href="#刨根问底" class="headerlink" title="刨根问底"></a>刨根问底</h2><blockquote><p>领导者深入各个环节，随时掌控细节，经常进行审核，当数据与传闻不一致时持有怀疑态度。领导者不会遗漏任何工作。</p></blockquote><h2 id="Dive-Deep"><a href="#Dive-Deep" class="headerlink" title="Dive Deep"></a>Dive Deep</h2><blockquote><p>Leaders operate at all levels, stay connected to the details, audit frequently, and are skeptical when metrics and anecdote differ. No task is beneath them.</p></blockquote><h2 id="讲解-11"><a href="#讲解-11" class="headerlink" title="讲解"></a>讲解</h2><p>在微软、 IBM 这样的大企业，一名员工一旦成为经理，往往只注重高层面上的东西而不愿深入细节。主要原因有两个，其一是他们距离细节比较遥远，其二是他的上级乃至更上级的领导只需要看到宏观的东西。所以深入细节对于他来说，没有实际的奖赏。但是，这对领导者管理公司却未必是好事。</p><p>关于这一点，贝佐斯给大家树立了一个很好的榜样。在亚马逊，每时每刻都发生着各种事件，比如网站运行慢了，再比如某个功能无法使用了等等。只要是与公司相关的事情，贝佐斯总是事必躬亲地参与进来。比如，他本人经常会出人意料，随机进入一个在开的会议，或是亲自给人发邮件汇报或解释事情等等。</p><p>很多人会奇怪了，贝佐斯是怎么知道这么多事情的？从公开的渠道来看，主要有两方面原因。</p><ul><li>一方面是，公司内部大大小小的邮件列表，贝佐斯都在里面。贝佐斯喜欢时不时地随机查看某个邮件组里的邮件。</li><li>另外一方面是，公司内部给贝佐斯写 Email 的渠道很畅通，贝佐斯（或者其秘书）总能在最短的时间内，知道公司内部发生的大大小小的异常事件。</li></ul><p><strong>贝佐斯在很多场合都强调过，领导者不应只局限于大局。无论是处于什么位置的领导者，都需要有深入细节、随时掌控各个环节的能力。只有这样，公司才能够良好运作。</strong></p><p><strong>这条准则的第二部分是对审核的严要求。</strong> 要知道，亚马逊内部完全数据化了，具体到打开网站需要多少时间，直至每个功能最多允许出现多少错误等等，量化的体系使亚马逊非常依赖数据去做决策。使用数据来做决策本身不是坏事，这起码好过拍脑门儿做决策的工作方式。然而用数据做决策，很多时候也会出现偏差。</p><p>数据出错的原因有很多，但无论是数据本身出错，还是说实际状态才是错误的，只要最终数据结果与实际状态不符，领导者就需要彻查。在亚马逊这样的状况经常出现，这就需要领导者时刻保持警觉状态。</p><p>因此，<strong>可以说对任何事物都保持谨慎和怀疑的态度，是领导力准则很重要的一点。</strong></p><p><strong>关于这个领导力准则的最后一部分，即“不会遗漏任何工作”，与之前提及的“最高标准”其实是一脉相承的。</strong> 一个领导者应该面面俱到，不遗漏任何东西，这其实是以极其严苛的、常人看来不可思议的标准去要求自己和团队的结果。</p><p>亚马逊领导力准则里除了提出领导者要深入细节，不遗漏任何工作的要求，也强调工作时要能抓住工作的关键决定条件，并以最终完成工作、达成业绩作为判断工作好坏的指标。深入细节，绝非眉毛胡子一把抓。</p><h1 id="13-敢于谏言，服从大局"><a href="#13-敢于谏言，服从大局" class="headerlink" title="13.敢于谏言，服从大局"></a>13.敢于谏言，服从大局</h1><h2 id="敢于谏言，服从大局"><a href="#敢于谏言，服从大局" class="headerlink" title="敢于谏言，服从大局"></a>敢于谏言，服从大局</h2><blockquote><p>领导者必须要能够不卑不亢地质疑他们无法苟同的决策，哪怕这样做让人心烦意乱，精疲力尽。领导者要信念坚定，矢志不移。他们不会为了保持一团和气而屈就妥协。一旦做出决定，他们就会全身心地致力于实现目标。</p></blockquote><h2 id="Have-Backbone-Disagree-and-Commit"><a href="#Have-Backbone-Disagree-and-Commit" class="headerlink" title="Have Backbone; Disagree and Commit"></a>Have Backbone; Disagree and Commit</h2><blockquote><p>Leaders are obligated to respectfully challenge decisions when they disagree, even when doing so is uncomfortable or exhausting. Leaders have conviction and are tenacious. They do not compromise for the sake of social cohesion. Once a decision is determined, they commit wholly.</p></blockquote><h2 id="讲解-12"><a href="#讲解-12" class="headerlink" title="讲解"></a>讲解</h2><p>从字面上来看，这条领导力准则还是比较难理解的，因此我先引用下贝佐斯在亚马逊里面对员工做的解释。大体上贝佐斯的要求分为三部分。</p><ol><li><p>“领导者必须能够不卑不亢地质疑他们无法苟同的决策，哪怕这样做让人心烦意乱、精疲力尽。领导者要信念坚定、矢志不移。他们不会为了保持一团和气而屈就妥协。”<br>这一段往往是最容易理解的。在亚马逊里面，所谓的“领导者”并不是指有领导职务的人，而是亚马逊的全体员工。<strong>也就是说，亚马逊的每一位员工，都必须有坚定的信念，能够敢于说“不”，坚决说“不”，绝对不随便因为要维持一团和气，或者维持上下级之间的关系等而违心地说是.</strong></p></li><li><p>“一旦做出决定，他们就会全身心地致力于实现目标。”<br>这是第二部分，它的意思是：服从大局。写得很简单，但是解释同样得多。这里的意思是：<strong>一旦一个决定做出来了，哪怕是讨论过程中存疑的一方，也需要从现在开始，完全地聚拢到决定上来，全力以赴地执行决定。</strong></p></li><li><p>而贝佐斯特地强调的第三点，其实并没有出现在这段文字里。或者，你也可以将其理解为第二点的一部分。<br>这个第三点是说：<strong>当一个决定做出并且执行了以后，最后的结果如果是失败的，那么参与执行的所有人，都应该重新检查审视这个结果，但是绝对不允许“当初如果听了我的，就会怎么怎么样”的言论存在。</strong></p></li></ol><p>那么我们来详细看一下这几点都反应了什么。贝佐斯给他自己挑选了一个 S-team，这个团队由亚马逊里的一些高管组成。挑 S-team 的原因是贝佐斯希望这个队伍里的人对自己实施这条领导力准则。</p><p>贝佐斯相信没有人是天才，所以一旦要做重要决定了，大家都要能够坚持自己的观点。当然，所有这些观点都要基于合理的理由，而不仅仅是个人的喜好。</p><p>贝佐斯觉得，<strong>办公室政治是非常浪费公司时间和精力的。而为了维持上下级间的一团和气，从而不愿意说“不”，进而造成决策的失误，对一家公司来说要付出的代价很大。</strong>因此，在亚马逊，贝佐斯不喜欢也不希望大家因为办公室政治而失去了对真理的追求。</p><p><strong>与其大家忙碌于维持和领导的关系，不如每个人都致力于对真理的追求。</strong>这样一来，一个重大决定在做出前就会被反复讨论，从而尽可能地避免或重大或微小的失误。贝佐斯对于 S-team 中每个人的要求，也是完全基于这样一个原则的。</p><p>这个准则的第二部分是：一旦参与项目的人经过了各种各样的讨论，或者通过讨论达成了一致，或者更有可能的情况是作为最高决策者，在大家互相不能说服的情况下，拍板做出了一个决定，那么在这之后，所有人都必须全力以赴地执行这个决定。而不是说有些人因为自己的意见看法没有得到实现，从而开始偷懒敷衍，或者在决定已经做出的情况下，对外界宣扬自己的不同看法，进而给外界造成一种不团结的印象。</p><p><strong>也就是说，一个决定一旦做出，就要求不存在异类和不全力以赴的情况。造成不团结的言论和行为，都是违反这个领导力准则的。</strong></p><p>第三部分，也是特意强调的一个部分，它是说这个决定的做出既然是集体反复讨论的结果，那么即便最后证明这个结论是不成功的，大家对于这件事情的检讨也应该仅限于就事论事。公司里绝对不允许把做出结论前个人的不同意见搬出来，并作为幸灾乐祸的理由。</p><p>这三条内容放在一起，某种程度上就反映了亚马逊的一种做事风格。亚马逊对于市场的反应速度是非常快、非常有效的。我们都可以看到，一旦市面上出现了一些新的动向，亚马逊相对于其他大企业来说，往往能够根据实际情况，非常迅速地做出反应，而且这种迅速反应很多时候都极为准确。和其他公司对比亚马逊所发布产品的成功率，就可以非常充分地说明这一点。</p><p>此外，<strong>亚马逊同样可怕的地方在于：这个机构一旦做出了决定，那么整个公司的机器就会被全面开动起来，不打折扣地执行决定。</strong></p><p>这不像很多公司存在的官僚做派，被否决的一方给决定采纳的一方添堵。这种执行方式对于一家大公司来讲是非常值得赞扬的。集中所有的资源没有分歧地执行下去，一个庞然大物一旦开动了这样的机器，对于竞争对手来说，就很可怕了。</p><p>这条准则的最后一部分还彻底杜绝了所谓“秋后算账”的做法。<strong>这种做出决定以后大家一起承担责任，然后就事论事进行改进的态度，是有效杜绝办公室政治的好办法。</strong> 贝佐斯作为一位卓有远见的领导，提出的这条领导力准则，确实有很多值得我们每个人思考的地方。</p><p>一家企业大了，官僚味儿就出来了。我们大凡能看到的企业，从 IBM 到微软到谷歌，其实都无法避免官僚化，亚马逊则在最高领导层上通过贯彻领导力准则，很大程度上避免了大公司病。从这个角度来说，我想贝佐斯的确做到了很多公司都没能做到的东西。</p><h1 id="14-达成业绩"><a href="#14-达成业绩" class="headerlink" title="14.达成业绩"></a>14.达成业绩</h1><h2 id="达成业绩"><a href="#达成业绩" class="headerlink" title="达成业绩"></a>达成业绩</h2><blockquote><p>领导者会关注其业务的关键决定条件，确保工作质量并及时完成。尽管遭受挫折，领导者依然勇于面对挑战，从不气馁。</p></blockquote><h2 id="Deliver-Results"><a href="#Deliver-Results" class="headerlink" title="Deliver Results"></a>Deliver Results</h2><blockquote><p>Leaders focus on the key inputs for their business and deliver them with the right quality and in a timely fashion. Despite setbacks, they rise to the occasion and never settle.</p></blockquote><h2 id="讲解-13"><a href="#讲解-13" class="headerlink" title="讲解"></a>讲解</h2><p>从字面意思来理解其实非常容易，“达成业绩”简单来说就是最后把东西做出来，有一丝“以结果论英雄”的意味。做企业不是请客吃饭，最终是要为股东创造利润的。所以在亚马逊领导力准则里，最后一条就是强调任何领导者都应达成业绩。</p><p><strong>以“结果”来说明一个领导者到底是不是合格，这在何时何地都是毋庸置疑的硬指标。</strong></p><p>贝佐斯在这一条准则中，不仅提出了要求，而且深入探讨了如何做到达成业绩。这包括两个方面：</p><ol><li>关注业务的关键决定条件，确保工作质量并及时完成；</li><li>面对挫折不气馁。</li></ol><p>第一部分谈及了达成业绩的关键：工作质量和工作速度。掌握两者间的平衡，其实是一门很大的学问。但凡有过大项目开发经验的人都知道，要求质量了，速度不一定能上去，速度上去了，质量可能又会是问题。所以在不降低质量的前提下，更好地提高速度，是需要技巧和耐心的。贝佐斯能够指出质量和速度是业绩的关键，很有远见。</p><p>在这一条领导力准则里，贝佐斯特意强调了要面对挫折不气馁，想来他在创建亚马逊，以及达成业绩的过程中必然遭遇了很多挫折，所以他才要将这一点写入领导力准则。当然，这只是我一家之言，并没有特别的证据支持。</p><p><strong>虽然说，以成败论英雄不一定正确，但在企业行为来看“结果”一定非常重要。</strong></p><p>或许你要问了，亚马逊强调做决策要为长远目标而服务，不能为短期利益牺牲长远的规划和利益，但同时却又强调需要有业绩，那么远期目标和近期业绩之间的平衡点到底在哪里呢？</p><p>对此，亚马逊领导力准则并没有给出答案，贝佐斯也没有表述过他的看法。但是我想，领导力准则给出来的是纲领性的东西，而把纲领性的东西融会贯通，成为一个好的领导者，就需要看每个人的悟性和能力了。</p><p>至于这种平衡点到底在哪里，也许具体到每个问题上会有所不同。而能否做好远期目标和近期业绩之间的平衡，这正是一个优秀的领导者和一个平庸的领导者的区别。</p><h1 id="15-致力于成为全球最佳雇主"><a href="#15-致力于成为全球最佳雇主" class="headerlink" title="15.致力于成为全球最佳雇主"></a>15.致力于成为全球最佳雇主</h1><h2 id="致力于成为全球最佳雇主"><a href="#致力于成为全球最佳雇主" class="headerlink" title="致力于成为全球最佳雇主"></a>致力于成为全球最佳雇主</h2><blockquote><p>领导者致力于打造一个更安全、更高生产力、更高效、更多元、更公平的工作环境。领导者具备同理心，享受工作乐趣，并帮助他人也在工作中获得乐趣。领导者时常自省：团队成员在成长吗？他们是否被赋能？是否准备好迎接未来？领导者对员工的个人成功拥有愿景和承诺，无论这成功是在亚马逊还是在其他地方。</p></blockquote><h2 id="Strive-to-be-Earth’s-Best-Employer"><a href="#Strive-to-be-Earth’s-Best-Employer" class="headerlink" title="Strive to be Earth’s Best Employer"></a>Strive to be Earth’s Best Employer</h2><blockquote><p>Leaders work every day to create a safer, more productive, higher performing, more diverse, and more just work environment. They lead with empathy, have fun at work, and make it easy for others to have fun. Leaders ask themselves: Are my fellow employees growing? Are they empowered? Are they ready for what’s next? Leaders have a vision for and commitment to their employees’ personal success, whether that be at Amazon or elsewhere.</p></blockquote><h1 id="16-成功和规模带来更大的责任"><a href="#16-成功和规模带来更大的责任" class="headerlink" title="16.成功和规模带来更大的责任"></a>16.成功和规模带来更大的责任</h1><h2 id="成功和规模带来更大的责任"><a href="#成功和规模带来更大的责任" class="headerlink" title="成功和规模带来更大的责任"></a>成功和规模带来更大的责任</h2><blockquote><p>亚马逊诞生于车库，但并未止步于此。亚马逊的业务规模庞大，对世界产生着影响，但我们还远非完美。我们必须时刻保持谦虚，并谨慎思考我们的行动带来的潜在影响。我们所在的社区、地球和后代需要我们每日精益求精做到更好。为了惠及客户、员工、合作伙伴以及全球更多人，我们必须抱着进步的决心开启每一天，并在每天结束时，深信明天可以更有作为。领导者要创造远超其所消费的更多价值，做到发现问题、并推动事物向更好的方向发展。</p></blockquote><h2 id="Success-and-Scale-Bring-Broad-Responsibility"><a href="#Success-and-Scale-Bring-Broad-Responsibility" class="headerlink" title="Success and Scale Bring Broad Responsibility"></a>Success and Scale Bring Broad Responsibility</h2><blockquote><p>We started in a garage, but we’re not there anymore. We are big, we impact the world, and we are far from perfect. We must be humble and thoughtful about even the secondary effects of our actions. Our local communities, planet, and future generations need us to be better every day. We must begin each day with a determination to make better, do better, and be better for our customers, our employees, our partners, and the world at large. And we must end every day knowing we can do even more tomorrow. Leaders create more than they consume and always leave things better than how they found them.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>亚马逊</tag>
      
      <tag>管理</tag>
      
      <tag>领导力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode经典算法题（只刷这些足够了）</title>
    <link href="/posts/741192809.html"/>
    <url>/posts/741192809.html</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>不要问我为什么，总之从两位业界算法大牛获取到这份算法面试刷题题库。毕竟leetcode有那么多题，如何快速高效备战面试也是有诀窍的。over~</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ul><li><a href="http://leetcode-cn.com/problems/two-sum">两数之和</a>（简单）  <a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a>（简单） <a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/decode-string/">字符串解码</a>（中等） <a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/lru-cache/submissions/">LRU缓存机制</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/LRUCache.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/implement-trie-prefix-tree/">实现Trie（前缀树）</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/Trie.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/add-and-search-word-data-structure-design/">添加与搜索单词-数据结构设计</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/word-search-ii/">单词搜索II</a> （困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/find-the-difference/">找不同</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%89%BE%E4%B8%8D%E5%90%8C.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/word-pattern/">单词规律</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/first-unique-character-in-a-string">字符串中的第一个唯一字符</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/longest-substring-without-repeating-characters">无重复字符的最长子串</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/merge-two-sorted-lists">合并两个有序链表</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/linked-list-cycle">环形链表</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/linked-list-cycle-ii">环形链表II</a> （中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/reverse-linked-list">反转链表</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/reverse-linked-list-ii">反转链表II</a> （中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/rotate-list">旋转链表</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/sort-list/">排序链表</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/swap-nodes-in-pairs">两两交换链表中的节点</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/sort-array-by-parity/">按奇偶排序数组</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/sort-array-by-parity-ii/">按奇偶排序数组II</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/squares-of-a-sorted-array/">有序数组的平方</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/peak-index-in-a-mountain-array">山脉数组的峰顶索引</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/search-in-rotated-sorted-array">搜索旋转排序数组</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组II</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值II</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/search-a-2d-matrix">搜索二维矩阵</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/satisfiability-of-equality-equations/">等式方程的可满足性</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7.java">代码实现</a></li><li><a href="https://leetcode.cn/problems/number-of-provinces/submissions/">省份数量</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/accounts-merge/">账户合并</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/basic/%E8%B4%A6%E6%88%B7%E5%90%88%E5%B9%B6.java">代码实现</a></li></ul><h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><ul><li><a href="http://leetcode-cn.com/problems/maximum-depth-of-binary-tree">二叉树的最大深度</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/depth/first/search/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/path-sum/">路径总和</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/depth/first/search/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/path-sum-ii/">路径总和II</a> （中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/depth/first/search/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/depth/first/search/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/number-of-islands/">岛屿数量</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/depth/first/search/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/max-area-of-island/">岛屿的最大面积</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/depth/first/search/%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/distribute-coins-in-binary-tree/">在二叉树中分配硬币</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/depth/first/search/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81.java">代码实现</a></li></ul><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul><li><a href="http://leetcode-cn.com/problems/generate-parentheses/">括号生成</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/backtracking/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/n-queens/">N皇后</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/backtracking/N%E7%9A%87%E5%90%8E.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/n-queens-ii/">N皇后II</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/backtracking/N%E7%9A%87%E5%90%8EII.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/sudoku-solver/">解数独</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/backtracking/%E8%A7%A3%E6%95%B0%E7%8B%AC.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/unique-paths-iii/">不同路径III</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/backtracking/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84III.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/word-search/">单词搜索</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/backtracking/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2.java">代码实现</a></li></ul><h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><ul><li><a href="http://leetcode-cn.com/problems/search-a-2d-matrix-ii/">搜索二维矩阵II</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/divide/conquer/%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/merge-k-sorted-lists">合并K个排序链表</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/divide/conquer/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/different-ways-to-add-parentheses">为运算表达式设计优先级</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/divide/conquer/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/expression-add-operators">给表达式添加运算符</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/divide/conquer/%E7%BB%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/kth-largest-element-in-an-array">数组中的第K个最大元素</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/divide/conquer/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/k-closest-points-to-origin/">最接近原点的K个点</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/divide/conquer/%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84K%E4%B8%AA%E7%82%B9.java">代码实现</a></li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li><a href="http://leetcode-cn.com/problems/min-cost-climbing-stairs">使用最小花费爬楼梯</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/climbing-stairs">爬楼梯</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E7%88%AC%E6%A5%BC%E6%A2%AF.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/unique-paths/">不同路径</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a> （中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/maximum-subarray/">最大子数组和</a> （简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/maximum-product-subarray/">乘积最大子数组</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机II</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机III</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机IV</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">买卖股票的最佳时机含手续费</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/coin-change">零钱兑换</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/coin-change-2">零钱兑换II</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/edit-distance">编辑距离</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/distinct-subsequences/">不同的子序列</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/maximal-rectangle/">最大矩形</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/maximal-square/">最大正方形</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/minimum-cost-for-tickets/">最低票价</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/range-sum-query-immutable/">区域和检索-数组不可变</a>（简单）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/range-sum-query-2d-immutable/">二维区域和检索-矩阵不可变</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/longest-increasing-subsequence">最长递增子序列</a>（中等）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.java">代码实现</a></li><li><a href="http://leetcode-cn.com/problems/super-egg-drop/">鸡蛋掉落</a>（困难）<a href="https://gitee.com/darkranger/beating-interviewer/blob/master/src/main/java/com/wujunshen/algorithm/leetcode/dynamic/programming/%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD.java">代码实现</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quarkus学习笔记2</title>
    <link href="/posts/3713165389.html"/>
    <url>/posts/3713165389.html</url>
    
    <content type="html"><![CDATA[<h1 id="idea新建quarkus项目"><a href="#idea新建quarkus项目" class="headerlink" title="idea新建quarkus项目"></a>idea新建quarkus项目</h1><h2 id="确定安装了quarkus插件"><a href="#确定安装了quarkus插件" class="headerlink" title="确定安装了quarkus插件"></a>确定安装了quarkus插件</h2><p><img src="/img/quarkus/A361119A-63D7-4E21-BA5A-8EA91EB9FCCC.png"></p><h2 id="new-project"><a href="#new-project" class="headerlink" title="new project"></a>new project</h2><p><img src="/img/quarkus/D51B5E83-AF00-4D96-AAB5-73BDA3F1487D.png"></p><p>选择已安装graalvm的java17版本</p><p>如何安装graalvm的java17版本，可见<a href="/posts/877356228.html#graalvm">graalvm</a></p><p><img src="/img/quarkus/B665EE8E-41E7-4798-A8A2-B13E13FA186E.png"></p><p><img src="/img/quarkus/A6959508-98A3-4128-B6FD-F724EC5370D8.png"></p><p>可选择各种扩展，或者不选，直接create</p><p>指定graalvm的java17版本</p><p><img src="/img/quarkus/A88DCF4B-C700-46E4-B239-D72522744A7B.png"></p><p>指定项目模块配置</p><p><img src="/img/quarkus/825CBDFC-0793-4326-A429-A5A40B606E90.png"></p><p>新建好的quarkus项目如下</p><p><img src="/img/quarkus/16D2F543-9ABD-4433-A6D3-6DC6822D349B.png"></p><h1 id="如何启动quarkus项目"><a href="#如何启动quarkus项目" class="headerlink" title="如何启动quarkus项目"></a>如何启动quarkus项目</h1><h2 id="第一种启动方式"><a href="#第一种启动方式" class="headerlink" title="第一种启动方式"></a>第一种启动方式</h2><p>点击红框按钮</p><p><img src="/img/quarkus/868D143C-98D9-4772-9BB8-D7A208BE270C.png"></p><p>输入</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">mvn compile quarkus<span class="token operator">:</span>dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><img src="/img/quarkus/08BFDA2E-96E7-418F-B143-FE213A4B9D48.png"></p><p>启动成功后，点击红框链接</p><p><img src="/img/quarkus/122A88A3-8979-4C21-8EE3-D77A7F6F17D8.png"></p><p>界面一览</p><p><img src="/img/quarkus/E6A0AD91-C3A8-4AC2-A4B1-C4C2F7B2E36D.png"></p><p>点击下方红色划线</p><p><img src="/img/quarkus/9AFB6246-CC61-4DC8-8B80-88FDBB1F38E8.png"></p><p>效果如下</p><p><img src="/img/quarkus/B9FD4556-C450-40BF-9C9D-767F35BDD41B.png"></p><p>还提供一个开发者界面</p><p><a href="http://localhost:8080/q/dev/">http://localhost:8080/q/dev/</a></p><p>随便点了几下，效果如如下</p><p><img src="/img/quarkus/5E54DD0F-E753-4BD9-8182-EF1117452327.png"></p><p><img src="/img/quarkus/8F32C5B1-BE7D-4361-8D6D-E1047474DD32.png"></p><p><img src="/img/quarkus/E232CC11-E590-4413-9093-957E5EE62B2A.png"></p><p><img src="/img/quarkus/F7C2CC47-FF5F-456F-915F-2AF04EF3BC06.png"></p><h2 id="第二种启动方式"><a href="#第二种启动方式" class="headerlink" title="第二种启动方式"></a>第二种启动方式</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">mvn clean <span class="token keyword">package</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>然后执行</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">java <span class="token operator">-</span>jar target<span class="token operator">/</span>quarkus<span class="token operator">-</span>app<span class="token operator">/</span>quarkus<span class="token operator">-</span>run<span class="token punctuation">.</span>jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>效果如下</p><p><img src="/img/quarkus/B15B8025-AF97-4259-94BE-8966C61AFC11.png"></p><p>但这个不是像spring-boot那样直接可执行的jar包，要想像spring-boot那样可执行，需要如下</p><h2 id="第三种启动方式"><a href="#第三种启动方式" class="headerlink" title="第三种启动方式"></a>第三种启动方式</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">mvn <span class="token keyword">package</span> <span class="token operator">-</span><span class="token class-name">Dquarkus</span><span class="token punctuation">.</span><span class="token keyword">package</span><span class="token punctuation">.</span>type<span class="token operator">=</span>uber<span class="token operator">-</span>jarjava <span class="token operator">-</span>jar target<span class="token comment">/*-runner.jar</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p><img src="/img/quarkus/4E84840E-A517-464C-876B-1DAD95FADCF8.png"></p><h2 id="第四种启动方式（原生方式）"><a href="#第四种启动方式（原生方式）" class="headerlink" title="第四种启动方式（原生方式）"></a>第四种启动方式（原生方式）</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">mvn <span class="token keyword">package</span> <span class="token operator">-</span><span class="token class-name">Pnative</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>如果没安装native-image</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">mvn <span class="token keyword">package</span> <span class="token operator">-</span><span class="token class-name">Pnative</span> <span class="token operator">-</span><span class="token class-name">Dquarkus</span><span class="token punctuation">.</span><span class="token keyword">native</span><span class="token punctuation">.</span>container<span class="token operator">-</span>build<span class="token operator">=</span><span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>执行成功后如下图</p><p><img src="/img/quarkus/00C18046-BF69-40A2-92EB-122723374761.png"></p><p>然后执行</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span>/target<span class="token operator">/</span>quarkus<span class="token operator">-</span>demo<span class="token operator">-</span><span class="token number">1.0</span><span class="token operator">-</span>SNAPSHOT<span class="token operator">-</span>runner<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><img src="/img/quarkus/77915776-9730-4179-A7F4-CCCDD997548A.png"></p><p>如何安装native-image，见<a href="/posts/877356228.html#native-image">native-image</a><br>更多原生启动方式资料可见</p><p><a href="https://quarkus.io/guides/maven-tooling">https://quarkus.io/guides/maven-tooling</a></p><blockquote><p>注意</p><p>以上几种启动项目方式，默认端口都是8080，所以需要考虑到端口被占用情况，不能同时启动，如果是Mac系统，输入端口是否被占用的命令，然后杀进程</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">lsof <span class="token operator">-</span>i<span class="token operator">:</span><span class="token number">8080</span>kill <span class="token operator">-</span><span class="token number">9</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>杀掉其余进程，保证有一个进程启动着就行</p></blockquote><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>更多官网学习资料见</p><p><a href="https://quarkus.io/guides/">https://quarkus.io/guides/</a></p><p>右上角选择相应版本</p><p><img src="/img/quarkus/C37C0EE7-EE49-48FA-B7CC-A9F9E0B6319B.png"></p>]]></content>
    
    
    <categories>
      
      <category>Quarkus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Quarkus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quarkus学习笔记1</title>
    <link href="/posts/1146829303.html"/>
    <url>/posts/1146829303.html</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>是一个全栈Kubernetes云原生Java开发框架，可以配合Java虚拟机做本地应用编译，它是专门针对容器进行优化的 Java 框架。可以促使 Java 成为 Serverless（无服务）、云原生和Kubernetes环境中的高效开发基础。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>容器优先</li><li>云原生</li><li>统一命令+响应式</li><li>基于java</li><li>微服务优先</li><li>开发乐趣</li></ul><h1 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h1><ul><li>节省资源和成本</li><li>技术优势明显</li><li>全面支持云原生和serverless</li><li>提高云原生开发生产力</li></ul><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><ul><li>构建微服务体系</li><li>构建Serverless体系</li><li>响应式系统</li><li>物联网业务</li><li>单体转微服务</li></ul><h1 id="为啥要学习Quarkus"><a href="#为啥要学习Quarkus" class="headerlink" title="为啥要学习Quarkus?"></a>为啥要学习Quarkus?</h1><ul><li>技术优势<ul><li>比传统java应用内存消耗减少到十分之一</li><li>比传统java应用启动速度加快300倍</li></ul></li><li>开发体验<ul><li>易于使用</li><li>运行模式可供选择，JVM or Native</li><li>整合优化配置</li><li>统一命令式和响应式两种编程方式</li><li>阻塞和非阻塞结合在一起</li></ul></li><li>扩展第三方框架</li><li>社区活跃</li></ul><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>三大部分</p><ul><li>JVM平台层</li><li>Quarkus 核心框架</li><li>Quarkus Extensions框架</li></ul><p><img src="/img/quarkus/architecture.png" alt="架构图"></p><ul><li>JVM平台层。包括HotSpot VM和SubstrateVM<ul><li>HotSpot VM 是 Sun JDK 和 OpenJDK 中的虚拟机，也是目前使用范围最广的 Java 虚拟机。它是JVM实现技术，与以往的实现方式相比，在性能和扩展能力上得到了很大的提升</li><li>SubstrateVM主要用于Java虚拟机语言的AOT编译，SubstrateVM的启动时间和内存开销非常少。SubstrateVM的轻量特性使其适合嵌入其他系统中</li></ul></li><li>Quarkus 核心框架层。包括 Jandex、Gizmo、GraalSDK、Arc、Quarkus Core 等<ul><li>Jandex是JBoss的库</li><li>Gizmo 是 Quarkus 开源的字节码生成库</li><li>GraalVM是以Java HotSpot虚拟机为基础，以 Graal 即时编译器为核心，以能运行多种语言为目标，包含一系列框架和技术的大集合基础平台。这是一个支持多种编程语言的执行环境，比如 JavaScript、Python、Ruby、R、C、C++、Rust 等语言，可显著地提高应用程序的性能和效率<br>GraalVM 还可以通过 AOT（Ahead-Of-Time）编译成可执行文件来单独运行（通过SubstrateVM）</li><li>Arc（DI）是Quarkus 的依赖注入管理，其内容是io.quarkus.arc，这是CDI的一种实现</li></ul></li><li>Quarkus Extensions框架层。包括RESTEasy、Hibernate ORM、Netty、Eclipse Vert.x、Eclipse MicroProfile、Apache Camel等外部扩展组件<ul><li>Eclipse Vert 扩展组件<br>该组件是 Quarkus 的网络基础核心框架扩展组件。但由于该扩展组件位于底层，故开发者一般不会察觉</li><li>RESTEasy 扩展组件<br>RESTEasy 框架是 JBoss 的一个开源项目，提供了各种框架来帮助构建RESTful Web Services和RESTful Java应用程序框架</li><li>Hibernate扩展组件<br>这是对关系型数据库进行处理的ORM框架集成，遵循JPA规范</li><li>Eclipse MicroProfile扩展组件<br>会在响应式和消息流中使用该扩展组件</li><li>Elytron 扩展组件<br>主要用于安全类的扩展，包括 elytron-security-jdbc、elytron-security-ldap、elytron-security-oauth2等</li><li>Keycloak 扩展组件<br>这是应用 Keycloak 开源认证授权服务器的扩展组件，包括 quarkus-keycloak-authorization、quarkus-oidc等</li><li>SmallRye 扩展组件<br>这是响应式客户端的扩展组件，SmallRye是一个响应式编程库</li><li>Narayana 扩展组件<br>这是处理数据库事务的扩展组件</li><li>Kafka 扩展组件<br>这是应用Kafka开源消息流平台的扩展组件</li><li>Artemis 扩展组件<br>这是应用Artemis开源消息服务器中间件的扩展组件</li><li>Agroal 扩展组件<br>这是数据库连接池的扩展组件</li><li>Redis 扩展组件<br>这是应用Redis开源缓存服务器的扩展组件</li><li>Spring 扩展组件<br>这是应用Spring框架的扩展组件</li><li>Kubernetes 扩展组件<br>这是应用Kubernetes服务器的扩展组件</li><li>JSON 集成扩展<br>组件有Jackson、JAXB等</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><img src="/img/quarkus/Quarkus%E5%9F%BA%E7%A1%80.png" alt="基础"></p><h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><p><img src="/img/quarkus/Quarkus%E5%AD%A6%E4%B9%A0%E7%9B%AE%E7%9A%84.png" alt="学习目的"></p><h2 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h2><p><img src="/img/quarkus/Quarkus%E6%9E%B6%E6%9E%84.png" alt="架构"></p>]]></content>
    
    
    <categories>
      
      <category>Quarkus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Quarkus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Graalvm安装</title>
    <link href="/posts/877356228.html"/>
    <url>/posts/877356228.html</url>
    
    <content type="html"><![CDATA[<h1 id="graalvm"><a href="#graalvm" class="headerlink" title="graalvm"></a>graalvm</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>从下面链接 <a href="https://github.com/graalvm/graalvm-ce-builds/releases">https://github.com/graalvm/graalvm-ce-builds/releases</a> 下载</p><p>我的电脑 <code>macOS</code> (<code>aarch64/M1</code>)且已安装java17</p><p>java17</p><p><a href="https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-22.1.0/graalvm-ce-java17-darwin-aarch64-22.1.0.tar.gz">https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-22.1.0/graalvm-ce-java17-darwin-aarch64-22.1.0.tar.gz</a></p><p>If you are using macOS Catalina and later you may need to remove the quarantine attribute from the bits before you can use them<br>To do this, run the following:</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo xattr -r -d com.apple.quarantine path&#x2F;to&#x2F;graalvm&#x2F;folder&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>迁移到java安装目录，并设置<code>JAVA_HOME</code></p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo mv graalvm-ce-java17-22.1.0 &#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachinesexport PATH&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;graalvm-ce-java17-22.1.0&#x2F;Contents&#x2F;Home&#x2F;bin:$PATHexport JAVA_HOME&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;graalvm-ce-java17-22.1.0&#x2F;Contents&#x2F;Home<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>To check whether the installation was successful, run the <code>java -version</code> command.</p><h1 id="native-image"><a href="#native-image" class="headerlink" title="native-image"></a>native-image</h1><h2 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h2><p>java17</p><p><a href="https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-22.1.0/native-image-installable-svm-java17-darwin-aarch64-22.1.0.jar">https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-22.1.0/native-image-installable-svm-java17-darwin-aarch64-22.1.0.jar</a></p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo mv native-image-installable-svm-java17-darwin-aarch64-22.1.0.jar &#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;sudo gu install -L native-image*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><h2 id="制作快捷路径"><a href="#制作快捷路径" class="headerlink" title="制作快捷路径"></a>制作快捷路径</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vi &#x2F;usr&#x2F;local&#x2F;bin&#x2F;native-image<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>加入以下内容</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">oldJH&#x3D;$JAVA_HOMEJAVA_HOME&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;graalvm-ce-java17-22.1.0&#x2F;Contents&#x2F;HomeoldPath&#x3D;$PATHPATH&#x3D;$JAVA_HOME&#x2F;bin:$PATHnative-image $*JAVA_HOME&#x3D;$oldJHPATH&#x3D;$oldPATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>然后赋权</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;native-image<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h2 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h2><p>随便哪个目录输入<code>native-image --help</code> ,出现下图所示即安装成功</p><p><img src="/img/graalvm/1.png" alt="安装成功"></p>]]></content>
    
    
    <categories>
      
      <category>Quarkus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Quarkus</tag>
      
      <tag>Graalvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/posts/4206121381.html"/>
    <url>/posts/4206121381.html</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆其实是个完全二叉树</p><ul><li>每个结点的值都大于或等于其左右孩子结点的值，称为最大堆</li><li>每个结点的值都小于或等于其左右孩子结点的值，称为最小堆</li></ul><p><img src="/img/heap/13D70C61-09AF-4ED9-96A9-2312B141E585.png" alt="最大堆和最小堆"></p><p>图一是最大堆，图二是最小堆</p><p>完全二叉树概念<br>叶子节点只能出现在最下层和次下层，且最下层的结点都集中在该层最左边的若干位置的二叉树</p><p>图例</p><p><img src="/img/heap/F1A766EF-D846-49C9-9C58-B5B9DDA28D97.png" alt="完全二叉树"></p><h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><p>就是最大堆，特点如下图</p><p><img src="/img/heap/95E88F5E-9068-4573-A649-0CA0DA2495D6.png" alt="最大堆特点"></p><p>源码实现，包括main测试方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinaryHeap</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> HEAP_DEGREE <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heap<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> heapSize<span class="token punctuation">;</span>  <span class="token comment">/** This will initialize our heap with default size. */</span>  <span class="token keyword">public</span> <span class="token class-name">BinaryHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    heapSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    heap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">BinaryHeap</span> maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryHeap</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxHeap<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxHeap<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxHeap<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxHeap<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxHeap<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxHeap<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxHeap<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxHeap<span class="token punctuation">.</span><span class="token function">printHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxHeap<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxHeap<span class="token punctuation">.</span><span class="token function">printHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxHeap<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxHeap<span class="token punctuation">.</span><span class="token function">printHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> heapSize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> heapSize <span class="token operator">==</span> heap<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> HEAP_DEGREE<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">kthChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> HEAP_DEGREE <span class="token operator">*</span> i <span class="token operator">+</span> k<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/**   * Inserts new element in to heap Complexity: O(log N) As worst case scenario, we need to traverse   * till the root   */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token string">"Heap is full, No space to insert new element"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    heap<span class="token punctuation">[</span>heapSize<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    heapSize<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">heapifyUp</span><span class="token punctuation">(</span>heapSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/** Deletes element at index x Complexity: O(log N) */</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token string">"Heap is empty, No element to delete"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> maxElement <span class="token operator">=</span> heap<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    heap<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>heapSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    heapSize<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token function">heapifyDown</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> maxElement<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/** Maintains the heap property while inserting an element. */</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">heapifyUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> insertValue <span class="token operator">=</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> insertValue <span class="token operator">></span> heap<span class="token punctuation">[</span><span class="token function">parent</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span><span class="token function">parent</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      i <span class="token operator">=</span> <span class="token function">parent</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> insertValue<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/** Maintains the heap property while deleting an element. */</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">heapifyDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> child<span class="token punctuation">;</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">kthChild</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> heapSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      child <span class="token operator">=</span> <span class="token function">maxChild</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">>=</span> heap<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>      i <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">maxChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> leftChild <span class="token operator">=</span> <span class="token function">kthChild</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rightChild <span class="token operator">=</span> <span class="token function">kthChild</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> heap<span class="token punctuation">[</span>leftChild<span class="token punctuation">]</span> <span class="token operator">></span> heap<span class="token punctuation">[</span>rightChild<span class="token punctuation">]</span> <span class="token operator">?</span> leftChild <span class="token operator">:</span> rightChild<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/** Prints all elements of the heap */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"nHeap = "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> heap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/** This method returns the max element of the heap. complexity: O(1) */</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token string">"Heap is empty."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>堆</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法汇总介绍</title>
    <link href="/posts/3278271016.html"/>
    <url>/posts/3278271016.html</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>二分查找又叫作折半查找，要求待查找的序列<strong>有序</strong>，每次查找都取中间位置的值与待查值进行比较，如果中间位置的值比待查值大，则在序列的左半部分继续执行该查找过程，如果中间位置的值比待查值小，则在序列的右半部分继续执行该查找过程，直到查找到值为止，否则在序列中没有待查值</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在有序数组[3,4,6,20,40,45,51,62,70,99,110]中查找key&#x3D;20的数据，根据二分查找，只需查找2次便能命中数据。这里需要强调的一点是，二分查找要求要查找的集合是有序的，如果不是有序集合，则先要通过排序算法排序后再进行查找</p><p><img src="/img/algorithm/93A1C418879DCFE94E8F35DA64109F5B.jpg" alt="原理"></p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinarySearch</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> high <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 中间位置</span>      mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> mid<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 向右查找</span>        low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 向左查找</span>        high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>广度优先遍历(Breadth First Search,BFS),又叫宽度优先遍历或横向优先遍历，是从根结点开始沿着树的宽度搜索遍历</p><p><img src="/img/algorithm/287CE5E81F72BCF8FB8872F928E83449.jpg" alt="广度优先遍历"></p><p>如图，广度优先遍历顺序为：ABCDEFG</p><h2 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BFS</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/**   * 计算从起点 start 到终点 target 的最近距离   *   * @param start 起始节点   * @param target 终止节点   * @return 步数   */</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> start<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 核心数据结构</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 避免走回头路</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 相邻节点</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> adj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将起点加入队列</span>    q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 记录扩散的步数</span>    <span class="token keyword">int</span> step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">/* 将当前队列中的所有节点向四周扩散 */</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 划重点: 这里判断是否到达终点 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> step<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 将cur的相邻节点加入队列 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          adj<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          adj<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span> x <span class="token operator">:</span> adj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">/* 划重点: 更新步数在这里 */</span>      step<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> step<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> left<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>深度优先搜索(Depth First Search,DFS)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支</p><p>如广度优先遍历所用图，深度优先遍历顺序为：ABDECFG</p><h2 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DFS</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 递归模板</span>      <span class="token keyword">boolean</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token class-name">Node</span> cur<span class="token punctuation">,</span> <span class="token class-name">Node</span> target<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">></span></span> visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token keyword">if</span> cur is target<span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span>next <span class="token operator">:</span> each neighbor of cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>next is not in visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  add next <span class="token keyword">to</span> <span class="token namespace">visted</span><span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token keyword">if</span> <span class="token function">DFS</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> target<span class="token punctuation">,</span> visited<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">;</span>              <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归就是自己调用自己，把一个问题分解成可以同样操作的子问题</p><h2 id="形成条件"><a href="#形成条件" class="headerlink" title="形成条件"></a>形成条件</h2><ul><li>子问题须与原始问题解决算法是同样一个算法</li><li>不能无限制地调用自己，必须有个出口，化为非递归状况</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>数据定义是按递归定义的（Fibonacci方法）</li><li>问题解法按递归算法实现<br>这类问题虽然本身没有明显的递归结构，但用递归比迭代求解更简单（汉诺塔问题）</li><li>数据结构形式是按递归定义的（树）</li></ol><p>二叉树从任意一个节点拆开，依然是一颗二叉树。换句话说，二叉树天生就可以把问题分解成子问题，而这类问题一般都是采用递归解决的</p><h2 id="代码模板-3"><a href="#代码模板-3" class="headerlink" title="代码模板"></a>代码模板</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   terminator   <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">></span> MAX_LEVEL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// process result</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>             <span class="token comment">// process current logic</span>   <span class="token function">process</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// drill down</span>   <span class="token function">recur</span><span class="token punctuation">(</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> newParam<span class="token punctuation">)</span><span class="token punctuation">;</span>   restore current status<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>又称试探法。从问题的某一状态出发，不断“试探”着往前走一步，当一条路走到“尽头”，不能再前进（拓展出新状态）时，再倒回一步或者若干步，从另一种可能的状态出发，继续搜索，直到所有的“路径”都试探过了。这种不断前进、不断回溯，寻找解的方法，称为回溯法</p><h2 id="形成条件-1"><a href="#形成条件-1" class="headerlink" title="形成条件"></a>形成条件</h2><p>回溯实际上就是一个决策树的遍历过程</p><ul><li>路径<br>也就是已经做出的选择</li><li>选择列表<br>也就是当前可以做的选择</li><li>结束条件<br>到达决策树底层，无法再做选择的条件</li></ul><h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p>搜索算法、数独、八皇后问题、全排列、正则表达式匹配和编译原理中语法分析等</p><h2 id="代码模板-4"><a href="#代码模板-4" class="headerlink" title="代码模板"></a>代码模板</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> result <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backTrack</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>choiceList<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//满足结束条件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token class-name">Choice</span> choice<span class="token operator">:</span>choiceList<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//做选择</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> choiceList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//撤销选择</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成的算法</p><h2 id="形成条件-2"><a href="#形成条件-2" class="headerlink" title="形成条件"></a>形成条件</h2><ol><li>问题规模缩小到一定程度就可轻易解决</li><li>问题可分解为若干个规模较小的相同问题，即该问题具有最优子结构性质</li><li>利用该问题分解出的子问题解可合并成该问题的解</li><li>问题分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题</li></ol><p>第1个是绝大多数问题都可满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加<br>第2个是应用分治法的前提，它也是大多数问题都可满足，此特征反映了递归思想<br>第3个是关键，能否利用分治法完全取决于问题是否具有这个特征，如果具备前两个，而不具备第3个，则可考虑用贪心法或动态规划<br>第4个涉及到分治法效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法比较好</p><h2 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h2><p>降低问题求解的时间复杂度，解决海量数据处理问题等</p><h2 id="代码模板-5"><a href="#代码模板-5" class="headerlink" title="代码模板"></a>代码模板</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token class-name">Problem</span> problem<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//terminator</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>problem <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//print result</span>     <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//prepare data</span>  data <span class="token operator">=</span> <span class="token function">prepareData</span><span class="token punctuation">(</span>problem<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">Array</span><span class="token punctuation">[</span><span class="token punctuation">]</span> subProblems <span class="token operator">=</span> <span class="token function">splitProblem</span><span class="token punctuation">(</span>problem<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//conquer subProblems</span>  subResult1 <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">divideConquer</span><span class="token punctuation">(</span>subProblems<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>  subResult2 <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">divideConquer</span><span class="token punctuation">(</span>subProblems<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>  subResult3 <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">divideConquer</span><span class="token punctuation">(</span>subProblems<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>  <span class="token comment">//process and generate the final result</span>  result <span class="token operator">=</span> <span class="token function">processResult</span><span class="token punctuation">(</span>subResult1<span class="token punctuation">,</span> subResult2<span class="token punctuation">,</span> subResult3<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//revert the current level states</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h2><p>每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划</p><h2 id="基本思想与策略"><a href="#基本思想与策略" class="headerlink" title="基本思想与策略"></a>基本思想与策略</h2><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解</p><p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中</p><p>与分治法最大的差别是</p><blockquote><p>适用于动态规划求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，要进行进一步的求解）</p></blockquote><h2 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h2><p>用动态规划求解的问题一般要具有下列3个性质</p><ol><li>最优化原理<br>如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理</li><li>无后效性<br>即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关</li><li>有重叠子问题<br>即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到(该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势)</li></ol><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><p>动态规划要解决的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)</p><p>动态规划的设计都有着一定的模式，一般要经历以下几个步骤</p><ol><li>划分阶段<br>按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段，注意划分后的阶段一定要有序的或者是可排序的，否则问题就无法求解</li><li>确定状态和状态变量<br>将问题发展到各个阶段时，所处于的各种客观情况用不同的状态表示。当然，状态的选择要满足无后效性</li><li>确定决策并写出状态转移方程<br>因为决策和状态转移有着天然的联系，状态转移是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就能被写出来。但事实上，常常是反过来，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程</li><li>寻找边界条件<br>给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件</li></ol><p>只要解决问题的<strong>阶段</strong>、<strong>状态</strong>和<strong>状态转移</strong>决策确定了，就可写出状态转移方程（包括边界条件）</p><p>实际应用，可按以下几个简化的步骤进行设计</p><ul><li>分析最优解的性质，并刻画其结构特征</li><li>递归的定义最优解</li><li>以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</li><li>根据计算最优值时得到的信息，构造问题的最优解</li></ul><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><p><img src="/img/algorithm/F0748769A760F4E7C5D552639C15C34B.jpg" alt="关键点"></p><h2 id="模板实现"><a href="#模板实现" class="headerlink" title="模板实现"></a>模板实现</h2><p>使用动态规划求解问题，最重要的就是确定动态规划三要素</p><ol><li>问题的阶段</li><li>每阶段的状态</li><li>从前一个阶段转化到后一个阶段之间的递推关系</li></ol><p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处</p><p>确定了动态规划的这三要素，整个求解过程就可用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解</p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h2><p>是一种在每步选择中都采取当前状态下最好或最优(最有利)选择，从而希望结果是全局最好或最优的算法</p><h3 id="和动态规划的不同"><a href="#和动态规划的不同" class="headerlink" title="和动态规划的不同"></a>和动态规划的不同</h3><p>不同点在于贪心对每个子问题的解决方法都作出选择，不能回退。动态规划则会保存以前的运算结果，并根据之前结果对当前进行选择，有回退功能</p><h2 id="形成条件-3"><a href="#形成条件-3" class="headerlink" title="形成条件"></a>形成条件</h2><p>问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解被称为最优子结构</p><h2 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h2><p>解决最优化问题，比如: 哈夫曼编码</p><p>一旦一个问题可以通过贪心算法来解决，那么它可能是解决这个问题的最佳方案。因为其高效性和求得答案比较接近最优结果，贪心算法可以当做辅助算法或直接解决一些要求结果不特别精确的问题</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分查找</tag>
      
      <tag>广度优先遍历</tag>
      
      <tag>深度优先遍历</tag>
      
      <tag>递归</tag>
      
      <tag>回溯</tag>
      
      <tag>分治</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Set</title>
    <link href="/posts/3730400060.html"/>
    <url>/posts/3730400060.html</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>继承于<code>Collection</code>接口，是一个不允许出现重复元素且无序的集合，主要包括<code>HashSet</code>和<code>TreeSet</code>两个实现类</p><p>判断重复元素时，<code>HashSet</code>调用<code>hashCode()</code>和<code>equal()</code>方法实现；<code>TreeSet</code>调用<code>compareTo</code>方法实现</p><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>用来存储没有重复元素的集合类，且无序。实现<code>Set</code>接口。底层使用机制就是<code>HashMap</code>（见<a href="1029785637.html">HashMap</a>章节），所以也是线程不安全的</p><p>见源码（java11）</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//定义了HashMap类型的成员变量，拥有HashMap所有属性</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> map<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>不可重复</li><li>无序</li><li>线程不安全</li><li>集合元素可以为<code>null</code>，但只能放一个<code>null</code></li><li>使用场景: 去重、不要求顺序</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>底层使用<code>HashMap</code>的<code>key</code>不能重复机制来实现没有重复的<code>HashSet</code></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>哈希表结构，主要利用<code>HashMap</code>的<code>key</code>来存储元素，计算插入元素的<code>hashCode</code>值来获取元素在集合中的位置</p><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p><code>TreeSet</code>实现了<code>SortedSet</code>接口，意味着可以排序，它是一个有序并且没有重复的集合类，底层是通过<code>TreeMap</code>实现。<code>TreeSet</code>并不是根据插入的顺序来排序，而是字典自然排序。线程不安全</p><p><code>TreeSet</code>支持两种排序方式: 自然升序排序和自定义排序。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul><li>不可重复</li><li>有序，默认自然升序排序</li><li>线程不安全</li><li>集合元素不可以为<code>null</code></li></ul><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p><code>TreeSet</code>底层基于<code>treeMap</code>（红黑树结构）实现，可自定义比较器对元素进行排序，或是使用元素的自然顺序</p><p>使用场景: 去重、要求排序</p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p>红黑树结构，每个元素都是树中的一个节点，插入的元素都会进行排序</p><h1 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h1><p><code>LinkedHashSet</code>使用<code>HashSet</code>机制实现，是一个可保证插入顺序或访问顺序，且没有重复的集合类。线程不安全</p><p>数据结构: 数组+双向链表<br><code>Entry</code>结构: <code>before|hash|key|value|next|after</code>，<code>before</code>和<code>after</code>用于维护整个双向链表。</p><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul><li>集合元素不可以为<code>null</code></li><li>线程不安全</li></ul><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><code>LinkedHashSet</code>底层使用了<code>LinkedHashMap</code>机制(比如<code>before</code>和<code>after</code>),加上又继承了<code>HashSet</code>，所以可实现既可以保证迭代顺序，又可以达到不出现重复元素</p><p>使用场景: 去重、需要保证插入或者访问顺序</p><h1 id="HashSet、TreeSet、LinkedHashSet的区别"><a href="#HashSet、TreeSet、LinkedHashSet的区别" class="headerlink" title="HashSet、TreeSet、LinkedHashSet的区别"></a>HashSet、TreeSet、LinkedHashSet的区别</h1><p><code>HashSet</code>只去重，<code>TreeSet</code>去重且排序，<code>LinkedHashSet</code>去重且保证迭代顺序</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="/posts/3455415529.html"/>
    <url>/posts/3455415529.html</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>java5开始才有的并发类，可以高效地支持并发操作。基本上就是个线程安全版的HashMap。但是key和value都不能为null，这点和HashMap不同</p><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="java8之前"><a href="#java8之前" class="headerlink" title="java8之前"></a>java8之前</h2><p>Segment数组+HashEntry数组+链表结构</p><p>它由一个个Segment组成，Segment就是我们说的分段锁，一个HashEntry数组对应一个分段锁</p><p>简单说，ConcurrentHashMap就是一个Segment数组，Segment通过继承ReentrantLock来加锁，每次需要加锁的操作，锁住的是一个Segment，这样只要保证每个Segment线程都安全，也就保证了全局是线程安全的</p><p>如下图<br><img src="/img/ConcurrentHashMap/D3A76B10-9779-41EE-8885-F67562F9BA78.png" alt="保证每个Segment线程安全"></p><blockquote><p>初始化后Segment数组是无法扩容的，能扩容的只有HashEntry数组。如果初始化时候，没有指定segment数组长度，默认为16。如果指定长度，则使用指定长度</p></blockquote><p>基本属性源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 段掩码，用于定位段，默认值15，不可变 */</span><span class="token keyword">final</span> <span class="token keyword">int</span> segmentMask<span class="token punctuation">;</span><span class="token comment">/** * 段偏移量，用于定位段，默认值28，不可变 */</span><span class="token keyword">final</span> <span class="token keyword">int</span> segmentShift<span class="token punctuation">;</span><span class="token comment">/** * 段数组 */</span><span class="token keyword">final</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 真正存储数据的数组     */</span>    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token comment">/**     * 用于统计当前Segement大小，即HashEntry数组长度     */</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment">/**     * 记录结构性修改次数，用于快速失败     */</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>    <span class="token comment">/**     * 阈值     */</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment">/**     * 负载因子，默认 0.75     */</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">//节点hash值</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token comment">//节点key值</span>    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>    <span class="token comment">//节点value值</span>    <span class="token keyword">volatile</span> <span class="token class-name">V</span> value<span class="token punctuation">;</span>    <span class="token comment">//下个节点引用</span>    <span class="token keyword">volatile</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>从以上代码可知，一个<code>Segment</code>就是一个<code>HashMap</code>，多个<code>HashMap</code>组成一个<code>ConcurrentHashMap</code>。<code>segmentMask</code>和<code>segmentShift</code>组合起来用于定位Segment数组的下标位置</p><p>由于目前java已发展到14版本，因此对于<code>java8</code>之前的版本，<code>ConcurrentHashMap</code>操作只做文字说明，有兴趣的可自行查看java7等8之前的版本源码</p><h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><ol><li>计算待put数据key的hash值</li><li>根据hash值、segmentShift和segmentMask通过无符号右移运算和位运算定位到哪个Segment，一个 Segment对应一个HashEntry数组</li><li>尝试获取锁，如果获取失败则自旋获取锁</li><li>根据hash值通过位运算得到HashEntry数组的下标，即得到链表的头节点，然后遍历链表</li><li>如果链表不为空，判断传入的key和hash值与当前遍历的key和hash值是否相等，相等则覆盖旧的value</li><li>如果链表为空（即表头为空），则根据待put数据的key和value创建结点，即初始化链表</li><li>判断元素个数是否超过阈值，数组长度大于阈值threshold且小于最大容量，则进行rehash扩容</li><li>如果不需扩容，则把新节点放到HashEntry数组中对应的位置（即把新的节点设置成原链表的表头，头插法）</li><li>最后释放锁</li></ol><h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><ol><li>计算get数据key的hash值</li><li>根据hash值、segmentShift和segmentMask通过无符号右移运算和位运算定位到哪个Segment，一个 Segment对应一个HashEntry数组</li><li>根据hash值通过位运算得到HashEntry数组下标，即得到链表的头节点，然后遍历链表</li><li>判断传入的key和hash值与当前遍历的key和hash值是否相等，相等则返回对应value，否则返回null</li></ol><h3 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h3><ol><li>创建新HashEntry数组，数组长度是原来的2倍，重新计算新的阈值</li><li>遍历旧数组，把每个元素（即HashEntry链表）迁移到新数组里面，步骤如下</li><li>如果旧数组只有一个结点，则直接放入新数组中</li><li>如果链表有多个结点，遍历旧链表，计算存放在新数组中的位置，使用头插法插入到新数组，即旧链表的表头结点做为新链表的尾结点</li><li>迁移完成之后将待新增数据插入链表的头部（头插法），最后将新数组的引用替换旧的</li></ol><h2 id="从java8开始及之后版本"><a href="#从java8开始及之后版本" class="headerlink" title="从java8开始及之后版本"></a>从java8开始及之后版本</h2><p>几个变化</p><ol><li>使用Node数组作为数据的基本存储。但锁粒度被缩小到数组中的每个下标位置上，数据读取的可见性依靠volatile来保证。尝试写入时，会将对应的下标位置上的元素作为加锁对象，使用synchronized进行加锁，来保证并发写入的安全性</li><li>如果多个Key的hashcode在取模后落在了相同的下标位置上，且在一定数量内（默认是8），采用链表方式连接节点；超过之后，为提高查询效率，会转为红黑树结构进行存储（和HashMap一样树化成红黑树）</li><li>当进行扩容时，除了扩容线程本身，如果其他线程识别到扩容正在进行中，则会尝试协助扩容</li></ol><h3 id="和java8之后的HashMap相同点"><a href="#和java8之后的HashMap相同点" class="headerlink" title="和java8之后的HashMap相同点"></a>和java8之后的HashMap相同点</h3><ul><li>底层数据结构一致（数组+链表+红黑树）</li><li>数组初始化都是在第一次put元素时进行，而不是new对象时候</li><li>数组长度都总是为2的幂</li><li>默认树化的阈值为8，而退化为链表的阈值为6</li><li>hash算法也很类似，ConcurrentHashMap也是key的hashCode值右移16位和原值取异或。但多了一步，和HASH_BITS取与，这是是为了消除最高位上的负符号，hash的负值在ConcurrentHashMap中有特殊意义表示在扩容或者是树节点(下文都会提及)</li></ul><p>下面从源码角度说明几个操作(java11版本)</p><h3 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** Implementation for put and putIfAbsent */</span><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//1.使用spread方法得到key的hash</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span> <span class="token class-name">K</span> fk<span class="token punctuation">;</span> <span class="token class-name">V</span> fv<span class="token punctuation">;</span>        <span class="token comment">//2.第一次调用put时才调用initTable方法来初始化Node数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.如果相应位置的Node节点还未初始化，则通过CAS插入相应的数据</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// no lock when adding to empty bin</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//4.如果对应Node不为空，且其hash标识为特定负数，也就是标识容器正在扩容的负数，此时需协助扩容</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>            tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>onlyIfAbsent <span class="token comment">// check first node without acquiring lock</span>                 <span class="token operator">&amp;&amp;</span> fh <span class="token operator">==</span> hash                 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fk <span class="token operator">=</span> f<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>fk <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>fk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>fv <span class="token operator">=</span> f<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> fv<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">V</span> oldVal <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token comment">//5.执行元素添加</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//5.1该节点的hash不小于0，则遍历链表更新节点或插入新节点</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token class-name">K</span> ek<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                                 <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                    e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token comment">//5.2如果是TreeBin类型节点，说明是红黑树，则通过putTreeVal方法往红黑树中插入节点</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span>                        binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>                                                       value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">ReservationNode</span><span class="token punctuation">)</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Recursive update"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//6.采用链表存储节点，且链表长度超过阀值，则将链表转化为红黑树(树化)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD<span class="token punctuation">)</span>                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//7.容器内元素总数+1，并在需要时执行扩容</span>    <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ol><li>使用spread方法得到key的hash<br>源码<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> HASH_BITS <span class="token operator">=</span> <span class="token number">0x7fffffff</span><span class="token punctuation">;</span> <span class="token comment">// usable bits of normal node hash</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> HASH_BITS<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>HASH_BITS值0x7FFFFFFF是一个用16进制表示的整型,是整型里面的最大值<br>转换成二进制0111 1111 1111 1111 1111 1111 1111 1111（前31个1代表数值，最高位（32位）是符号位 0代表正数，1代表负数），hashcode值与其按位与会得到一个正数</li><li>尝试添加元素时发现tab为null，则Node数组尚未初始化，此时执行初始化方法initTable<br>源码<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> sizeCtl<span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lost initialization race; just spin</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSetInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>                    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                    table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>                    sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> tab<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>通过CAS争夺sizeCtl属性控制权，成功将该值设置为-1的线程可执行初始化，其他线程通过Thread.yield()<br>进行等待，直到确认容器初始化完毕，也就是tab数组有了值。初始化完毕时，sizeCtl被设置为下一次扩容的容量阀值，该值为当前容量的0.75（见源码，n为当前容量值。当变量n右移2位，2的-2次方变为0.25n，然后n减去0.25n为0.75n）</li><li>虽然已经初始化了Node数组，但是Key的hash对应的下标位置的节点元素为空，则新建一个Node节点放入该下标位置数组中<br>源码<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">tabAt</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">getObjectAcquire</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i <span class="token operator">&lt;&lt;</span> ASHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> ABASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">boolean</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span>                                     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> c<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">return</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSetObject</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i <span class="token operator">&lt;&lt;</span> ASHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> ABASE<span class="token punctuation">,</span> c<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>tabAt方法通过计算对应下标位置在数组中的偏移量值，即((long)i &lt;&lt; ASHIFT) +<br>ABASE，基础偏移量+元素间隔偏移量。且读取时使用的是getObjectVolatile方法，该方法的读取和对属性使用volatile是一样效果，保证读取到最新值<br>casTabAt方法在下标位置的节点元素为空时，写入采用了compareAndSetObject方法，目的也是为了保证并发安全性。若CAS成功，则元素添加完毕，可以直接退出循环。若失败，则意味着有其他线程已经对相同的下标位置操作成功，此时就要重新循环，确认最新情况，就是步骤4</li><li>对应Node不为空，且其hash标识为特定负数，也就是标识容器正在扩容的负数MOVED，此时需要协助进行容器扩容<br>由于key的hash会经过方法spread处理，因此必然为正数。而负数的hash有三个特殊的含义(源码中有定义，见下)<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MOVED     <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// hash for forwarding nodes</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEBIN   <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// hash for roots of trees</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RESERVED  <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// hash for transient reservations</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li></ol><ul><li>-1: 代表容器正在扩容，且当前节点数据已前移到扩容后的数组中</li><li>-2: 代表当前下标位置上的Node节点采用红黑树结构存储</li><li>-3: 代表该Node节点正在进行函数式运算，值还未最终确定<br>关于扩容和协助扩容，下文会详细记述，这里只需记住协助扩容的触发条件是hash标识为MOVED即可</li></ul><ol start="5"><li>这里是真正开始执行元素添加的操作，分为两步来说<ul><li>节点的hash值不小于0，则遍历链表更新节点或插入新节点。类似HashMap章节所述，判断节点中的key和value是否和要添加的键值对相同，如果不同就添加到链表尾部（尾插法）。重复，则依据方法入参onlyIfAbsent的值判断是否要进行覆盖</li><li>如果是TreeBin类型节点，说明是红黑树，则通过putTreeVal方法往红黑树中插入节点（红黑树会在之后章节具体说明，这里只需要明白是插入树型节点即可）</li></ul></li><li>采用链表存储节点，且链表长度超过阀值8，则将链表转化为红黑树(树化)。见源码注释6，binCount不为0，说明put操作对数据产生影响，在当前链表个数大于等于阈值8时，通过treeifyBin方法转化为红黑树。接着判断oldVal是否不为空，不为空说明是更新操作，不会让元素个数产生变化，则直接返回旧的value</li><li>容器内元素总数+1，并在需要时执行扩容。调用addCount方法尝试更新元素个数baseCount</li></ol><h3 id="扩容和协助扩容操作"><a href="#扩容和协助扩容操作" class="headerlink" title="扩容和协助扩容操作"></a>扩容和协助扩容操作</h3><p>扩容和协助扩容操作其实就在前述注释7这个addCount方法里，但是这个方法看名字其实是对Node数组的元素个数进行更新操作。所以我先把整个addCount方法源码分析一下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> check<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cs<span class="token punctuation">;</span> <span class="token keyword">long</span> b<span class="token punctuation">,</span> s<span class="token punctuation">;</span>    <span class="token comment">//1. 元素个数更新</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cs <span class="token operator">=</span> counterCells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span>        <span class="token operator">!</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSetLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> BASECOUNT<span class="token punctuation">,</span> b <span class="token operator">=</span> baseCount<span class="token punctuation">,</span> s <span class="token operator">=</span> b <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CounterCell</span> c<span class="token punctuation">;</span> <span class="token keyword">long</span> v<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> uncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cs <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> cs<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>            <span class="token punctuation">(</span>c <span class="token operator">=</span> cs<span class="token punctuation">[</span><span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span>            <span class="token operator">!</span><span class="token punctuation">(</span>uncontended <span class="token operator">=</span>              <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSetLong</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> CELLVALUE<span class="token punctuation">,</span> v <span class="token operator">=</span> c<span class="token punctuation">.</span>value<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">fullAddCount</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> uncontended<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//2. 扩容判断，true就开始真正的扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> nt<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> sc<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>               <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2.1 计算盖戳标记值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//2.2 协助扩容</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">>>></span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span>                    sc <span class="token operator">==</span> rs <span class="token operator">+</span> MAX_RESIZERS <span class="token operator">||</span> <span class="token punctuation">(</span>nt <span class="token operator">=</span> nextTable<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span>                    transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSetInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nt<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 2.3 扩容</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSetInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span>                                         <span class="token punctuation">(</span>rs <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>如上源码可知这个addCount方法分为两大部分</p><ol><li>整体更新思路实际上和java8新增的一个统计类完全一致的，即<code>java.util.concurrent.atomic. LongAdder</code>。这个类用于在更高的并发竞争下，降低或维持数字计算的延迟。其性能比传统的AtomicLong更好。介绍一下核心思路</li></ol><ul><li>整个统计的数据结构包含一个基本的长整形变量baseCount和一个统计单元CounterCell构成的数组，数组长度为2的幂，初始长度为2，最大长度超过CPU内核数时停止扩容</li><li>当统计数字需要变化时，优先在baseCount上执行CAS操作。如果成功，意味着更新完成。如果失败，说明此时有多线程竞争，放弃在baseCount上的争夺</li><li>当放弃在baseCount上的争夺时，通过线程上的随机数h在CounterCell数组上找到下标位置，在此位置上的CounterCell内部的整型变量上循环执行CAS更新，直到成功</li><li>如果需要初始化CounterCell数组或者添加元素到具体下标位置，或者扩容，那就只能一个线程进行，该线程需要对cellBusy这个属性进行CAS争夺并成功<br>核心思路就是避免多线程在一个变量上循环CAS直到成功。因为当多线程竞争较为激烈时，大量的线程会在不断的<br>CAS失败中浪费很多CPU时间。通过线程变量的方法，将多线程分散到不同的CounterCell元素中，降低竞争激烈程度和颗粒度，从而提高并发效率。<br>由于统计数据被分散在baseCount和CounterCell数组中，执行总数计算时也需要遍历这里面所有的值相加才能得到最终值。接着就是扩容判断环节</li></ul><ol start="2"><li>扩容依据是sizeCtl，当容器元素总数超过sizeCtl时，执行扩容流程(见源码中while循环判断条件)<br>2.1 对当前数组长度计算盖戳标记值，也就是resizeStamp方法，其具体代码如下<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">numberOfLeadingZeros</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>RESIZE_STAMP_BITS <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div>注释1中说数组长度n是2的幂，<code>Integer.numberOfLeadingZeros(n)</code>获得32位整型数字中，在第一个1之前有多少个0的结果，因此这个值实际上是数字n的一种换算关系<br><code>RESIZE_STAMP_BITS</code>则意味着该结果能够占据的比特位数。由于<code>Integer.numberOfLeadingZeros(n)</code>最大值为27（n的最小值为16），因此<code>RESIZE_STAMP_BITS</code>最小也必须为6。<br>这个方法计算出来的结果，实际上可看成是数组长度的固定换算值。这个值可在扩容过程用于判断是否扩容完毕<br>开始判断是执行扩容还是协助扩容操作。如果sizeCtl当前值为负数，就协助扩容也就是注释2.2；如果为正数，就扩容，也就是注释2.3<br>这里要说明一下sizeCtl</li></ol><ul><li>0: 初始值，意味着此时数组尚未初始化</li><li>-1: 控制值，意味着有线程取得了数组的初始化权利，并且正在执行初始化中</li><li>正数: 要扩容的阀值，一旦元素总数到达该值，则应该进行扩容。除非数组长度到达上限</li><li>非-1的负数: 意味着当前数组正在扩容，该值左边RESIZE_STAMP_BITS个数的比特位用于存储数组长度n的盖戳标记，右边32-RESIZE_STAMP_BITS位用于存储当前参与扩容的线程数<br> 2.2 先看源码中第一个if判断 <code>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</code>意味着数组长度已经发生变化，扩容可能已结束，不需要协助。<code>transferIndex &lt;= 0</code><br>意味着原始数组已无可分配的扩容区域，不需要协助。<br><code>sc == rs + 1 || sc == rs + MAX_RESIZERS</code><br>这个条件永远不会达成，属于bug。具体可看 <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8214427">JDK-8214427: probable bug in logic of ConcurrentHashMap.addCount()</a> (java12版本已修复)<br>如果确认需要协助，就到第二个if。<code>if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1))</code>通过 CAS增加了一个协助线程数量，然后执行transfer迁移方法<br> 2.3 通过CAS对sizeCtl值进行置换。扩容时需要置换的值含义上面也说过（正数），左边是盖戳标记，右边是参与扩容的线程数</li></ul><p>老实说put和扩容以及协助扩容操作代码比较深奥，个人以为面试不会考的这么细致，但是最好记住步骤和这样执行的目的，特别是何时CAS，何时Synchronize以及sizeCtl和计算得出的hash的正负数含义是什么这些</p><h3 id="get操作-1"><a href="#get操作-1" class="headerlink" title="get操作"></a>get操作</h3><p>先看一下get操作源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">,</span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> eh<span class="token punctuation">;</span> <span class="token class-name">K</span> ek<span class="token punctuation">;</span>    <span class="token comment">//1.使用spread方法得到key的hash</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2. 判断数组是否为空，不为空根据hash值确定Node节点位置  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//3. 如果搜索到的Node节点key与传入的key相同且不为null,直接返回节点的value</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//4. 如果eh&lt;0，说明Node节点在红黑树上，直接查询  </span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>val <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">//5. 否则遍历链表，找到对应的值并返回  </span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ol><li>和put操作第一步相同，不再记述</li><li>先判断tab数组是否为空，不为空再用tabAt方法，根据hash值确定Node节点位置</li><li>判断找到的Node节点的hash值是否和key的hash值相同，再判断key相同且不为null，返回该节点的value</li><li>eh小于0，则说明节点在红黑树上，去那边查询(红黑树搜索，添加会另外记述，这里不作更多说明)</li><li>否则遍历链表，找到对应的Node节点的value</li></ol><h1 id="追命三问"><a href="#追命三问" class="headerlink" title="追命三问"></a>追命三问</h1><h2 id="ConcurrentHashMap为啥比Collections-synchronizedMap-读写性能更加好？"><a href="#ConcurrentHashMap为啥比Collections-synchronizedMap-读写性能更加好？" class="headerlink" title="ConcurrentHashMap为啥比Collections.synchronizedMap()读写性能更加好？"></a><code>ConcurrentHashMap</code>为啥比<code>Collections.synchronizedMap()</code>读写性能更加好？</h2><p>网上有人做了测试，发现同样进行put，get操作，<code>ConcurrentHashMap</code>性能都比<code>Collections.synchronizedMap()</code>好，那么为啥呢？</p><ul><li><p>put操作<br><code>Collections.synchronizedMap()</code>的put封装了<code>HashMap</code>的put方法，并加上互斥锁保证安全性。java8之后的<code>ConcurrentHashMap</code>取消了segments分段锁，采用<code>transient volatile Node&lt;K,V&gt;[] table;</code>保存数据。这样对每个Node数组元素加锁，见put操作源码中<code>synchronized(f)</code>,可减少并发冲突概率，提高并发性能。所以<code>ConcurrentHashMap</code>的put并发性更好</p></li><li><p>get操作<br><code>Collections.synchronizedMap()</code>同样封装了HashMap的get方法并加了同步锁。从前述<code>ConcurrentHashMap</code>的get操作源码可知。get操作全程并没有加锁，所以性能上优于<code>Collections.synchronizedMap()</code>的get方法</p></li></ul><p>那么问题来了</p><h2 id="ConcurrentHashMap的get操作为啥不需要加锁？"><a href="#ConcurrentHashMap的get操作为啥不需要加锁？" class="headerlink" title="ConcurrentHashMap的get操作为啥不需要加锁？"></a><code>ConcurrentHashMap</code>的get操作为啥不需要加锁？</h2><p>原因是Node的元素val和指针next是用volatile修饰的，在多线程环境下线程A修改Node结点的val或新增节点时是对线程B可见（见<a href="4266433718.html">volatile</a>章节）</p><p>Node源码中修饰val和next内容如下图红框所示（Node类在<code>ConcurrentHashMap</code>类源码中）</p><p><img src="/img/ConcurrentHashMap/03A3CB77-402C-4536-8886-BFC2E72A2059.png" alt="Node源码中修饰val和next内容"></p><p>另外有人说还和Node数组被修饰为volatile关键字有关，见下图<code>ConcurrentHashMap</code>类源码中，Node数组定义代码</p><p><img src="/img/ConcurrentHashMap/1DFD2EBF-F76F-4901-AC2C-7DECDE4DF463.png" alt="volatile关键字修饰"></p><p>但其实这是错误的说法，volatile的确可以修饰数组，但修饰的是数组地址。</p><p>比如，<code>volatile int myArray[100]</code>是指myArray地址是volatile的而不是数组元素值是volatile</p><p>那么问题又来了</p><h2 id="ConcurrentHashMap中的Node数组被修饰为volatile的目的是啥？"><a href="#ConcurrentHashMap中的Node数组被修饰为volatile的目的是啥？" class="headerlink" title="ConcurrentHashMap中的Node数组被修饰为volatile的目的是啥？"></a>ConcurrentHashMap中的Node数组被修饰为volatile的目的是啥？</h2><p>答案: <strong>为了扩容！！！</strong></p><p>当Node数组扩容时，可以对其他线程具有可见性，所以加了volatile</p><h2 id="三问答案简易版"><a href="#三问答案简易版" class="headerlink" title="三问答案简易版"></a>三问答案简易版</h2><ol><li>java8中的<code>ConcurrentHashMap</code>，它的get操作，全程不需要加锁，这也是比<code>hashtable</code>、用<code>Collections.synchronizedMap()</code>封装的hashmap这些集合类读写性能好的原因之一</li><li>get操作全程不需要加锁是因为Node的成员val和指针next是用volatile修饰的。和用volatile修饰的Node数组没关系</li><li>数组用volatile修饰主要是为了能在数组扩容时,保证可见性</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h2><p>JAVA8之前主要采用锁机制，对某个Segment进行操作时，锁定该Segment，不允许对其进行非查询操作，而JAVA8之后是对每个Node数组中的元素，即Node节点采用CAS无锁算法操作，这种操作在完成前进行判断，如果符合预期结果才给予执行，对并发操作提供了良好的优化</p><h3 id="为啥java8开始放弃Segment？"><a href="#为啥java8开始放弃Segment？" class="headerlink" title="为啥java8开始放弃Segment？"></a>为啥java8开始放弃Segment？</h3><p>根本原因在于java7中的Segment继承ReentrantLock，使用了显示锁，在其实例方法中，每个更新操作内部又使用Unsafe来处理更新。这显然是一种浪费。显示锁、Unsafe这二者都可保证对对象的原子操作。使用一个就行了。但是java8中，Segment还是予以了保留，仅用来处理对象流的读写</p><h2 id="和其它类型的区别"><a href="#和其它类型的区别" class="headerlink" title="和其它类型的区别"></a>和其它类型的区别</h2><p>见表格</p><table><thead><tr><th align="left">类名</th><th align="left">key</th><th align="left">value</th><th align="left">父类</th><th align="left">是否线程安全</th></tr></thead><tbody><tr><td align="left">ConcurrentHashMap</td><td align="left">不允许为null</td><td align="left">不允许为null</td><td align="left">AbstractMap</td><td align="left">安全</td></tr><tr><td align="left">HashMap</td><td align="left">允许为null</td><td align="left">允许为null</td><td align="left">AbstractMap</td><td align="left">不安全</td></tr><tr><td align="left">TreeMap</td><td align="left">不允许为null</td><td align="left">允许为null</td><td align="left">AbstractMap</td><td align="left">不安全</td></tr><tr><td align="left">Hashtable</td><td align="left">不允许为null</td><td align="left">不允许为null</td><td align="left">Dictionary</td><td align="left">安全</td></tr></tbody></table><h3 id="和Hashtable在实现线程安全上的区别"><a href="#和Hashtable在实现线程安全上的区别" class="headerlink" title="和Hashtable在实现线程安全上的区别"></a>和Hashtable在实现线程安全上的区别</h3><ul><li><p>ConcurrentHashMap<br>java8之前，ConcurrentHashMap对整个数组进行了分段(Segment)，每一把锁只锁其中一部分数据，多线程访问不同数据段的数据，不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。）<br>java8之后，放弃了Segment，直接用Node数组+链表+红黑树来实现，使用synchronized和CAS来并发控制操作。所以看起来就像是优化过且线程安全的HashMap（这也是为啥一开始就说它是线程安全版的HashMap），虽然在java8中还有Segment数据结构，但已简化了属性，只是为了兼容旧版本<br>见ConcurrentHashMap中的Segment源码及其注释<br><img src="/img/ConcurrentHashMap/FDC20221-F22C-4BD3-A57D-B9328E9C7291.png" alt="Segment源码及其注释"></p></li><li><p>Hashtable<br>使用synchronized来保证线程安全，效率非常低下。当多个线程访问同步方法时，可能会进入阻塞或轮询状态，若使用put添加元素，另一个线程则不能使用put添加元素，也不能使用get，竞争越激烈效率越低</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8214427">JDK-8214427: probable bug in logic of ConcurrentHashMap.addCount()</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Map</tag>
      
      <tag>ConcurrentHashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/posts/1029785637.html"/>
    <url>/posts/1029785637.html</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>HashMap是采用key-&gt;value形式，key可以为null，但不能重复。value可以重复，也可以为null</p><p>默认容量是16，扩充因子是0.75，也就是说put元素个数超过16* 0.75&#x3D;12后，会自动扩充一倍，容量到32</p><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="java8之前"><a href="#java8之前" class="headerlink" title="java8之前"></a>java8之前</h2><p>数组+链表结构</p><p>把key的hashcode值通过散列函数，获取到hash值，然后通过（n-1）&amp;hash判断当前元素存放位置（n是数组的长度，初始时候是16），如果当前位置已存在元素，就判断已有元素和要存入元素的hash值，key值是否相同，相同就覆盖，不同就放在链表里（也称之为拉链法）</p><p>使用散列函数原因是为了减少hash碰撞，尽量均匀放入数组。否则通过拉链法放入链表，链表可以很长，这样搜索时，本来的时间复杂度O(1)就会退化为O(n)，因为数组元素存放地址是连续的，链表元素是不连续的，因此搜索链表元素只能从第一个元素开始依次一个个查询下去，所以复杂度是O（n）</p><p>简而言之，拉链法就是数组和链表相结合，创建一个链表数组，数组中每个元素就是一个链表，遇到hash碰撞，就将冲突的值放到链表里，如下图</p><p><img src="/img/hashmap/F26FE55F-0B2E-4B2B-A18B-33A5EB7CBD01.png" alt="数组+链表结构"></p><p>但是在多线程并发扩容情况下，HashMap的链表元素会形成循环引用的问题，具体可见<a href="https://coolshell.cn/articles/9606.html">疫苗：Java HashMap的死循环</a></p><p>形成原因归根结底是put元素时，java8之前使用的是头插法</p><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><ul><li><p>概念<br>java8之前，往HashMap里put元素时，新增在链表上的元素位置在链表头部，故名头插法</p></li><li><p>源码实现<br>看一下java7版本中头插法的源码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>   table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>   size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>主要实现方法在这个<code>createEntry(hash, key, value, bucketIndex)</code><br>参数bucketIndex是之前用key的hashcode值做过散列函数得到的下标。key-value这个键值对元素在被put进去时，会放到数组的这个下标位置或者此位置链表中<code>Entry&lt;K,V&gt; e = table[bucketIndex]</code>这一句取到数组这个下标元素，然后作为<code>new Entry&lt;&gt;(hash, key, value, e)</code>的参数e传入Entry构造方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token class-name">K</span> k<span class="token punctuation">,</span> <span class="token class-name">V</span> v<span class="token punctuation">,</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    value <span class="token operator">=</span> v<span class="token punctuation">;</span>    next <span class="token operator">=</span> n<span class="token punctuation">;</span>    key <span class="token operator">=</span> k<span class="token punctuation">;</span>    hash <span class="token operator">=</span> h<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>next属性指向<code>table[bucketIndex]</code>，然后在上一层createEntry方法中又复制给了<code>table[bucketIndex]</code>，实际效果就等同于把该下标的链表整体往后移了一步，再把新构造的entry放在链表头（同时也是数组上该下标的位置）。这就是java7版本hashmap元素在put时，所用的头插法</p></li><li><p>采用原因<br>据说是想到最近插入的元素有极大可能在最近会被用到。所以为了缩短链表查找元素时间，每次都会将新插入的元素放到表头</p></li></ul><h2 id="从java8开始及之后版本"><a href="#从java8开始及之后版本" class="headerlink" title="从java8开始及之后版本"></a>从java8开始及之后版本</h2><p>hash碰撞解决方法有改变，链表长度大于阈值(默认为8)<strong>且数组长度大于64时</strong>，链表转为红黑树，搜索时间复杂度从O(n)变为O(logn)（后文会解释为啥阈值默认值为8以及为啥数组长度大于64才转红黑树）</p><p><img src="/img/hashmap/E4EF5259-2FF8-4D5B-AD71-0C2A780FD0BB.png" alt="转红黑树"></p><p>java8开始解决了多线程并发扩容情况下，链表元素循环引用的问题（不使用头插法，开始使用尾插法，下文源码分析时详细说明），但是并发情况，推荐使用ConcurrentHashMap，因为无论哪个java版本都存在线程不安全情况，下面详细说明put元素时产生的问题</p><h3 id="两个线程执行put元素时，可能导致数据覆盖"><a href="#两个线程执行put元素时，可能导致数据覆盖" class="headerlink" title="两个线程执行put元素时，可能导致数据覆盖"></a>两个线程执行put元素时，可能导致数据覆盖</h3><p>java8开始及之后版本往HashMap里put元素时，如果没有hash碰撞则会直接插入元素（具体代码逻辑见下文put方法源码分析注释2）。假设线程A和线程B同时put，刚好两个value不同的元素的hashcode值一样，通过散列函数得到的下标位置相同，且数组下标位置数据还为null，当线程A通过散列函数得到数组下标位置，但还没往数组下标位置插入元素时就挂起，而线程B正常执行，正常插入元素，然后线程A获取了CPU时间片，此时线程A已获知数组下标位置，它就直接把元素插入数组下标位置。此时问题出现: 线程A把线程B插入的元素key-&gt;value键值对给覆盖掉了，这就发生了线程不安全。</p><p>不光put时候，删除、修改元素时同样会有数据覆盖问题。所以为了线程安全，推荐使用ConcurrentHashMap</p><p>另外Java8开始及之后版本有两点优化</p><ol><li><p>将key的hashcode值变成二进制，右移16位取异或值<br>源码如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>目的是为了减少哈希碰撞概率，即使有两个hashcode值的低16位相同或相似，高16位大相径庭（低位不变高位变），取异或也能让低16位有高16位特征，也能做区分，不会在计算下标位置后进入同一个数组元素位置，从而使用拉链法放入同一链表，引发哈希碰撞</p></li><li><p>hash值对数组长度取模等同于hash值和数组长度－1的取与操作</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">hash<span class="token operator">%</span>n<span class="token operator">=</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>hash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>目的是hash值的高16位都是和0取与，不需做计算，直接得出0，比起取模操作，更减少运算时间，更加高效<br>但是这个公式成立的前提是n也就是<strong>数组长度必须是2的幂</strong>，否则等式不成立的。因此初始化HashMap时，若指定容量初始值不是2的幂，它会用附录中tableSizeFor方法将容量初始值变为2的幂。若没有指定容量初始值，HashMap默认容量是16也是2的幂，所以这也是HashMap的长度不管如何都是2的幂的原因<br>数组长度必须是2的幂的另外一个原因是如果n不是2的幂，比如15，则n-1为14，对应的二进制为1110，取与操作时最后一位都为0，则 0001（同0000取与为0），0011（同0010取与为1），0101（同0100取与为4），1001（同1000取与为8），1011（同1010取与为10），0111（同0110取与为6），1101（同1100取与为12）这几个位置永远都不存放元素（本来应该放在这些位置的元素都放在前述括号里那些位置），空间浪费大，而且数组可用位置比数组长度小了很多，意味着增加了哈希碰撞概率，查询效率降低</p></li></ol><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>主要是put和get方法分析，java11版本</p><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment">// 1. tab为空则创建</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 2. 计算index，并对null做处理    </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>        <span class="token comment">// 3. 节点key存在，直接覆盖value</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment">// 4. 判断是否为红黑树节点    </span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 5. 如果是链表</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//链表长度大于8转换为红黑树进行处理</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// key已存在就覆盖value</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// existing mapping for key</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment">//6. 超过最大容量就扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ol><li>判断键值对数组tab[i]是否为空或为null，否则执行resize()进行扩容(也就说HashMap初始化时，若没指定初始化容量大小，它是在put时候resize指定的)</li><li>根据键值key计算hash值得到插入的数组索引i，如果table[i]&#x3D;&#x3D;null，直接新建节点添加，转向6，如果不为空，转向3</li><li>判断tab[i]的首个元素是否和key一样，如果相等直接覆盖value，否则转向4，这里相等指的是hashCode以及equals都要相等</li><li>判断tab[i]是否为treeNode，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则下一步</li><li>遍历tab[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历中若发现key已存在就覆盖value</li><li>插入成功后，判断实际存在的键值对数量size是否超过了最大容量threshold，如果超过，进行扩容</li></ol><p>有个泳道图可以借鉴一下</p><p><img src="/img/hashmap/22474D7C-4E7E-40AD-8E25-305DD3817B6A.png" alt="put泳道图"></p><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><ul><li>概念<br>java8之后版本，往HashMap里put元素时，数组上还是未转化为红黑树的链表，此时新增在链表上元素的位置在链表尾部，故名尾插法<br>看前述put方法代码，需要注意的是注释2这里<code>tab[i] = newNode(hash, key, value, null);</code>这行使用的newNode方法代码如下<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>新构造的Node节点指向链表查找到的最后一个元素的后继节点。最终的效果就是将新元素追加到链表的尾部。传入的next参数为null，也就是尾插法。这样就避免出现java8之前，那个链表元素循环引用的问题</li></ul><h3 id="转成红黑树的树化阈值TREEIFY-THRESHOLD默认值为啥是8"><a href="#转成红黑树的树化阈值TREEIFY-THRESHOLD默认值为啥是8" class="headerlink" title="转成红黑树的树化阈值TREEIFY_THRESHOLD默认值为啥是8?"></a>转成红黑树的树化阈值<code>TREEIFY_THRESHOLD</code>默认值为啥是8?</h3><p>具体可见HashMap源码注释</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">*</span> <span class="token class-name">Because</span> <span class="token class-name">TreeNodes</span> are about twice the size of regular nodes<span class="token punctuation">,</span> we<span class="token operator">*</span> use them only when bins contain enough nodes <span class="token keyword">to</span> <span class="token namespace">warrant</span> use<span class="token operator">*</span> <span class="token punctuation">(</span>see TREEIFY_THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token class-name">And</span> when they become too small <span class="token punctuation">(</span>due <span class="token keyword">to</span><span class="token operator">*</span> removal or resizing<span class="token punctuation">)</span> they are converted back <span class="token keyword">to</span> <span class="token namespace">plain</span> <span class="token class-name"><span class="token namespace">bins<span class="token punctuation">.</span></span>  In</span><span class="token operator">*</span> usages <span class="token keyword">with</span> <span class="token namespace">well</span><span class="token operator">-</span>distributed user hashCodes<span class="token punctuation">,</span> tree bins are<span class="token operator">*</span> rarely <span class="token class-name"><span class="token namespace">used<span class="token punctuation">.</span></span>  Ideally</span><span class="token punctuation">,</span> under random hashCodes<span class="token punctuation">,</span> the frequency of<span class="token operator">*</span> nodes in bins follows a <span class="token class-name">Poisson</span> distribution<span class="token operator">*</span> <span class="token punctuation">(</span>http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>en<span class="token punctuation">.</span>wikipedia<span class="token punctuation">.</span>org<span class="token operator">/</span>wiki<span class="token operator">/</span><span class="token class-name">Poisson_distribution</span><span class="token punctuation">)</span> <span class="token keyword">with</span> <span class="token namespace">a</span><span class="token operator">*</span> parameter of about <span class="token number">0.5</span> on average <span class="token keyword">for</span> the <span class="token keyword">default</span> resizing<span class="token operator">*</span> threshold of <span class="token number">0.75</span><span class="token punctuation">,</span> although <span class="token keyword">with</span> <span class="token namespace">a</span> large variance because of<span class="token operator">*</span> resizing <span class="token class-name"><span class="token namespace">granularity<span class="token punctuation">.</span></span> Ignoring</span> variance<span class="token punctuation">,</span> the expected<span class="token operator">*</span> occurrences of list size k are <span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token class-name">The</span> first values are<span class="token operator">:</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">0</span><span class="token operator">:</span>    <span class="token number">0.60653066</span><span class="token operator">*</span> <span class="token number">1</span><span class="token operator">:</span>    <span class="token number">0.30326533</span><span class="token operator">*</span> <span class="token number">2</span><span class="token operator">:</span>    <span class="token number">0.07581633</span><span class="token operator">*</span> <span class="token number">3</span><span class="token operator">:</span>    <span class="token number">0.01263606</span><span class="token operator">*</span> <span class="token number">4</span><span class="token operator">:</span>    <span class="token number">0.00157952</span><span class="token operator">*</span> <span class="token number">5</span><span class="token operator">:</span>    <span class="token number">0.00015795</span><span class="token operator">*</span> <span class="token number">6</span><span class="token operator">:</span>    <span class="token number">0.00001316</span><span class="token operator">*</span> <span class="token number">7</span><span class="token operator">:</span>    <span class="token number">0.00000094</span><span class="token operator">*</span> <span class="token number">8</span><span class="token operator">:</span>    <span class="token number">0.00000006</span><span class="token operator">*</span> more<span class="token operator">:</span> less than <span class="token number">1</span> in ten million<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>我粗略翻译一下:</p><p>因为树状节点的大小大约是常规节点的两倍，所以我们在容器中包含足够多的节点时才可使用它们(参见TREEIFY_THRESHOLD)。当它们变得太小(由于去除或调整大小)，它们被转换回普通的链表元素。在用户hashcode分布良好情况下，很少会树化。理想情况下,随机取hashcode、扩充因子默认大小调整为0.75且平均出现频率参数约为0.5的情况下，元素个数出现的频率遵循泊松分布。即使考虑到由于扩容而引发的极大变数，我们还是可以把链表长度假设为k，期望出现频率的计算公式写为</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token function">factorial</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>将k从0到8依次代入公式计算出频率值</p><ul><li>0:    0.60653066</li><li>1:    0.30326533</li><li>2:    0.07581633</li><li>3:    0.01263606</li><li>4:    0.00157952</li><li>5:    0.00015795</li><li>6:    0.00001316</li><li>7:    0.00000094</li><li>8:    0.00000006</li></ul><p>由此答案是:<br><strong>当链表结点个数为8时，出现频率是0.00000006，也就是亿分之6，因此个数小于8的情况下，链表的查询性能和红黑树差不多，而且树化还需时间和空间，所以没有转化成红黑树的必要</strong></p><h3 id="数组长度大于64才树化的原因"><a href="#数组长度大于64才树化的原因" class="headerlink" title="数组长度大于64才树化的原因?"></a>数组长度大于64才树化的原因?</h3><p>见前文put方法代码注释5</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//链表长度大于8转换为红黑树进行处理</span><span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>   <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>查看<code>treeifyBin</code>方法源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>    <span class="token comment">//如果tab的长度小于64，那么即使冲突节点数达到TREEIFY_THRESHOLD，也不会把链表转化成红黑树，而是将tab扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hd <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> tl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                hd <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">;</span>                tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            tl <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hd<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            hd<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>因此在数组长度小于64时，只会扩容。即使数组中有多个元素（每个元素都是一个链表）的长度都超过8，也不会树化成红黑树</p><p>由此答案是:<br><strong>数组长度不大时，可以用扩容的方式使数组元素，即链表的长度变短，提高读写效率，相对于转换为红黑树做法，可保证数据结构更简单</strong></p><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>    <span class="token comment">//1. 得到tab数组的index,查看tab[index]是否有值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//2. 判断tab[index]的首个元素是否和key一样，如果相等直接拿出来值返回，否则下一步</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment">//3. 是否有下一个链表元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//4. 如果是TreeNode,说明采用的是数组+红黑树结构。遍历红黑树，得到节点值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//5. 如果是链表，循环遍历和2一样判断的方法，返回值    </span>            <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ol><li>通过hash &amp; (length-1)得到tab数组的index,查看tab[index]是否有值，如有继续下一步，没有就返回null</li><li>判断tab[index]的首个元素是否和key一样，如果相等直接拿出来值返回，否则下一步，这里相等同样指的是hashCode以及equals都要相等</li><li>是否有下一个链表元素</li><li>如果是TreeNode,说明采用的是数组+红黑树结构。遍历红黑树，得到节点值</li><li>如果是链表，循环遍历和2一样判断方法，返回值（也就是说元素个数没有超过8个，do-while循环最多循环7次）</li></ol><h2 id="红黑树退化成链表"><a href="#红黑树退化成链表" class="headerlink" title="红黑树退化成链表"></a>红黑树退化成链表</h2><p>红黑树中的元素减少到一定数量时，会退化成链表。见源码默认是6</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>而元素减少有两种情况</p><ul><li><p>调用remove方法删除元素<br>HashMap的remove方法中，删除红黑树节点逻辑的removeTreeNode方法中有关解除红黑树结构的分支代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span>   <span class="token punctuation">(</span>rl <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rl<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token function">untreeify</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// too small</span>   <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>从代码可知不是节点数小于<code>UNTREEIFY_THRESHOLD</code>时才退化成链表，而是通过红黑树根节点及其子节点是否为空来判断。而满足该条件的最大红黑树结构如下:<br><img src="/img/hashmap/5870F1CD-5BFA-46E3-90AB-C6293D5AE162.png" alt="最大红黑树结构"><br>节点数为10，大于6，但是根据代码逻辑，是需要退化成链表的</p></li><li><p>resize时对红黑树进行拆分<br>resize时，判断节点类型，如果是链表，则将链表拆分，如果是TreeNode，则执行TreeNode的split方法拆分红黑树，split方法源码如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//根据运算结果将树划分为两棵红黑树，lc表示其中一棵树的节点数</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span>      tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">.</span><span class="token function">untreeify</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>hiHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// (else is already treeified)</span>         loHead<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>这时才用到<code>UNTREEIFY_THRESHOLD</code>判断，当小于等于6时，才调用<code>untreeify</code>方法退化成链表<br>hashMap的红黑树不一定小于6时才退化成链表，而是只有在resize时才根据<code>UNTREEIFY_THRESHOLD</code>进行转换</p></li></ul><h1 id="和常用数据结构的区别"><a href="#和常用数据结构的区别" class="headerlink" title="和常用数据结构的区别"></a>和常用数据结构的区别</h1><h2 id="HashMap和HashTable"><a href="#HashMap和HashTable" class="headerlink" title="HashMap和HashTable"></a>HashMap和HashTable</h2><ul><li>线程安全<br>HashMap非线程安全，HashTable线程安全</li><li>效率<br>因为HashMap非线程安全，所以它的效率比HashTable高</li><li>对key为null和value为null支持<br>HashMap的key可以为null，但不能重复。value可以重复，也可以为null。HashTable不行，key只要有null就会抛NullPointerException异常</li><li>初始容量和扩充容量大小<br>HashTable默认容量是11，每次扩充，容量变为原来的2n+1。HashMap默认容量是16，扩充因子是0.75，也就是说put元素个数超过<code>16*0.75=12</code>后，会自动扩充一倍，容量到32。如果初始化时候指定容量初始值，HashTable会直接使用指定的初始值。而HashMap会扩充为2的幂（见<a href="1029785637.html#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">tableSizeFor</a>方法，代码附在最后）</li><li>数据结构<br>java8开始，HashMap解决hash碰撞时，会将链表长度大于阈值8的转化为红黑树，将搜索时间复杂度从<code>O（N）</code>降为<code>O（logn）</code>。以此减少搜索时间</li></ul><h2 id="HashMap和HashSet"><a href="#HashMap和HashSet" class="headerlink" title="HashMap和HashSet"></a>HashMap和HashSet</h2><p>从HashSet源码可知底层基于HashMap实现</p><ul><li>实现接口<br>HashMap实现了Map接口，HashSet实现了Set接口</li><li>HashMap存储<code>key-&gt;value</code>，HashSet存储对象</li><li>HashMap调用put方法加元素，HashSet调用add方法加元素</li><li>HashMap使用key通过散列函数计算hashcode,HashSet使用成员对象计算hashcode，两个对象hashcode相同，不能保证对象值相等，还要用equals方法判断</li></ul><h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><p>初始化指定容量初始值时，HashMap会扩充为2的幂的方法代码如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">>>></span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">numberOfLeadingZeros</span><span class="token punctuation">(</span>cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numberOfLeadingZeros</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// HD, Count leading 0's</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">32</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> n <span class="token operator">-=</span> <span class="token number">16</span><span class="token punctuation">;</span> i <span class="token operator">>>>=</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span>  <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> n <span class="token operator">-=</span>  <span class="token number">8</span><span class="token punctuation">;</span> i <span class="token operator">>>>=</span>  <span class="token number">8</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span>  <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> n <span class="token operator">-=</span>  <span class="token number">4</span><span class="token punctuation">;</span> i <span class="token operator">>>>=</span>  <span class="token number">4</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span>  <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> n <span class="token operator">-=</span>  <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>>>=</span>  <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>i <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://coolshell.cn/articles/9606.html">疫苗：JAVA HASHMAP的死循环</a></p></li><li><p><a href="http://www.2cto.com/kf/201505/401433.html">Java类集框架之HashMap(JDK1.8)源码剖析</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Map</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql</title>
    <link href="/posts/2501908538.html"/>
    <url>/posts/2501908538.html</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>mysql支持的存储引擎有很多种，主要是innodb、myisam两种</p><ul><li>myisam<br>不支持事务，不支持外键约束，不支持行锁，支持表锁。索引文件和数据文件分开，能在内存里缓存更多的索引，对查询的性能会更好，适用于少量插入，大量查询的场景。执行select count（* ） from table操作时，由于保存了表的行数，因此可以直接读取已经保存的值，不需要进行全表扫描。</li><li>innodb<br>mysql 5.5之后的默认存储引擎。主要特点是支持事务，支持行锁和表锁（默认为行锁），走聚簇索引，强制要求有主键，支持外键约束，可用来做分库分表、读写分离、主备切换。执行select count（* ） from table操作时，需要进行全表扫描</li></ul><blockquote><p>这里能问一道面试题<br>一张表共有10条数据，删除了最后2条，重启数据库后，再插入一条数据，此时自增id是多少？<br>如果表类型是myisam,id是11<br>如果表类型是innodb，id是9<br>原因<br>innodb会把自增id最大值记录在内存中，重启后，内存数据丢失，所以插入时从id&#x3D;8开始自增</p></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>mysql索引是用一个数据结构组织某一列的数据，如果根据那一列的数据进行查询，可以不用全表扫描，根据那个特定的数据结构去找到那一列的值，再找到对应的行物理地址即可</p><p>mysql索引是通过b+树实现，b+树是b树的一个变种，因此先讲一下b树概念</p><p>b树</p><ul><li><p>叶子节点具有相同深度，指针为空</p></li><li><p>所有索引元素不重复</p></li><li><p>节点中的数据索引从左到右递增排列</p><p><img src="/img/mysql/EA189B1339D1EEB67297FB3F7EF65849.jpg" alt="b树"></p></li></ul><p>b+树</p><ul><li><p>非叶子节点不存储data，只存储索引（冗余），可以放更多索引</p></li><li><p>叶子节点包含所有索引字段</p></li><li><p>叶子节点用指针链接，提高区间访问性能</p><p><img src="/img/mysql/6DCCA38F35EC0834658E17595661DFEC.jpg" alt="b+树"></p></li></ul><p>数据查询都是从树的根节点开始二分查找</p><h3 id="myism索引实现"><a href="#myism索引实现" class="headerlink" title="myism索引实现"></a>myism索引实现</h3><p>myism索引最大的特点是数据文件（后缀名MYD）和索引文件（后缀名MYI）是分开的，也就是非聚簇索引。</p><p>数据文件里每行对应一个物理地址，而myism索引里，每个叶子节点的data存放的就是数据行的物理地址。数据查找时，先在索引文件里找到对应的数据行物理地址，然后就可以在数据文件里找到对应的行。</p><p>也就是说数据查找流程是先在索引文件里搜索到行物理地址，然后到数据文件里定位到一条具体的数据行。</p><p><img src="/img/mysql/2DBC314D72B3428D84715FEDA4E5D193.jpg" alt="myism"></p><p>如图根据左下角示例，依次根据箭头显示了整个myism索引的数据查找流程</p><h3 id="innodb索引实现"><a href="#innodb索引实现" class="headerlink" title="innodb索引实现"></a>innodb索引实现</h3><p>和myisam最大的区别在于innodb的数据文件本身就是个B+树结构的索引文件，就是主键key，叶子节点的data就是待查找的那条数据所在行。总结下来两点</p><ul><li>表数据文件本身就是B+树结构的索引文件（后缀名ibd）</li><li>聚簇索引，叶子节点包含了完整的数据记录</li></ul><p>如下图</p><p><img src="/img/mysql/D9517517C6B99EA58E79CBEC53BC5DC5.jpg" alt="innodb"></p><p>这里有几个可以作为面试题的问题</p><ol><li><p>innodb引擎的数据库表为啥要求必须有主键？<br>答案:<br>因为聚簇索引是根据主键来聚合数据，如上图最底部叶子节点绿色的都是主键，下面两行是数据。如果不定义主键，innodb会选择一个唯一的非空索引来替代主键。如果连这样的索引都没有，它会隐式定义一个主键来作为聚簇索引。所以，聚簇索引也被称为主键索引。<br>另外说一句，如上图，聚簇索引的索引号和对应的数据记录是在一起的，这样索引顺序和数据存储的顺序也是一致的。</p></li><li><p>所谓的”回表“是什么？为啥非主键索引结构的叶子节点存储的是主键值？<br>答案:<br>非主键的字段创建索引，叶子节点存储的data值是主键值，因为可以用主键的值到聚簇索引里，根据主键值再次查找到数据，即所谓的回表，例如:</p> <div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from table where name <span class="token operator">=</span> ‘张三’<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>先到name的索引里去找，找到张三对应的叶子节点，叶子节点的data就是那一行的主键，假设是id&#x3D;15，然后再根据id&#x3D;15，到数据文件里的聚簇索引（主键索引）里定位到id&#x3D;15这一行的完整数据</p></li><li><p>为啥主键推荐整型自增字段？用uuid不香么？<br>答案:<br>因为这样可以保持聚簇索引直接加记录就行了，如果用那种不是单调递增的主键值，可能会导致b+树分裂后重新组织，会浪费时间，影响性能（这也是不用uuid做主键的原因之一）。原因之二: 根据前面问题2，可知如果主键都是uuid字符串，那么所有非主键索引叶子节点存储的data都是uuid字符串，会导致索引变得很大，浪费磁盘空间</p></li><li><p>为啥Innodb引擎索引使用B+树而不是B树？<br>答案</p><ul><li>B+树内部非叶子节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树叶子节点由一条指针链连接。当需要进行一次全数据遍历时，B+树只需使用O(logN)时间找到最小的一个节点，然后通过指针链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</li><li>B树适合随机检索，而B+树同时支持随机检索和顺序检索</li><li>B+树空间利用率更高，可减少I&#x2F;O次数，磁盘读写代价更低。一般索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样，索引查找过程中就要产生磁盘I&#x2F;O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引查询效率的最大因素</li><li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路径，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当</li><li>B树在提高了磁盘IO性能的同时并没有解决元素遍历效率低下的问题。B+树的叶子节点使用指针链顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而在数据库中基于范围的查询是非常频繁的，B树不支持这样的操作</li><li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并有序的链表结构存储，这样可很好提高增删效率</li></ul></li></ol><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from table where a<span class="token operator">=</span><span class="token number">1</span> and b<span class="token operator">=</span><span class="token number">2</span> and c<span class="token operator">=</span><span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>针对上述sql怎么建立索引，才可以确保这个sql会使用索引来查询？</p><p>一般我们针对平时要查询的几个字段，会建立一个联合索引，后面写sql都要符合一个最左前缀匹配原则。确保所有sql都可以使用这个联合索引，通过索引来查询</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">create index <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><ol><li><p>全列匹配<br>这个表示如果where条件里就用了这3个字段，那么一定可以用到这个联合索引</p> <div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from table where a<span class="token operator">=</span><span class="token number">1</span> and b<span class="token operator">=</span><span class="token number">2</span> and c<span class="token operator">=</span><span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>最左前缀匹配<br>这个表示如果用到了联合索引最左边的一个或者几个字段，那么也可用上这个索引，在索引里查找时，就用最左边的几个字段就ok了</p> <div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from table where a<span class="token operator">=</span><span class="token number">1</span> and b<span class="token operator">=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>最左前缀匹配了，但是中间某个值没匹配<br>这个表示如果就用了联合索引的第一个字段和第三个字段,那么会按照第一个字段值在索引里找，找完以后对结果集扫描一遍,根据第三个字段来过滤，第三个字段是不走索引搜索的，就会有一个额外的过滤的工作，但是还能用到索引</p> <div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from table where a<span class="token operator">=</span><span class="token number">1</span> and c<span class="token operator">=</span><span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>没有最左前缀匹配<br>这个肯定不会用到索引，千万别犯这个错误</p> <div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from table where b<span class="token operator">=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>前缀匹配<br>这个表示如果不是等值的，比如&#x3D;，&gt;&#x3D;，&lt;&#x3D;的操作，而是like操作，那么必须要是like ‘XX%’这种才能用上索引</p> <div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from table where a<span class="token operator">=</span><span class="token number">1</span> and b<span class="token operator">=</span><span class="token number">2</span> and c like ‘<span class="token number">2018</span><span class="token operator">%</span>’<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>范围列匹配<br>这个表示如果是范围查询，比如&gt;&#x3D;，&lt;&#x3D;，between操作，只有在符合最左前缀的规则下才可以进行范围查询，范围查询后的字段就不用索引了</p> <div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from table where a<span class="token operator">>=</span><span class="token number">1</span> and b<span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>这个sql就只能根据联合索引中的字段a来查询</p></li><li><p>包含函数<br>这个表示如果对某个字段用了函数，比如substring之类的东西，那么那一字段不会用上索引</p> <div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from table where a<span class="token operator">=</span><span class="token number">1</span> and 函数<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>这个sql也只能根据联合索引中的字段a来查询</p></li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>增加磁盘消耗</li><li>占用磁盘文件</li><li>高并发频繁插入和修改索引，会导致性能损耗</li></ul><h3 id="使用时注意事项"><a href="#使用时注意事项" class="headerlink" title="使用时注意事项"></a>使用时注意事项</h3><ol><li><p>高并发场景建议尽量创建少的索引</p></li><li><p>创建索引时，执行下列sql</p> <div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token function">count</span><span class="token punctuation">(</span><span class="token function">discount</span><span class="token punctuation">(</span>col<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>看看选择性，就是这个字段的唯一值在总行数的占比，如果过低，就代表这个字段的值其实都差不多或者类似，那创建索引几乎没什么意义，搜一个值定位到一大坨行，还得重新扫描<br><strong>如果一个字段的值几乎都不太一样，此时用索引的效果才最好</strong></p></li><li><p>某字段是个很长的字符串，如果要建立索引，最好针对这个字符串的前缀来创建前缀索引，比如前10个字符。<br>要用字符串的前多少位来创建前缀索引，取决于不同长度的前缀的选择性，一般前缀长度越长选择性值越高</p></li></ol><h2 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul><li>Atomicity（原子性）<br>事务中所有操作要么全部完成，要么全部不完成，不会在中间某个环节结束。如果事务在执行中发生错误，会回滚（rollback）恢复到事务开始前状态，好像这个事务从来没执行过一样。也就是说，事务不可分隔，简化</li><li>Consistency（一致性）<br>事务开始前，结束后，数据库完整性没有被破坏</li><li>Isolation（隔离性）<br>数据库允许多个并发事务对数据进行crud操作的能力。它可以防止多个事务并发操作时，不会因为参差进行导致数据不一致。隔离级别有下面几个:读未提交（read uncommitted）、读已提交（read committed）、可重复读（repeatable read）以及串行化（serializable）</li><li>Durability(持久性)<br>事务结束后，对数据修改是永久的，即使系统故障，数据也不会丢失，状态也是事务结束后最新的状态</li></ul><h3 id="隔离级别不同引发的脏读、不可重复读、幻读"><a href="#隔离级别不同引发的脏读、不可重复读、幻读" class="headerlink" title="隔离级别不同引发的脏读、不可重复读、幻读"></a>隔离级别不同引发的脏读、不可重复读、幻读</h3><p>首先说明，在mysql里隔离级别是可以设置的，在MYSQL.ini文件里添加下列配置</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">transaction<span class="token operator">-</span>isolation<span class="token operator">=</span>REPEATABLE<span class="token operator">-</span>READ<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>可用配置值有4个，每种级别引发的问题见如下列表</p><table><thead><tr><th align="left">隔离级别配置值</th><th align="left">引发问题</th></tr></thead><tbody><tr><td align="left">READ-UNCOMMITTED</td><td align="left">脏读、不可重复读、幻读</td></tr><tr><td align="left">READ-COMMITTED</td><td align="left">不可重复读、幻读</td></tr><tr><td align="left">REPEATABLE-READ</td><td align="left">幻读（Mysql默认事务隔离级别）</td></tr><tr><td align="left">SERIALIZABLE</td><td align="left">无</td></tr></tbody></table><ul><li>脏读<br>一个事务能读取另外一个事务中还未提交的数据记录，如果这个未提交的事务回滚了，那么能读取未提交数据记录的事务就读到了脏数据</li><li>不可重复读<br>一个事务内，多次读取同一条数据记录，每次读取结果都不同</li><li>幻读<br>同一个事务内多次查询返回的数据记录结果集不同。原因是有另外一个事务新增、修改、删除了这个事务结果集里的数据记录，导致发生同一条数据记录内容被修改了或结果集的数据记录条数变多变少了</li></ul><p>不可重复读针对的是一条数据记录的被修改，幻读针对的是多条数据记录的新增、修改、删除</p><blockquote><p>注: MySQL事务隔离级别是通过锁和MVCC机制实现的。后续章节将对这两个依次说明</p></blockquote><h2 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h2><p>最简单的就是说一下怎么看sql的执行计划</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from table<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><table><thead><tr><th align="left">表字段</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">table</td><td align="left">表名</td></tr><tr><td align="left">type</td><td align="left">类型包括 all（全表扫描）、const（读常量，最多一条记录匹配）、eq_ref（走主键，一般就最多一条记录匹配）、index（扫描全部索引）、range（扫描部分索引）</td></tr><tr><td align="left">possible_keys</td><td align="left">显示可能使用的索引</td></tr><tr><td align="left">key</td><td align="left">实际使用的索引</td></tr><tr><td align="left">key_len</td><td align="left">使用的索引长度</td></tr><tr><td align="left">ref</td><td align="left">联合索引哪一字段</td></tr><tr><td align="left">rows</td><td align="left">一共扫描和返回了多少行</td></tr><tr><td align="left">extra</td><td align="left">using filesort（需要额外进行排序）、using temporary（mysql构建了临时表，比如排序的时候）、using where（就是对索引扫出来的数据再次根据where来过滤出了结果）</td></tr></tbody></table><p>稍微进阶就是使用show processlist查看当前库的所有连接信息，还有开启慢查询日志，查看慢查询sql</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><ul><li>表锁</li><li>行锁</li><li>页锁</li></ul><h2 id="两种引擎锁机制"><a href="#两种引擎锁机制" class="headerlink" title="两种引擎锁机制"></a>两种引擎锁机制</h2><ol><li>myisam会加表锁，读数据时候默认加个表共享锁，写数据时候加个表排他锁</li><li>innodb行锁分为共享锁（S）、排它锁（X）<ul><li>共享锁:多个事务加共享锁读同一行数据，别的事务不能写这行数据</li><li>排它锁:一个事务可以写这行数据，别的事务只能读，不能写<br>innodb行锁通过给索引上的<strong>索引加锁</strong>来实现，因此只有通过索引条件检索数据时候，innodb才用行级锁，否则用表锁</li></ul></li><li>innodb表锁分为意向共享锁（IS）、意向排它锁（IX）<ul><li>意向共享锁，加共享行锁前，必须先加这个共享表锁</li><li>意向排它锁，给行加排它锁前，必须先给表加排它锁，这是innodb自动加的，不需要手工操作<br>insert、update、delete，会自动给行加行排它锁,select什么锁都不加，因为默认隔离级别是可重复读（见前述），多个事务对某行数据随便读，不会冲突</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试时候重点说innodb的锁机制</p><p>针对某行数据，如果有一个事务在修改，它会加排它锁（X），同时获取到了表级的排它锁。<br>另外的事务不能修改，只能等待。但是可以随便读。<br>不同事务如果修改不同的行数据，会拿不同行的行级排它锁，但是大家都拿到了表级排它锁。表级排它锁可以随便拿，不冲突。<br>同一行数据同一时刻只能一个事务写，但可以同时多个事务读</p><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><ul><li>悲观锁: 事务拿数据时，认为会被别的事务修改，所以每次拿数据时候上锁，不让别的事务拿这条数据，直到悲观锁被释放</li><li>乐观锁: 事务拿数据时，认为别的事务不会修改，所以不上锁，但是在提交更新时判断在它拿数据进行crud操作时，是否会有别的事务去操作这条数据</li></ul><p>乐观锁可以手工实现，表里增加一个version字段，每次修改成功值+1，这样每次修改好提交时，看自己这个事务之前查询出来，准备修改的这条数据version字段值和数据库表里这条数据当前version字段值是否一致？不一致就不修改这条数据。</p><p>不推荐使用悲观锁，<code>select ... for update</code>语法会产生死锁问题</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个事务互相持有了一个悲观锁，然后还去请求对方手里持有的悲观锁，这样就死循环了，这就是死锁。</p><p>innodb的事务管理和锁定机制里，有专门检测死锁的机制，在系统产生死锁之后的很短时间内就能检测到死锁的存在。</p><blockquote><p>注意: 当产生死锁的场景中涉及到不止innodb引擎时，innodb是没办法检测到死锁的，这时就只能通过锁定超时限制参数<code>InnoDB_lock_wait_timeout</code>来解决</p></blockquote><p>死锁解决方法</p><ul><li>回滚较小的那个事务</li><li>在REPEATABLE-READ隔离级别下，如果两个线程同时对相同条件过滤的数据用select … for update加悲观锁，在没有符合该条件的数据情况下，两个线程都会加锁成功。系统发现数据还不存在，会试图插入一条新数据，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可避免问题。</li></ul><blockquote><p>判断事务大小: 事务各自插入、更新或者删除的数据量</p></blockquote><h1 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>英语全称为Multi Version Concurrency Control，简称MVCC。一般我们称之为“数据多版本并发控制”</p><p>它是为了解决mysql事务隔离级别中出现的读一致性问题，用来保证同一个事务中前后两次读取数据结果一致(幻读问题)</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在每行数据记录后保存两个隐藏的列，这两个列一个保存了行创建时间(DATATRXID,大小为6个字节,插入为自增id)，一个保存了行过期时间（DATAROLLPTR，回滚指针，大小为7个字节）。但是存储的不是真实时间而是系统版本号（system version number）。每开始一个新事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务版本号，用来和查询到每行记录的版本号进行比较</p><p>看一下crud四种操作时，做了什么</p><ul><li>SELECT<br>InnoDB会根据以下条件检查每行记录<ol><li>只查找版本小于(早于)当前事务版本的数据行，这样可确保事务读取的行要么在开始事务之前就已存在，要么是事务自身插入或者修改过的</li><li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可确保事务读取到的行在事务开始之前未被删除</li></ol></li><li>INSERT<br>为新插入的每一行保存当前系统版本号作为行版本号</li><li>DELETE<br>为删除的每一行保存当前系统版本号作为行删除标识</li><li>UPDATE<br>为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。保存这两版本号，使大多数操作都不用加锁。不足之处在于每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作</li></ul><h2 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h2><p>第1个事务</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">begin<span class="token punctuation">;</span> insert into person <span class="token function">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> insert into person <span class="token function">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> commit<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>假设事务ID从1开始自增，那么此时为</p><table><thead><tr><th align="left">id</th><th align="left">name</th><th align="left">DATATRXID</th><th align="left">DATAROLLPTR</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">A</td><td align="left">1</td><td align="left">null</td></tr><tr><td align="left">2</td><td align="left">B</td><td align="left">1</td><td align="left">null</td></tr></tbody></table><p>创建版本是当前事务ID，删除版本为空</p><p>第2个事务</p><p>执行第1次查询</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">begin<span class="token punctuation">;</span> select <span class="token operator">*</span> from person<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>读取到两条原始数据，是“A”和“B”两个数据，这个时候当前事务ID是2,根据前述select操作只查找版本小于当前事务ID为2的数据行，即创建版本号为1的“A”和“B”</p><p>第3个事务</p><p>插入数据</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">begin<span class="token punctuation">;</span> insert into person <span class="token function">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token char">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> commit<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>多了一条“C”数据，它的创建版本号是当前事务ID为3</p><table><thead><tr><th align="left">id</th><th align="left">name</th><th align="left">DATATRXID</th><th align="left">DATAROLLPTR</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">A</td><td align="left">1</td><td align="left">null</td></tr><tr><td align="left">2</td><td align="left">B</td><td align="left">1</td><td align="left">null</td></tr><tr><td align="left">3</td><td align="left">C</td><td align="left">3</td><td align="left">null</td></tr></tbody></table><p>第2个事务，执行第2次查询</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">begin<span class="token punctuation">;</span> select <span class="token operator">*</span> from person<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>和第1次查询一样。不能查到第3个事务插入的数据“C”，“C”的创建版本号为3大于第2个事务ID即2，所以还是只能查到创建版本号为1的“A”和“B”两条数据</p><p>第4个事务</p><p>删除数据，删除id&#x3D;2的“B”这条记录，</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">begin<span class="token punctuation">;</span>delete from person where id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>commit<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>此时变成如下表格</p><table><thead><tr><th align="left">id</th><th align="left">name</th><th align="left">DATATRXID</th><th align="left">DATAROLLPTR</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">A</td><td align="left">1</td><td align="left">null</td></tr><tr><td align="left">2</td><td align="left">B</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left">3</td><td align="left">C</td><td align="left">3</td><td align="left">null</td></tr></tbody></table><p>根据前述delete操作实现原理，“B”的回滚版本号被记录为当前事务ID即4，其他不变</p><p>第2个事务中，执行第3次查询</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">begin<span class="token punctuation">;</span> select <span class="token operator">*</span> from person<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>前述可知，第2个事务ID为2，那么能查询到创建版本号小于2的数据“A”和删除版本号大于2的数据“B”，也就是说还是“A”和“B”两条数据</p><p>第5个事务，执行更新操作，这个事务ID为5</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">begin<span class="token punctuation">;</span> update person set name<span class="token operator">=</span><span class="token char">'D'</span> where id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>commit<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>第5个事务更新“A”数据，旧数据的回滚版本号被记录为当前事务ID即5(同时写入Undo Log)，产生一条新数据，创建版本号为当前事务ID为5</p><table><thead><tr><th align="left">id</th><th align="left">name</th><th align="left">DATATRXID</th><th align="left">DATAROLLPTR</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">A</td><td align="left">1</td><td align="left">5</td></tr><tr><td align="left">2</td><td align="left">B</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left">3</td><td align="left">C</td><td align="left">3</td><td align="left">null</td></tr><tr><td align="left">1</td><td align="left">D</td><td align="left">5</td><td align="left">null</td></tr></tbody></table><p>第2个事务，执行第4次查询</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">begin<span class="token punctuation">;</span> select <span class="token operator">*</span> from person<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>还是根据前述select操作实现原理</p><p>首先查不到第3个事务插入的数据“C”，这是因为“C”创建版本号为3大于第2个事务ID即2，所以还是只能查到创建版本号为1的两条数据，即“A”和“B”</p><p>其次，第5个事务更新后，数据”D”的创建版本号为5大于2，代表是在第2个事务之后增加的，查不出来，而旧数据“A”的回滚版本号大于2，代表是在第2个事务之后删除的，可查。所以也还是只能查到创建版本号为1的两条数据，即“A”和“B”</p><p>通过以上示例，可知通过创建版本号与回滚版本号的查找规则，无论其他事务是插入、修改还是删除，第2个事务查询到的数据都没有变化，从而说明MVCC解决了幻读问题</p><p>但是如果查询操作在插入、修改、或者删除之后，同时这些操作的事务并没有提交时，按照MVCC机制查询的事务还是不能保证前后两次数据读取的一致性</p><h2 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h2><p>在InnoDB引擎里，MVCC通过前述实现原理和Undo Log来一起实现读的一致性</p><p>它是为了实现事务的原子性而产生的<br>事务开始前，在对数据进行操作之前，先把操作的数据备份到一个日志文件里，以便在事务处理出现异常或者回滚时，MySQL可利用Undo Log中的备份数据恢复到事务执行前的状态，主要是用于回滚操作</p><p>MVCC通过和Undo Log结合一起实现读的一致性的根本原因是Undo Log保存了未提交之前的老版本数据，因此可以将其作为老版本快照便于其它事务来进行并发的读操作</p><p>快照读<br>普通的select查询就是快照读，它由缓存区(Undo buffer)和undo区(Undo Log)两部分组成</p><p>当前读<br>sql读取的是最新版本数据，加锁的数据读取都是当前读</p><h2 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h2><p>它是为了实现恢复操作而产生的，是为了实现事务的持久性<br>Redo Log对事务中操作的任何数据，都把最新的数据备份到一个日志文件里，它不是事务提交后才写入日志文件，而是在事务执行过程中就开始写入Redo Log</p><p>Redo Log实现事务的持久性是指发生故障时，如果有脏页没有写入磁盘，在重启MySQL时，根据Redo Log进行重做，从而把没有写入磁盘的数据进行持久化</p><p>如下图，最新数据备份在redo log，如果发生故障，磁盘中数据不是最新数据，则进行重做把最新数据从redo log持久化到ibd磁盘文件中。undo log存放的是在进行操作之前的老数据，通过快照读方便其它事务并发进行读操作<br><img src="/img/mysql/ADB9FC3A914558F4C747EB1CF8B8C56C.jpg" alt="redo log"></p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>高并发场景下，基本发生读操作的情况远远大于写操作，如果数据库读和写压力都同在一台服务器上，这显然不太合理。于是，把一台数据库主机分为单独的一台写主库（主要负责写操作），而把读的数据库压力分配给多台读的从库，这就是读写分离的典型场景，也就是一写多读</p><p><img src="/img/mysql/3BA48EBC95F22F1FDDD10C843278EBAB.jpg" alt="一写多读"></p><p>如图，多个从库采用异步方式更新主库变化，写操作是在主库上进行，读操作则是在各从库上进行。</p><p>为了进一步降低数据库压力(高并发的瓶颈)，也会在业务层部署分布式缓存集群(redis)，把读压力转移给应用服务器端，其实与数据库主从设计是遵循同一个原则，就是为了降低后端数据库的压力</p><p>问题<br>由于延时（网络传输，操作）而引起的数据库主从数据不一致的问题</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>MySQL之间数据复制的基础是二进制日志文件（binary log）</p><p><img src="/img/mysql/44391195E28E593D4E8D8CB20AF86955.jpg" alt="binary log"></p><p>如图所示3个步骤</p><ol><li>一台MySQL数据库一旦启用二进制日志后，作为主库，它的数据库中所有操作都会以“事件”方式记录在二进制日志中</li><li>其他数据库作为从库通过一个I&#x2F;O线程与主库保持通信，并监控主库的二进制日志文件的变化，如果发现主库二进制日志文件发生变化，则会把变化复制到自己的中继日志（relay log）中</li><li>之后从库的一个sql线程会把相关“事件”执行到自己的数据库中，以此实现从库和主库的一致性，也就实现了主从复制</li></ol><p>实现主从复制需要做的配置</p><ul><li>主库<br>开启二进制日志<br>配置唯一的server-id<br>获得master二进制日志文件名及位置<br>创建一个用于slave和master通信的用户账号</li><li>从库<br>配置唯一的server-id<br>使用master分配的用户账号读取master二进制日志<br>启用slave服务</li></ul><p>上述这个复制过程在mysql里默认是异步的。主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理。所以如果主库挂掉了，此时主库上已提交的事务可能并没有传到从库上。这就产生了主从数据不一致的问题</p><h2 id="主从数据不一致解决方案"><a href="#主从数据不一致解决方案" class="headerlink" title="主从数据不一致解决方案"></a>主从数据不一致解决方案</h2><h3 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h3><p>介于异步和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时也造成了一定程度的延迟，这个延迟最少是一个TCP&#x2F;IP往返的时间。所以，半同步复制最好在低延时的网络中使用</p><p>如图5.6和5.7版本半同步复制流程有略微差异</p><p><img src="/img/mysql/E1135396451570062E17E70C1DA0B5AF.jpg" alt="5.6和5.7版本半同步复制流程差异"></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>事务在主库写完binlog后需要从库返回一个已接受，才返回给客户端</li><li>mysql5.5版本以后，以插件的形式存在，需要单独安装</li><li>确保事务提交后binlog至少传输到一个从库</li><li>不保证从库完成这个事务的binlog</li><li>性能有一定的降低</li><li>网络异常或从库挂机，卡主库，会一直到超时或从库恢复</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>利用数据库原生功能，比较简单</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>主库的写请求时延会增长，吞吐量会降低</p><h3 id="双主模式"><a href="#双主模式" class="headerlink" title="双主模式"></a>双主模式</h3><p>改用双主多从架构，保证高可用</p><p>1.两台mysql主库都可读写，互为主备，默认只用一台（masterA）负责数据写操作，另一台（masterB）备用<br>2.masterA是masterB的主库，masterB又是masterA的主库，它们互为主从<br>3.两台主库之间做高可用,可采用keepalived等方案（使用VIP对外提供服务）<br>4.所有从库与masterB进行主从同步（双主多从）<br>5.建议采用高可用策略时，masterA或masterB均不因挂机恢复后，抢占VIP（非抢占模式）</p><p><img src="/img/mysql/93112A9374398A3B371E434206248652.jpg" alt="双主模式"></p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>一定程度上保证了主库的高可用,在一台主库挂掉后,可在极短的时间内切换到另一台主库上（尽可能减少主库挂机对业务造成的影响），减少了主从同步给主库带来的压力</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>masterB可能会一直处于空闲状态（可用它当从库，负责部分读操作）</li><li>从库要等masterB先同步完了数据，才能去masterB上去同步数据，可能会造成一定程度的同步延时</li></ul><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li><p>分库<br>提升并发量。一个库一般最多支撑到并发 2000，就要扩容了，单库并发量最好保持在每秒1000左右。所以把数据分库到多个库中，访问时，访问一个库就好了</p></li><li><p>分表<br>单表单表数据量太大，会极大影响 sql 执行的性能。所以要把一个表的数据放到多个表中，然后查询时，就查一个表。比如按照用户 id 来分表，将一个用户的数据放在一个表中。操作时，对一个用户就操作那个表就好了。这样可以让每个表数据量在可控的范围内，比如每个表就固定在 200 万以内（mysql单表数据量我觉得最多也就200万左右，超过执行性能就很差）。</p></li></ul><h2 id="为啥要分库分表？"><a href="#为啥要分库分表？" class="headerlink" title="为啥要分库分表？"></a>为啥要分库分表？</h2><p>见下列表格</p><table><thead><tr><th align="left"></th><th align="left"><strong>分库分表前</strong></th><th align="left"><strong>分库分表后</strong></th></tr></thead><tbody><tr><td align="left">并发支撑情况</td><td align="left">单机部署，扛不住高并发</td><td align="left">从单机到多机，能承受的并发增加了多倍</td></tr><tr><td align="left">磁盘使用情况</td><td align="left">单机磁盘容量几乎撑满</td><td align="left">拆分为多个库，数据库服务器磁盘使用率大大降低</td></tr><tr><td align="left">sql执行性能</td><td align="left">单表数据量太大，sql越跑越慢</td><td align="left">单表数据量减少，sql执行效率明显提升</td></tr></tbody></table><h2 id="数据库拆分"><a href="#数据库拆分" class="headerlink" title="数据库拆分"></a>数据库拆分</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>通过某种特定的条件，按照某个维度，将存放在同一个数据库中的数据分散存放到多个数据库上，达到分散单库负载的效果。</p><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><ol><li>优先考虑缓存，降低对数据库的读操作</li><li>再考虑读写分离，降低数据库写操作</li><li>最后开始数据拆分: 首先垂直拆分、再水平拆分</li><li>先考虑按照业务垂直拆分</li><li>再考虑水平拆分：先分库(设置数据路由规则，把数据分配到不同的库中)</li><li>最后再考虑分表，单表拆分到数据200万以内（个人经验单表200万足够了）</li></ol><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><p>把一个有很多字段的表给拆分成多个表，或者是多个库里。每个库表的结构都不一样，每个库表都包含部分字段。一般会将少量访问频率高的字段放到一个表里，然后将大量访问频率低的字段放到另外一个表里。因为数据库是有缓存的，访问频率高的行字段越少，可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多。</p><h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><p>把一个表的数据给弄到多个库的多个表里去，但每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表数据合起来就是全部数据。水平分表意义，是将数据均匀放在更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。总结就是扛高并发，扩容</p><h3 id="两种常用数据路由规则"><a href="#两种常用数据路由规则" class="headerlink" title="两种常用数据路由规则"></a>两种常用数据路由规则</h3><ul><li><p>按照 range 来分<br>就是每个库一段连续的数据放一张表，一般按时间范围来分，但是现在很少用，因为容易产生热点问题，大量的流量都打在最新的数据上，好处是扩容简单</p></li><li><p>按照某个字段 hash 均匀分散<br>这个较常用。可以平均分配每个库的数据量和请求压力;但扩容比较麻烦，要有一个数据迁移的过程，之前的数据要重新计算 hash 值重新分配到不同的库或表</p></li></ul><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="2PC（Two-Phase-Commit）"><a href="#2PC（Two-Phase-Commit）" class="headerlink" title="2PC（Two-Phase Commit）"></a>2PC（Two-Phase Commit）</h2><p>也就是所谓的XA方案</p><p><img src="/img/mysql/3DB22D0D5E44DD2695C0550F9A87393A.jpg" alt="2PC"></p><p>有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问各个数据库准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不ok，那就回滚事务。</p><blockquote><p>事务管理器又被称之为协调者，数据库即资源管理器又被称之为参与者</p></blockquote><p>这种分布式事务方案，比较适合单体应用，跨多个库的分布式事务，而且因为严重依赖于数据库层面来操作事务，效率很低，绝对不合适高并发场景。</p><p>某个系统内部如果出现跨多库的操作，其实是不合规的。现在微服务系统都要求每个服务只能操作自己对应的一个数据库。如果要操作其他服务对应的库，是不允许直连其他服务的库，这违反微服务架构的规范。随便胡乱交叉访问，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>如果给要操作其他服务的库，必须通过调用其他服务的接口来实现，绝不允许交叉访问其他服务的数据库。</p><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><p>阶段1: 准备阶段</p><ol><li>事务管理器向所有数据库发送事务内容，询问是否可以提交事务，并等待所有数据库答复</li><li>各数据库执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）</li><li>如数据库执行成功，给事务管理器反馈YES，即可以提交；如执行失败，给事务管理器反馈NO，即不可提交</li></ol><p>阶段2: 提交阶段</p><p>此阶段分两种情况: 所有数据库均反馈YES、或任何一个数据库反馈NO。<br>所有数据库均反馈YES时，即提交事务。<br>任何一个数据库反馈NO时，即中断事务。</p><p>提交事务: （所有数据库均反馈YES）</p><ol><li>事务管理器向所有数据库发出正式提交事务的请求（即Commit请求）</li><li>数据库执行Commit请求，并释放整个事务期间占用的资源</li><li>各数据库向事务管理器反馈Ack完成的消息</li><li>事务管理器收到所有数据库反馈的Ack消息后，即完成事务提交</li></ol><p>中断事务: （任何一个数据库反馈NO）</p><ol><li>事务管理器向所有数据库发出回滚请求（即Rollback请求）</li><li>数据库使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源</li><li>各数据库向事务管理器反馈Ack完成的消息</li><li>事务管理器收到所有数据库反馈的Ack消息后，即完成事务中断</li></ol><p><img src="/img/mysql/3C707C30CA82FDFDB2BF8983717A27DF.jpg" alt="提交事务和中断事务"></p><p>图上方是提交事务，下方是中断事务流程图</p><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul><li>同步阻塞: 所有参与事务的逻辑均处于阻塞状态</li><li>单点: 事务管理器存在单点问题，如果事务管理器出现故障，数据库将一直处于锁定状态</li><li>脑裂: 在阶段2中，如果只有部分数据库接收并执行了Commit请求，会导致节点数据不一致</li></ul><h2 id="3PC（Three-Phase-Commit）"><a href="#3PC（Three-Phase-Commit）" class="headerlink" title="3PC（Three-Phase Commit）"></a>3PC（Three-Phase Commit）</h2><p>3PC是基于2PC思想演化而来的<br>事务提交过程分为<code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code>三个阶段来进行</p><p><img src="/img/mysql/64EE471DDF22953F1C66E64CBA44AFFF.jpg" alt="3PC"></p><h3 id="具体流程-1"><a href="#具体流程-1" class="headerlink" title="具体流程"></a>具体流程</h3><p>阶段1: CanCommit</p><ol><li>事务管理器向所有数据库发出包含事务内容的CanCommit请求，询问是否可以提交事务，并等待所有参与者答复</li><li>数据库收到CanCommit请求后，如果认为可以执行事务操作，则反馈YES并进入预备状态，否则反馈NO</li></ol><p>阶段2: PreCommit<br>此阶段分两种情况:</p><ol><li>所有数据库均反馈YES，即执行事务预提交</li><li>任何一个数据库反馈NO，或者等待超时后事务管理器还无法收到所有数据库反馈，即中断事务</li></ol><p>事务预提交:（所有数据库均反馈YES时）</p><ol><li>事务管理器向所有数据库发出PreCommit请求，进入准备阶段</li><li>数据库收到PreCommit请求后，执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）</li><li>各数据库向事务管理器反馈Ack响应或No响应，并等待最终指令</li></ol><p>中断事务:（任何一个数据库反馈NO，或者等待超时后事务管理器还无法收到所有数据库反馈时，即中断事务）</p><ol><li>事务管理器向所有数据库发出abort请求</li><li>无论是已收到事务管理器发出的abort请求，或者在等待事务管理器请求过程中出现超时，数据库均会中断事务</li></ol><p>阶段3: do Commit<br>此阶段也存在两种情况:</p><ol><li>所有数据库均反馈Ack响应，即执行真正的事务提交</li><li>任何一个数据库反馈NO，或者等待超时后事务管理器还无法收到所有数据库反馈，即中断事务</li></ol><p>提交事务: （所有数据库均反馈Ack响应时）</p><ol><li>如果事务管理器处于工作状态，则向所有数据库发出do Commit请求</li><li>数据库收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源</li><li>各数据库向事务管理器反馈Ack完成的消息</li><li>事务管理器收到所有数据库反馈的Ack消息后，即完成事务提交</li></ol><p>中断事务: （任何一个数据库反馈NO，或者等待超时后事务管理器还无法收到所有数据库反馈，即中断事务）</p><ol><li>如果事务管理器处于工作状态，向所有数据库发出abort请求</li><li>数据库使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源</li><li>各数据库向事务管理器反馈Ack完成的消息</li><li>事务管理器收到所有数据库反馈的Ack消息后，即完成事务中断</li></ol><blockquote><p>注意:进入阶段3后，无论事务管理器自己出现问题还是事务管理器与数据库网络出现问题，都会导致数据库无法接收到事务管理器发出的do Commit请求或abort请求。此时，数据库都会在等待超时后，继续执行事务提交</p></blockquote><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点: 降低了阻塞范围，在等待超时后事务管理器或数据库会中断事务。避免了事务管理器单点问题，阶段3中事务管理器出现问题时，数据库会继续提交事务</li><li>缺点: 脑裂问题依然存在，即在数据库收到PreCommit请求后等待最终指令，如果此时事务管理器无法与数据库正常通信，会导致数据库继续提交事务，造成数据不一致（前述注意事项）</li></ul><h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><p>TCC 全称: Try、Confirm、Cancel。</p><ul><li>Try 阶段<br>这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留</li><li>Confirm 阶段<br>这个阶段说的是在各个服务中执行实际的操作</li><li>Cancel 阶段<br>如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li></ul><p>涉及支付、交易相关场景，会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，保证资金的正确性，确保资金不会出现问题。但最好各个业务执行的时间都比较短。如图</p><p><img src="/img/mysql/7D632AD7ED5C1489198EB3021FF96D6F.jpg" alt="TCC"></p><p>但是需要程序员自己手写回滚逻辑，或是补偿逻辑，业务代码很难维护</p><h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><p>ebay出品</p><ul><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表</li><li>接着 A 系统将这个消息发送到 MQ 中去；</li><li>B 系统收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作<br>如果收到消息之后。发现这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息</li><li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态</li><li>如果 B 系统处理失败，那就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理</li><li>保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</li></ul><p><img src="/img/mysql/41A8F5EB9D20B3F9B8D64FBBBDFF9D07.jpg" alt="本地消息表"></p><p><strong>严重依赖于数据库的消息表来管理事务</strong>，不适合高并发场景</p><h2 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h2><p>直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务</p><ul><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作。</li><li>如果 prepared 消息发送成功，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务</li><li>mq 会自动定时轮询所有 prepared 消息回调你的接口，询问 prepared 消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？这里可以查下数据库看之前本地事务是否执行了，如果回滚了，那么这里也回滚。这就避免了可能本地事务执行成功，而确认消息却发送失败的情况。</li><li>如果系统 B 的事务失败了，就重试，直到成功。如果实在不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或是发送报警手工进行回滚和补偿。</li><li>举用 RocketMQ 例子，或者自己封装一套类似的逻辑出来</li></ul><p><img src="/img/mysql/A87F476F500B01AD3C2DCC07A723DD7F.jpg" alt="可靠消息最终一致性方案"></p><h2 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h2><ul><li>系统 A 本地事务执行完之后，发送个消息到 MQ</li><li>这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ 然后写入数据库中记录下来，或是放入内存队列，接着调用系统 B 的接口</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃</li></ul><h2 id="阿里SEATA-Saga模式"><a href="#阿里SEATA-Saga模式" class="headerlink" title="阿里SEATA Saga模式"></a>阿里SEATA Saga模式</h2><p>阿里开源的分布式事务解决方案seata中支持3种模式，其中TA和TCC模式可自行参考“参考资料”中提供的链接</p><p>这里重点说一下长事务解决方案Saga模式</p><p><img src="/img/mysql/D20F8CCCCFD5A3E8E4C9545C7B25042E.jpg" alt="SEATA"></p><p>上图是阿里蚂蚁金服提供的Sage模式基本理论，它用一种非常纯朴的方式来处理一致性: 补偿。<br>见图右边部分流程图: 左侧是正常的事务流程，当执行到 T3 时发生错误，则开始执行右边的事务补偿流程，返向执行T3、T2、T1 的补偿服务，其中 C3 是 T3 的补偿服务、C2 是 T2 的补偿服务、C1 是 T1 的补偿服务，将T3、T2、T1 已经修改的数据补偿掉</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>适用于业务流程长且需要保证事务最终一致性的业务系统，它一阶段就会提交本地事务，无锁、长流程情况下可以保证性能</p></li><li><p>事务参与者（资源管理器）可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，可以使用 Saga 模式</p></li></ul><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>一阶段提交本地数据库事务，无锁，高性能</li><li>参与者可采用事务驱动异步执行，高吞吐</li><li>补偿服务即正向服务的“反向”，易于理解，易于实现</li></ul><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul><li>Saga 模式由于一阶段已经提交本地数据库事务，且没有进行“预留”动作，所以不能保证隔离性</li></ul><p>具体实现原理和使用见“参考资料”中提供的链接</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://gitee.com/shishan100/Java-Interview-Advanced">中华石杉–互联网Java进阶面试训练营</a></li><li><a href="https://www.bilibili.com/video/BV1yK4y1t7Vo?from=search&seid=17751926388626439161">2小时学会MySQL索引优化</a></li><li><a href="http://www.bytesoft.org/">关于如何实现一个TCC分布式事务框架的一点思考</a></li><li><a href="https://seata.io/zh-cn/docs/user/saga.html">SEATA Saga 模式</a></li><li><a href="https://seata.io/zh-cn/docs/dev/mode/at-mode.html">SEATA AT模式</a></li><li><a href="https://seata.io/zh-cn/docs/dev/mode/tcc-mode.html">SEATA TCC模式</a></li></ol><h1 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a><a href="/mysql">推荐书单</a></h1>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>数据库</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/posts/2065787451.html"/>
    <url>/posts/2065787451.html</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>树（Tree）是若干个结点组成的有限集合，其中必须有一个结点是根结点</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>树的根结点没有父结点，除根结点之外的所有结点有且只有一个父结点</li><li>树中所有结点可以有零个或多个叶子结点</li></ul><p>见下图</p><p><img src="/img/tree/A19828BF-B383-4985-8E5A-3FA2D7F08B29.png" alt="特点"></p><p>只有a满足前述两个特点，所以是树，其他都不是</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>见代码定义</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinaryTree</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span>  <span class="token comment">//左子树</span>  <span class="token keyword">public</span> <span class="token class-name">BinaryTree</span> left<span class="token punctuation">;</span>  <span class="token comment">//右子树</span>  <span class="token keyword">public</span> <span class="token class-name">BinaryTree</span> right<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">BinaryTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>根据树的特点，一个BinaryTree既可以表示一个节点又可以表示一棵树。但是二叉树面试题解法一般都是递归，而递归又是从整体和局部，问题和子问题为出发点来思考解决问题的。所以，需要思考的是树和左子树、右子树之间的关系</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>将树的所有结点访问且仅访问一次。按照根节点位置的不同主要分为前序遍历、中序遍历、后序遍历</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><ul><li>访问根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ul><p>如图<br><img src="/img/tree/B5DC072A-575F-4501-B37E-C10665A53796.png" alt="前序遍历"></p><p>假设我们构建了一个二叉树类,见下列代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeData</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BinaryTree</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">BinaryTree</span> node0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryTree</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BinaryTree</span> node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryTree</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BinaryTree</span> node2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryTree</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BinaryTree</span> node3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryTree</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BinaryTree</span> node4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryTree</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BinaryTree</span> node5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryTree</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BinaryTree</span> node6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryTree</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BinaryTree</span> node7 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryTree</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    node0<span class="token punctuation">.</span>left <span class="token operator">=</span> node1<span class="token punctuation">;</span>    node0<span class="token punctuation">.</span>right <span class="token operator">=</span> node2<span class="token punctuation">;</span>    node1<span class="token punctuation">.</span>left <span class="token operator">=</span> node3<span class="token punctuation">;</span>    node1<span class="token punctuation">.</span>right <span class="token operator">=</span> node4<span class="token punctuation">;</span>    node2<span class="token punctuation">.</span>right <span class="token operator">=</span> node5<span class="token punctuation">;</span>    node3<span class="token punctuation">.</span>left <span class="token operator">=</span> node6<span class="token punctuation">;</span>    node3<span class="token punctuation">.</span>right <span class="token operator">=</span> node7<span class="token punctuation">;</span>    <span class="token keyword">return</span> node0<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>开始用递归对其进行前序遍历代码如下，main方法是测试方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PreOrderTree</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token class-name">BinaryTree</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 结束条件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 递归主体</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">BinaryTree</span> root <span class="token operator">=</span> <span class="token class-name">TreeData</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul><li>中序遍历左子树</li><li>访问根节点</li><li>中序遍历右子树</li></ul><p>如图<br><img src="/img/tree/032550CA-B85C-4EF8-8EE0-669DD9228A08.png" alt="中序遍历"></p><p>用递归对其进行中序遍历代码如下，main方法是测试方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InOrderTree</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token class-name">BinaryTree</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">BinaryTree</span> root <span class="token operator">=</span> <span class="token class-name">TreeData</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ul><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根节点</li></ul><p>如图</p><p><img src="/img/tree/0FFA886A-ADC0-44EE-BF05-E4399C96A696.png" alt="后序遍历"></p><p>用递归对其进行后序遍历代码如下，main方法是测试方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PostOrderTree</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token class-name">BinaryTree</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">BinaryTree</span> root <span class="token operator">=</span> <span class="token class-name">TreeData</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>二叉搜索树，二叉树的一种。简称BST（Binary Search Tree）</p><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li>左子树上所有节点的值均小于或等于它的根节点的值</li><li>右子树上所有节点的值均大于或等于它的根节点的值</li><li>左、右子树也分别为二叉排序树<br>如图，就是一棵典型的二叉搜索树<br><img src="/img/tree/6754DD1B-C536-4FB0-85A9-5291D786F1F7.png" alt="典型二叉搜索树"></li></ul><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul><li><p>平衡<br>当节点数量固定时，左右子树的高度越接近，说明越平衡（高度越低）。最理想的平衡就是完全二叉树&#x2F;满二叉树，高度最小的二叉树<br>一棵二叉搜索树平均时间复杂度可以认为是树的高度O(height)。如下图<br><img src="/img/tree/7F4DF227-8172-4E45-AB09-65556E59B17A.png" alt="二叉搜索树平均时间复杂度"><br>节点的左右子树高度接近，就属于一棵平衡二叉搜索树，<code>O(height)=O(logn)</code><br>如果如下图，高度达到最大，就已经退化成了链表<br><img src="/img/tree/E26CDCF9-7D7F-4FE3-8129-0E22421BE0DF.png" alt="链表"><br>这个时候O(height)&#x3D;O(n)</p></li><li><p>改进<br>当退化成链表时，性能很低，所以需要在节点的插入、删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度）<br>但如果为了追求最理想的平衡，而增加时间复杂度，这也不是有必要的，因此较合理的方法是: 用尽量少的调整次数达到适度平衡<br>二叉搜索树为了达到上述改进，演化出来3种自平衡二叉树，也就是我们常说的动态平衡二叉树</p></li></ul><h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>AVL树是最早出现的自平衡二叉搜索树之一，名字来自两位发明者的名字: <code>G.M.Adelson-Velsky</code>和<code>E.M.Landis</code>(都是前苏联，也就是现在的俄罗斯人)</p><p>这里有个概念就是平衡因子(<code>Balance Factor</code>): 指的是树中某节点的左右子树的高度差。而且每个叶子节点的平衡因子都定义为0</p><p>举个例子，比如下图</p><p><img src="/img/tree/0694AAF5-6F8B-4D52-AB3A-4884199C5455.png" alt="平衡因子举例"></p><p>8的左子树高度为2，右子树高度为1，因此它的平衡因子为1；5的左子树高度为0，右子树高度为3，因此它的平衡因子为-3；4的左子树高度为2，右子树高度为4，因此它的平衡因子为-2；</p><p>由此看一下AVL树和它每个节点对应的平衡因子</p><p>举例如下图</p><p><img src="/img/tree/39D3ECE9-354D-43EE-BF80-EDEC0EA20423.png" alt="举例"></p><p>根据前述规则可判断图中红色数字是否正确</p><p>从例子中的AVL树和其平衡因子可以得知</p><ul><li>每个节点的平衡因子只可能是-1、0、1（如果绝对值超过1，则认为是失衡）</li><li>每个节点的左右子树高度差不超过1</li><li>搜索、插入、删除的时间复杂度是O(<code>logn</code>)</li></ul><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>B树（<code>Balanced Tree</code>）是一种自平衡的多叉搜索树，多用于文件系统、数据库的实现（就是我们在<code>MySql</code>中常说的B-树，这里经常被人说成B减树，其实只有B树和B+树）</p><p>下图是举例说明的3叉B树</p><p><img src="/img/tree/2F9EE089-090A-4C14-951F-2739A0C24D3D.png" alt="3叉B树"></p><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul><li>每节点可存储超过2个的元素，可拥有超过2个的子节点（元素数量最多是叉数-1，也就是3叉树，每节点最多存储3-1&#x3D;2个元素）</li><li>拥有二叉搜索树的一些性质</li><li>平衡，每节点的所有子树高度相同</li><li>比较矮</li></ul><p>以此类推，假设叉树为m，每个节点存储的元素个数为x，那么能得出推导公式</p><ul><li>根节点: <code>2≤x≤m</code></li><li>非根节点: <code>Math.max(m/2)≤y≤m</code></li></ul><p>比如 m&#x3D;3，子节点个数2≤x≤3，这个B树可以称为（2，3）树、2-3树<br>比如 m&#x3D;4，子节点个数2≤x≤4，这个B树可以称为（2，4）树、2-3-4树<br>比如 m&#x3D;5，子节点个数3≤x≤4，这个B树可以称为（3，5）树、3-4-5树</p><h2 id="对比二叉搜索树"><a href="#对比二叉搜索树" class="headerlink" title="对比二叉搜索树"></a>对比二叉搜索树</h2><p>见图</p><p><img src="/img/tree/CE6689FA-FE51-48E9-A5E7-2C06E3AE135C.png" alt="对比二叉搜索树"></p><p>和上面3叉B树图对比可知</p><ul><li>通过某些父子节点合并，二叉搜索树可变成3叉B树</li><li>B树和二叉搜索树，逻辑上是等价的</li><li>多代节点合并，可获得一个超级节点，n代合并的超级节点，最多拥有2的n次方个子节点（至少是2的n次方叉B树）</li></ul><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是一种含有红黑节点并能自平衡的二叉搜索树</p><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><ul><li>每个节点要么是红色，要么是黑色</li><li>根节点必须是黑色</li><li>叶子节点（外部节点、空节点）是黑色</li><li>红色节点不能连续（也就是，红色节点的孩子和父亲都是黑色）</li><li>对于每个节点，从该节点至nil（树尾端，Java中为null的节点）的任何路径都应包含所相同个数的黑色节点</li></ul><p>如下图这棵红黑树，可对比这些特点是否准确，这里图中没有把nil节点显示出来，所以可能会有人觉得怎么叶子节点是红色的</p><p><img src="/img/tree/BEA3E925-BABD-4FD4-B298-181C6DA6D45E.png" alt="红黑树"></p><h2 id="对比B树"><a href="#对比B树" class="headerlink" title="对比B树"></a>对比B树</h2><p>将上图所有红色节点上升一层与它的父节点放在同一行，就变成一棵4叉B树</p><p><img src="/img/tree/134953A6-E5D1-4094-B1FA-8C3537ED074D.png" alt="4叉B树"></p><p>可得出结论</p><ul><li>红黑树与4叉B树（<code>2-3-4</code>树）具有等价性</li><li>黑色节点与红色子节点合在一起，形成1个B树节点</li><li>红黑树的黑色节点个数与4叉B树的节点总个数相等</li></ul><p>红黑树具体细节见<a href="/posts/3929952611.html">红黑树</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>树</tag>
      
      <tag>红黑树</tag>
      
      <tag>二叉树</tag>
      
      <tag>AVL树</tag>
      
      <tag>B树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>祝贺米兰时隔11年重夺联赛冠军</title>
    <link href="/posts/241530720.html"/>
    <url>/posts/241530720.html</url>
    
    <content type="html"><![CDATA[<p>今天早上我喜欢的球队AC Milan时隔11年重夺联赛冠军，以此为念~</p><p>加油米兰~</p><p><code>Forza Milan</code>~</p><p><img src="/img/milan/WechatIMG1460.jpeg" alt="米兰是冠军~"></p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Milan</tag>
      
      <tag>米兰</tag>
      
      <tag>红黑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/posts/3929952611.html"/>
    <url>/posts/3929952611.html</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>红黑树就是二叉搜索树:<code>Binary Search Tree，BST</code>但是特殊之处在于它是自平衡（动态平衡）的<a href="/posts/2065787451.html#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">二叉搜索树</a>，在进行元素节点插入和删除时，会破坏树的平衡，需要重新自我进行旋转，从而达到平衡</p><blockquote><p>它是由<code>Rudolf Bayer</code>于1972年发明，当时被称为对称二叉B树(<code>symmetric binary B-trees</code>)。<br>后来，在1978年被<code>Leo J. Guibas</code>和<code>Robert Sedgewick</code>改称为如今的红黑树</p></blockquote><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>前述<a href="/posts/2065787451.html">树</a>的篇章也有说到<a href="/posts/2065787451.html#%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>，这里再次展开说明一下，让大家能更加清晰红黑树的概念</p><ol><li>每节点要么是黑色，要么是红色</li><li>根节点是黑色</li><li>每个叶子节点（<code>NIL</code>）是黑色</li><li>每个红色节点的两个子节点和父节点一定都是黑色（从每个叶子节点到根节点的所有路径上不能有两个连续的红色节点）</li><li>任意一节点到每个叶子节点的路径都包含数量相同的黑色节点（有时又被称之为<strong>黑高</strong>）<br>从5又可推理出</li><li>如果一个节点存在黑色子节点，那么该节点肯定有两个子结点</li></ol><p>下图是一颗简单的红黑树。其中<code>Nil</code>为叶子节点，且是黑色的</p><p><img src="/img/blackred/86697534BF749C2B4C174E3E925C4F30.jpg" alt="简单的红黑树"></p><blockquote><p>注意: 在Java中，叶子节点为null</p></blockquote><p>具备这些特点的目的，前述也已说明，是为了对树用尽量少的调整次数达到适度的平衡（自平衡&#x2F;动态平衡）</p><p>这里通常会有一道面试题</p><h2 id="为啥红黑树中，任意节点到其每个叶子节点路径最长长度不会超过最短路径的2倍？"><a href="#为啥红黑树中，任意节点到其每个叶子节点路径最长长度不会超过最短路径的2倍？" class="headerlink" title="为啥红黑树中，任意节点到其每个叶子节点路径最长长度不会超过最短路径的2倍？"></a>为啥红黑树中，任意节点到其每个叶子节点路径最长长度不会超过最短路径的2倍？</h2><p><strong>原因</strong><br>当某条路径最短时，这条路径必然都由黑色节点组成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成（前述特点4限定了不能出现两个连续的红色节点）。而特点5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点，即黑高永远相等。那么在路径最长的情况下，路径上红色节点数&#x3D;黑色节点数。该路径长度为两倍黑色节点数，也就是最短路径长度的2倍</p><p>如图所示</p><p><img src="/img/blackred/68068E262AB1734E22028F52EE3A9D0B.jpg" alt="原因"></p><p>红黑树最早被称为对称二叉B树，从名字中可发现红黑树和B树（这里指的是<code>2-3-4</code>树）有一定的关联。前述<a href="/posts/2065787451.html">树</a>的篇章也有说明和图示，细节这里就不展开说明，有兴趣的可见<a href="https://weread.qq.com/web/bookDetail/7cc32910718ff66b7cc8d9d">《算法》第4版</a>相关章节，已经说的很透彻了</p><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RBTree</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token class-name">T</span> value<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">RBTree</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> parent<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">RBTree</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> left<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">RBTree</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> right<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> isRed<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="平衡操作"><a href="#平衡操作" class="headerlink" title="平衡操作"></a>平衡操作</h1><p>前述<a href="/posts/2065787451.html">树</a>的篇章也有说明，这里再强调一下</p><p>所谓平衡，就是当节点数量固定时，左右子树的高度越接近，说明越平衡（高度越低）</p><p>红黑树达到平衡状态，有2种操作: 旋转和变色</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>旋转又分左旋还是右旋，在记述这两种旋转操作前，先对红黑树节点有个定义，方便后续说明</p><p>如图所示</p><p><img src="/img/blackred/49D3D1C9A5D7B0FF3A2A47ABEB06897B.jpg" alt="节点定义"></p><p>正在遍历的节点叫做当前节点，如图中的D，它的父亲叫做父节点，它的父亲的另外一个子节点叫做兄弟结点，父亲的父亲叫做祖父节点</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>以某个节点作为支点(旋转节点)，其右节点变为旋转节点的父节点，右节点的左节点变为旋转节点的右节点，左节点保持不变</p><p><img src="/img/blackred/548359A0A721BA32911EE8D3148903FA.jpg" alt="左旋"></p><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>以某个节点作为支点(旋转节点)，其左节点变为旋转节点的父节点，左节点的右节点变为旋转节点的左节点，右节点保持不变</p><p><img src="/img/blackred/7FBB39177951D4D95DC12E12C2B6040F.jpg" alt="右旋"></p><h3 id="旋转总结"><a href="#旋转总结" class="headerlink" title="旋转总结"></a>旋转总结</h3><ul><li>旋转操作不会影响旋转节点的父节点，父节点以上的结构还是保持不变</li><li>左旋只影响旋转节点和其右子树的结构，把右子树的节点挪给左子树了</li><li>右旋只影响旋转节点和其左子树的结构，把左子树的节点挪给右子树了</li></ul><p>所以旋转操作是局部的。</p><p>旋转之所以能保持红黑树平衡原因在于<strong>当一边子树的节点少了，那么向另外一边子树“借”一些节点；当一边子树的节点多了，那么向另外一边子树“租”一些节点</strong></p><p>但要保持红黑树的特点，节点不能乱挪，所以还需变色</p><h2 id="变色"><a href="#变色" class="headerlink" title="变色"></a>变色</h2><p>变色指的是节点颜色由红变黑或由黑变红，主要在红黑树插入，删除元素时，为了保证前述几个特点，而进行变色操作，保证可以自平衡（当然也免不了会进行左旋，右旋操作）</p><p>这里不做过多说明，见下文插入、删除元素操作</p><blockquote><p>注意: 文字和图如果还理解不了，这里分享一个链接<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">红黑树动态演示增删查和遍历</a><br>有兴趣的可以打开网页，自行进行元素添加，删除操作看看是否符合前述这些情况中的说明</p></blockquote><h1 id="插入元素操作"><a href="#插入元素操作" class="headerlink" title="插入元素操作"></a>插入元素操作</h1><p>有几种情况</p><ol><li>新节点就是根节点: 直接让新节点变色为黑色(红黑树特点2)</li><li>新节点的父节点为黑色: 新插入的红色节点并没有打破红黑树的特点5限制，黑高不变，所以不需做任何操作</li><li>新节点的父节点和以及父节点的兄弟节点都为红色: 父节点和父节点的兄弟节点变黑，它们的父节点也就是祖父节点变红</li><li>新节点的父结点为红色，父节点的兄弟节点为黑色或没有兄弟节点，且新节点是父节点的右子树，父节点是祖父节点的左子树: 以父节点为旋转节点，左旋。使新节点变为其原来父节点的新父节点，这样就变成马上要说的情况5</li><li>新节点的父结点为红色，父节点的兄弟节点为黑色或没有兄弟节点，且新结点是父节点的左子树，父节点是祖父节点的左子树: 以祖父节点为旋转节点,右旋。使父节点变为其原来父节点（祖父节点）的新父节点，父节点变黑，原祖父节点变红</li><li>新节点的父结点为红色，父节点的兄弟节点为黑色或没有兄弟节点，且新节点是父节点的右子树，父节点是祖父节点的右子树: 以祖父节点为旋转节点,左旋。使父节点变为其原来父节点（祖父节点）的新父节点，父节点变黑，原祖父节点变红</li><li>新节点的父结点为红色，父节点的兄弟节点为黑色或没有兄弟节点，且新结点是父节点的左子树，父节点是祖父节点的右子树: 以父节点为旋转节点，右旋。使新节点变为其原来父节点的新父节点，这样就变成情况6</li></ol><p>图示情况3-7<br>情况3<br>节点D为新节点，节点B为父节点，节点C为父节点的兄弟节点，节点A为祖父节点<br>父节点变黑</p><p><img src="/img/blackred/84E67706B690DE83DA01A5FB19A45A00.jpg" alt="父节点变黑"></p><p>祖父节点变红</p><p><img src="/img/blackred/00855B55D5AAF67ED183D88FA12D34C0.jpg" alt="祖父节点变红"></p><p>父节点的兄弟节点变黑</p><p><img src="/img/blackred/9A06DDC67518FBE2FD889A1D1D79FFC5.jpg" alt="父节点的兄弟节点变黑"></p><p>情况4<br>以父节点为旋转节点，左旋。使新节点变为其原来父节点的新父节点，变成情况5</p><p><img src="/img/blackred/236A6CE2521CD8E482ACFB94583D50A0.jpg" alt="情况4-&gt;情况5"></p><p>情况5<br>以祖父节点为旋转节点,右旋。使父节点变为其原来父节点（祖父节点）的新父节点。节点B变为节点A的父节点</p><p><img src="/img/blackred/C42BE98D84F7C37A162345CB443C2CD0.jpg" alt="右旋"></p><p>父节点变黑，原祖父节点变红</p><p><img src="/img/blackred/56486109BE5799F707F6604128829D53.jpg" alt="父节点变黑，原祖父节点变红"></p><p>情况6<br>节点I为新节点，节点P为父节点，父节点没有兄弟节点，且节点I是节点P的右子树，节点G是祖父节点，父节点P为祖父节点G的右子树<br>以祖父节点G为旋转节点,左旋。使父节点P变为祖父节点G的新父节点。然后节点P变黑，节点G变红</p><p><img src="/img/blackred/83DBC38A785BD2690BF8E904BD7A8044.jpg" alt="左旋"></p><p>情况7<br>节点I为新节点，节点P为父节点，P为红色，父节点没有兄弟节点，且节点I是节点P的左子树，节点G是祖父节点，父节点P为祖父节点G的右子树</p><p><img src="/img/blackred/FD7343523FF88B16BDD3986DD02DA253.jpg" alt="情况7"></p><p>以父节点P为旋转节点，右旋。使节点I变为其原来父节点P的新父节点，节点P变为新节点，这样就变成情况6</p><p><img src="/img/blackred/74AC709E2354120241E5F7E053294E0C.jpg" alt="情况7-&gt;情况6"></p><p>按照情况6进行旋转和变色</p><p><img src="/img/blackred/4DB5518C72F6D2104392B70666C15282.jpg" alt="按照情况6进行旋转和变色"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据新节点的父节点、它的兄弟节点以及祖父节点颜色，组合使用旋转和变色操作来完成插入元素操作。复杂的也就是3-7这5种情况，请细品。</p><p>接下来，我要开始说明删除元素操作了哦，这可是红黑树里最复杂，最难理解的操作。</p><p>坐好了，我要开始发车了~</p><h1 id="删除元素操作"><a href="#删除元素操作" class="headerlink" title="删除元素操作"></a>删除元素操作</h1><p>先不管颜色，不管颜色红黑树就是一个二叉搜索树，我们看看二叉搜索树的删除元素操作场景</p><ol><li>若删除节点无子节点，直接删除</li><li>若删除节点只有一个子节点，用子节点替换删除节点</li><li>若删除节点有两个子节点，用<strong>后继节点，即大于删除节点的最小节点</strong>替换删除节点</li></ol><p>如图3种删除场景转换</p><p><img src="/img/blackred/28411D20580D08B62A87D8369B60007E.jpg" alt="3种删除场景转换"></p><p>看图可知场景2和3可以通过相互转换变为场景1</p><ul><li><p>场景2<br>删除节点用其唯一的子节点替换，子节点替换为删除节点后，可以认为删除的是子节点，若子节点又有两个子节点，那么相当于转换为场景3，一直自顶向下转换，总是能转换为场景1</p></li><li><p>场景3<br>删除节点用后继节点，如果后继节点有右子节点，那么相当于转换为场景2，否则转为场景1</p></li></ul><p>由此可知，删除节点可看作删除替换节点，且替换节点最后总是在叶子节点这里</p><p>接着看红黑树删除元素情况，在这之前定义好节点类型，以便说明</p><p><img src="/img/blackred/A2CA49696972ABAD1B13EB73975923DC.jpg" alt="先定义节点类型"></p><ul><li>R: 替换节点</li><li>P: 替换节点的父节点</li><li>S: 替换节点的兄弟节点</li><li>SL: 兄弟节点的左子节点</li><li>SR: 兄弟节点的右子节点</li><li>灰色: 节点颜色可能是红色，也可能是黑色</li></ul><h2 id="情况1-替换节点为红色"><a href="#情况1-替换节点为红色" class="headerlink" title="情况1: 替换节点为红色"></a>情况1: 替换节点为红色</h2><p>替换节点换到删除节点的位置时，由于替换节点为红色，删除也了不会影响红黑树的平衡（黑高永远不变），只要把替换节点颜色变为删除节点颜色即可重新平衡</p><h2 id="情况2-替换节点为黑色"><a href="#情况2-替换节点为黑色" class="headerlink" title="情况2: 替换节点为黑色"></a>情况2: 替换节点为黑色</h2><p>细分有很多情况</p><h3 id="替换节点为左子树"><a href="#替换节点为左子树" class="headerlink" title="替换节点为左子树"></a>替换节点为左子树</h3><ol><li><p>替换节点的兄弟节点为红色<br><img src="/img/blackred/AF1DD38268E946C74389ECF39F8C1E58.jpg" alt="替换节点的兄弟节点为红色"><br>若兄弟节点为红色，根据红黑树特点4，兄弟节点的父节点和子节点肯定为黑色，将兄弟节点变黑，父节点变红，对父节点进行左旋，得到本节删除情况2.3<br><img src="/img/blackred/F7E711C14DFDD2DA693FAFB7666F712B.jpg" alt="得到删除情况2.3"></p></li><li><p>替换节点的兄弟节点为黑色<br>兄弟节点为黑色，其父节点和子节点的具体颜色无法确定，此时得考虑多种子情况<br>2.1 替换节点的兄弟节点的右子节点为红色，左子节点任意颜色(左+右为黑+红、红+红）<br><img src="/img/blackred/CC009DAFB3209ED657F81540038A4DBE.jpg" alt="2.1"><br>即将删除的左子树的一个黑色节点，显然左子树的黑色节点少1了，然而右子节点又是红色，那么我们直接向右子树“借”个红节点来补充黑节点，并进行旋转处理。<br>将兄弟节点的颜色变为父节点的颜色，将父节点变黑，将兄弟节点的右子节点变黑，对父节点左旋<br>2.2 替换节点的兄弟节点的右子节点为黑色，左子节点为红色(左+右为红+黑）<br>兄弟节点所在的子树有红节点，又可以向兄弟子树“借”个红节点过来，回到本节删除情况2.1<br>将兄弟节点变红，将兄弟节点的左子节点变黑<br><img src="/img/blackred/4BEDB049560867E664B486DE01B7C561.jpg" alt="将兄弟节点变红，将兄弟节点的左子节点变黑"><br>对兄弟节点进行右旋，回到本节删除情况2.1<br><img src="/img/blackred/485AFB69D98E64AED456909B4CC12D6C.jpg" alt="对兄弟节点进行右旋，回到本节删除情况2.1"><br>2.3 替换节点的兄弟节点的子节点都为黑色(左+右为黑+黑）<br>兄弟子树没有红节点可以“借”了，再向父节点“借”！<br>如果父节点为黑色，为了让父节点在所在的子树中保证平衡（替换节点即将删除，少了一个黑色节点，子树也需要少一个）先把兄弟节点变为红色，再让父节点成为新的替换节点，然后重新进行二叉搜索树删除节点的场景处理<br>如果父节点为红色，替换节点的父节点和替换节点的兄弟节点颜色交换；删除节点和替换节点的值交换后，删除替换节点。<br><img src="/img/blackred/17C32BA222F55EF2D346A48A5A072FA6.jpg" alt="删除节点和替换节点的值交换后，删除替换节点"></p></li></ol><h3 id="替换节点是右子树"><a href="#替换节点是右子树" class="headerlink" title="替换节点是右子树"></a>替换节点是右子树</h3><ol><li><p>替换节点的兄弟节点为红色<br>将兄弟节点变黑，将父节点变红<br><img src="/img/blackred/3764B48903BAD3D6731F04A800BCD8E6.jpg" alt="将兄弟节点变黑，将父节点变红"><br>对父节点进行右旋，得到本节删除情况2.3<br><img src="/img/blackred/60EBCB8E42142DB9B256567FAC16D7F6.jpg" alt="对父节点进行右旋，得到本节删除情况2.3"></p></li><li><p>替换节点的兄弟节点为黑色<br>2.1 替换节点的兄弟节点的左子节点为红色，右子节点任意颜色(左+右为红+黑、红+红）<br>将兄弟节点的颜色变为父节点的颜色，将父节点变黑，将兄弟节点的左子节点变黑，对父节点右旋<br><img src="/img/blackred/D2B46F79EB7BB7E51AD9FF56AE0721C7.jpg" alt="将兄弟节点的颜色变为父节点的颜色，将父节点变黑，将兄弟节点的左子节点变黑，对父节点右旋"><br>2.2 替换节点的兄弟节点的左子节点为黑色，右子节点为红色(左+右为黑+红）<br><img src="/img/blackred/E475F3ACEB012C20C51C6C2D2C371C96.jpg" alt="将兄弟节点变红，将兄弟节点的右子节点变黑，对兄弟节点进行左旋，回到本节删除情况2.1"><br>将兄弟节点变红，将兄弟节点的右子节点变黑，对兄弟节点进行左旋，回到本节删除情况2.1<br>2.3 替换节点的兄弟节点的子节点都为黑色(左+右为黑+黑）<br>如果父节点为黑色，将兄弟节点变为红色，再让父节点成为新的替换节点，然后重新进行二叉搜索树删除节点的场景处理<br>如果父节点为红色，替换节点的父节点和替换节点的兄弟节点颜色交换；删除节点和替换节点的值交换后，删除替换节点<br><img src="/img/blackred/34E7A0D6D0EAD75AF44607EBE289FE9E.jpg" alt="替换节点的兄弟节点的子节点都为黑色(左+右为黑+黑）"></p></li></ol><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/img/blackred/3C3976E5C3C70AB378FF6209A1BB1DFA.jpg" alt="删除问题练习"></p><p>该图我要删除黑色节点17怎么玩？</p><p>解题步骤</p><ol><li><p>先不管颜色，按照二叉搜索树删除元素操作场景来看，这是属于场景3，找后续节点，就是比删除节点大的数字里面最小的那个，就是25</p></li><li><p>25替换要删除的17，变成下图<br><img src="/img/blackred/D81CF60CFC9645446E6FF279A8022033.jpg" alt="步骤2"><br>25是要被替换的节点，15是它兄弟节点，16是它兄弟节点的右子节点，且是红色的，25本身是在右子树这里。那么就是替换节点是右子树章节中的删除情况2.2</p></li><li><p>那么将兄弟节点15变红，将兄弟节点15的右子节点16变黑，对兄弟节点15进行左旋，得到下图<br><img src="/img/blackred/1E56A684B0FE535480A92F80963679C1.jpg" alt="步骤3"><br>这里替换节点25已经被删除掉了，其实这张图不对，应该nil节点还是替换节点25，这个时候就变成替换节点是右子树章节中的删除情况2.1</p></li><li><p>将兄弟节点16的颜色变为父节点25的颜色，将父节点25变黑，将兄弟节点16的左子节点15变黑，对父节点25右旋.由于兄弟节点16和父节点25本来就是黑的，我们只要把15变黑，然后25右旋，得到下图<br><img src="/img/blackred/FAC7336EF05402168B8D30FFFA53B7B9.jpg" alt="步骤4"></p></li><li><p>其实这时才应该删除上图虚线框的替换节点25为<code>nil</code>节点，最后总的红黑树图如下<br><img src="/img/blackred/962F24901942F4D797320983B2B6EDBB.jpg" alt="步骤5"></p></li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>删除操作先不管颜色，判断属于二叉搜索树中的哪种删除场景，然后再根据替换节点所处左右子树位置以及兄弟节点、父节点颜色来判断如何删除</p><h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><p>以下分享一下我用java源码实现的红黑树，使用java11编写，加入了大量中文注释，可对照前述章节查看插入，删除元素操作过程</p><p>一共三个类</p><ul><li>RBTreeNode.java 红黑树节点类</li><li>RBTree.java 红黑树类，包括遍历，插入和删除操作</li><li>RBTreeRunner.java 红黑树运行类，执行main方法，打印出红黑树结构</li></ul><p>main方法输出格式如下:</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">d<span class="token operator">(</span>黑<span class="token operator">;</span><span class="token operator">;</span><span class="token operator">)</span>b<span class="token operator">(</span>黑<span class="token operator">;</span>d<span class="token operator">;</span>左<span class="token operator">)</span>g<span class="token operator">(</span>红<span class="token operator">;</span>d<span class="token operator">;</span>右<span class="token operator">)</span>a<span class="token operator">(</span>红<span class="token operator">;</span>b<span class="token operator">;</span>左<span class="token operator">)</span>e<span class="token operator">(</span>黑<span class="token operator">;</span>g<span class="token operator">;</span>左<span class="token operator">)</span>h<span class="token operator">(</span>黑<span class="token operator">;</span>g<span class="token operator">;</span>右<span class="token operator">)</span>f<span class="token operator">(</span>红<span class="token operator">;</span>e<span class="token operator">;</span>右<span class="token operator">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>括号左边表示节点值。括号内用分号间隔表示<strong>颜色;父节点值;位置</strong>，颜色分红黑两种，位置分左右两种</p><p>第一个节点d是根节点，根节点没有父节点，所以括号内只有颜色表示</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>见 <a href="https://gitee.com/darkranger/beating-interviewer/tree/master/src/main/java/com/wujunshen/algorithm/rbtree">红黑树(java11版)</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">红黑树动态演示增删查和遍历</a></li><li><a href="https://mp.weixin.qq.com/s/652xl0kH_po4kSXgFLgn3Q">漫画: 什么是红黑树？</a></li><li><a href="https://mp.weixin.qq.com/s/XEJD5eyfo1Kz3tDZGepBcQ">红黑树在HashMap中的应用</a></li><li><a href="https://mp.weixin.qq.com/s/5e1LdYr9Mdmh85rUyTMdhw">ConcurrentHashMap的红黑树实现分析</a></li><li><a href="https://gitee.com/darkranger/beating-interviewer/tree/master/src/main/java/com/wujunshen/algorithm/rbtree">红黑树(java11版)</a></li></ol><h1 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a><a href="/algorithm">推荐书单</a></h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>树</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/posts/3135569683.html"/>
    <url>/posts/3135569683.html</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><code>redis</code>数据类型</p><ol><li><code>string</code></li><li><code>hash</code></li><li><code>list</code></li><li><code>set</code></li><li><code>sorted set</code></li></ol><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>最简单类型，普通的<code>set</code>和<code>get</code>，做简单的<code>KV</code>缓存。</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">set name wjs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>类似<code>map</code>，可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在<code>redis</code>里，然后每次读写缓存的时候，可以就操作<code>hash</code>里的某个字段。</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">hset person name wjshset person age <span class="token number">20</span>hset person id <span class="token number">1</span>hget person nameperson <span class="token operator">=</span> <span class="token operator">&#123;</span>    <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"wjs"</span><span class="token punctuation">,</span>    <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>    <span class="token string">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token operator">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>有序列表，通过<code>list</code>存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西</p><p>通过<code>lrange</code>命令，读取某个闭区间内的元素，基于<code>list</code>实现分页查询，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token operator">#</span> <span class="token number">0</span>开始位置，<span class="token operator">-</span><span class="token number">1</span>结束位置，结束位置为<span class="token operator">-</span><span class="token number">1</span>时，表示列表的最后一个位置，即查看所有。lrange mylist <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>也可以搞个简单的消息队列，从<code>list</code>头放进去，从<code>list</code>尾巴里出来。</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">lpush mylist <span class="token number">1</span>lpush mylist <span class="token number">2</span>lpush mylist <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token operator">#</span> <span class="token number">1</span>rpop mylist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>无序集合，自动去重</p><p>直接基于<code>set</code>将系统里需要去重的数据扔进去，自动就给去重，如果需要对一些数据进行快速的全局去重，当然可以基于<code>HashSet</code>进行去重，但如果系统部署在多台机器上，得基于<code>redis</code>进行全局的<code>set</code>去重。</p><p>基于<code>set</code>玩交集、并集、差集的操作</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token operator">#</span><span class="token separator comment">-------</span>操作一个set<span class="token separator comment">-------</span><span class="token operator">#</span> 添加元素sadd mySet <span class="token number">1</span><span class="token operator">#</span> 查看全部元素smembers mySet<span class="token operator">#</span> 判断是否包含某个值sismember mySet <span class="token number">3</span><span class="token operator">#</span> 删除某个<span class="token operator">/</span>些元素srem mySet <span class="token number">1</span>srem mySet <span class="token number">2</span> <span class="token number">4</span><span class="token operator">#</span> 查看元素个数scard mySet<span class="token operator">#</span> 随机删除一个元素spop mySet<span class="token operator">#</span><span class="token separator comment">-------</span>操作多个set<span class="token separator comment">-------</span><span class="token operator">#</span> 将一个set的元素移动到另外一个setsmove yourSet mySet <span class="token number">2</span><span class="token operator">#</span> 求两set的交集sinter yourSet mySet<span class="token operator">#</span> 求两set的并集sunion yourSet mySet<span class="token operator">#</span> 求在yourSet中而不在mySet中的元素sdiff yourSet mySet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h2><p>排序<code>set</code>，去重且可以排序，写进去的时候给一个分数，自动根据分数排序。</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">zadd board <span class="token number">85</span> zhangsanzadd board <span class="token number">72</span> lisizadd board <span class="token number">96</span> wangwuzadd board <span class="token number">63</span> zhaoliu<span class="token operator">#</span> 获取排名前三的用户（默认是升序，所以需要 rev 改为降序）zrevrange board <span class="token number">0</span> <span class="token number">3</span><span class="token operator">#</span> 获取某用户的排名zrank board zhaoliu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p><code>redis</code>内部使用文件事件处理器<code>file event handler</code>，它是单线程的，所以<code>redis</code>才叫做单线程的模型。</p><p>采用<code>IO</code>多路复用机制同时监听多个<code>socket</code>，将产生事件的<code>socket</code>压入内存队列中，事件分派器根据<code>socket</code>上的事件类型来选择对应的事件处理器进行处理</p><p><code>file event handler</code>结构:</p><ol><li>多个<code>socket</code></li><li><code>IO</code>多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ol><p>多个<code>socket</code>可能会并发产生不同的操作，每个操作对应不同的文件事件，但是<code>IO</code>多路复用程序会监听多个<code>socket</code>，会将产生事件的<code>socket</code>放入队列中排队，事件分派器每次从队列中取出一个<code>socket</code>，根据<code>socket</code>的事件类型交给相应的事件处理器进行处理。</p><h1 id="客户端与redis交互过程"><a href="#客户端与redis交互过程" class="headerlink" title="客户端与redis交互过程"></a>客户端与redis交互过程</h1><p><img src="/img/redis/5AE201D71C159926092D25629BCA84E0.jpg" alt="客户端与redis交互过程"></p><blockquote><p>前提：通信是通过<code>socket</code>来完成</p></blockquote><ol><li><code>redis</code>服务端进程初始化的时候，会将<code>server socket</code>的<code>AE_READABLE</code>事件与连接应答处理器关联。<br>客户端<code>socket01</code>向<code>redis</code>进程的<code>server socket</code>请求建立连接，此时<code>server socket</code>会产生一个<code>AE_READABLE</code>事件，<code>IO</code>多路复用程序监听到<code>server socket</code>产生的事件后，将该<code>socket</code>压入队列中。文件事件分派器从队列中获取<code>socket</code>，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的<code>socket01</code>，并将该<code>socket01</code>的<code>AE_READABLE</code>事件与命令请求处理器关联。</li><li>客户端发送了一个<code>set key value</code>请求<br><code>redis</code>中的<code>socket01</code>会产生<code>AE_READABLE</code>事件，<code>IO</code>多路复用程序将<code>socket01</code>压入队列，此时事件分派器从队列中获取到<code>socket01</code>产生的<code>AE_READABLE</code>事件，由于前面<code>socket01</code>的<code>AE_READABLE</code>事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取<code>socket01</code>的<code>key value</code>并在自己内存中完成<code>key value</code>的设置。操作完成后，它会将<code>socket01</code>的<code>AE_WRITABLE</code>事件与命令回复处理器关联。</li><li>客户端准备好接收返回结果<br><code>redis</code>中的<code>socket01</code>会产生一个<code>AE_WRITABLE</code>事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对<code>socket01</code>输入本次操作的一个结果，比如<code>ok</code>，之后解除<code>socket01</code>的<code>AE_WRITABLE</code>事件与命令回复处理器的关联。</li></ol><h2 id="redis单线程模型为啥效率这么高？"><a href="#redis单线程模型为啥效率这么高？" class="headerlink" title="redis单线程模型为啥效率这么高？"></a><code>redis</code>单线程模型为啥效率这么高？</h2><ol><li>纯内存操作。</li><li>核心是基于非阻塞的<code>IO</code>多路复用机制。</li><li>C语言实现，一般来说，C语言实现的程序“距离”操作系统更近，执行速度相对会更快。</li><li>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</li></ol><h1 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h1><p>定期删除+惰性删除</p><p>定期删除，指的是<code>redis</code>默认每隔<code>100ms</code>随机抽取一些设置了过期时间的<code>key</code>，检查其是否过期，如果过期就删除。</p><p>问题是定期删除可能会导致很多过期<code>key</code>到了时间并没有被删除掉，所以还要惰性删除。获取<code>key</code>时，如果此时<code>key</code>已经过期，就删除，不会返回任何东西。</p><p>但是还有问题，如果定期删除漏掉了很多过期<code>key</code>，也没及时去查，也没走惰性删除，此时大量过期<code>key</code>堆积在内存里，会导致<code>redis</code>内存块耗尽。如何解决？</p><p>答案是：内存淘汰机制。</p><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p><code>redis</code>内存淘汰机制如下:</p><ul><li><code>noeviction</code>: 当内存不足以容纳新写入数据时，新写入操作会报错</li><li><code>allkeys-lru</code>：当内存不足以容纳新写入数据时，在键空间中，移除<strong>最近最少使用</strong>的<code>key</code>（这个是最常用的）</li><li><code>allkeys-random</code>：当内存不足以容纳新写入数据时，在键空间中，<strong>随机移除</strong>某个<code>key</code></li><li><code>volatile-lru</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除<strong>最近最少使用</strong>的<code>key</code></li><li><code>volatile-random</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，<strong>随机移除</strong>某个<code>key</code></li><li><code>volatile-ttl</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有<strong>更早过期时间的<code>key</code>优先移除</strong></li></ul><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>两种方式</p><ul><li><code>RDB</code><br>对<code>redis</code>中的数据执行周期性的持久化</li><li><code>AOF</code><br>对每条写入命令作为日志，以<code>append-only</code>的模式写入一个日志文件中，在<code>redis</code>重启的时候，可以通过回放<code>AOF</code>日志中的写入指令来重新构建整个数据集</li></ul><p>使用<code>mac</code>电脑的同学都知道mac用来做硬盘数据备份的”时间机器“<code>app</code>，<code>rdb</code>就好比我们经常用云空间或移动硬盘开启时间机器<code>app</code>进行硬盘数据定期备份。而<code>aof</code>就好比我们执行每个操作时候同步进行的备份操作。当然<code>mac</code>电脑并没有提供类似<code>aof</code>这样的备份机制。</p><p>如果<code>redis</code>挂了，服务器上的内存和磁盘上的数据都丢了，可从云服务上拷贝之前的数据，放到指定目录，然后重新启动<code>redis</code>，<code>redis</code>就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。</p><p>如果同时使用<code>RDB</code>和<code>AOF</code>两种持久化机制，那么在<code>redis</code>重启的时候，会使用<code>AOF</code>来重新构建数据，因为<code>AOF</code>中的数据更加完整。</p><h2 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a><code>RDB</code>优缺点</h2><p><code>RDB</code>会生成多个数据文件，每个数据文件都代表了某一个时刻<code>redis</code>数据，这种多个数据文件的方式，非常适合做冷备，可将这种完整的数据文件发送到一些远程的安全存储上去，以预定好的备份策略来定期备份<code>redis</code>数据。</p><p><code>RDB</code>对<code>redis</code>对外提供的读写服务，影响非常小，可以让<code>redis</code><strong>保持高性能</strong>，因为<code>redis</code>主进程只需要<code>fork</code>一个子进程，让子进程执行磁盘<code>IO</code>操作来进行<code>RDB</code>持久化即可。</p><p>相对于<code>AOF</code>持久化机制来说，直接基于<code>RDB</code>数据文件来重启和恢复<code>redis</code>进程，更加快速。</p><p>如果想要尽可能少的丢数据，那么<code>RDB</code>没有<code>AOF</code>好。<code>RDB</code>数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦<code>redis</code>进程挂机，那么最近5分钟的数据会丢失。</p><p><code>RDB</code>每次在<code>fork</code>子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</p><h2 id="AOF优缺点"><a href="#AOF优缺点" class="headerlink" title="AOF优缺点"></a><code>AOF</code>优缺点</h2><p><code>AOF</code>会每隔1秒，通过一个后台线程执行一次<code>fsync</code>操作，最多丢失1秒钟的数据。</p><p><code>AOF</code>日志文件以<code>append-only</code>模式写入，没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</p><p><code>AOF</code>日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在<code>rewrite log</code>的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的<code>merge</code>后的日志文件<code>ready</code>的时候，再交换新老日志文件即可。</p><p><code>AOF</code>日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做<strong>灾难性的误删除的紧急恢复</strong>。比如不小心用<code>flushall</code>命令清空了所有数据，只要这个时候后台<code>rewrite</code>还没有发生，那么就可以立即拷贝<code>AOF</code>文件，将最后一条<code>flushall</code>命令删了，然后再将该<code>AOF</code>文件放回去，就可通过恢复机制，自动恢复所有数据。</p><p>对于同一份数据来说，<code>AOF</code>日志文件通常比<code>RDB</code>数据快照文件更大。</p><p><code>AOF</code>开启后，支持的写<code>QPS</code>会比<code>RDB</code>支持的写<code>QPS</code>低，因为<code>AOF</code>一般会配置成每秒<code>fsync</code>一次日志文件，当然，每秒一次<code>fsync</code>，性能也还是很高的。（如果实时写入，那么<code>QPS</code>会大降，<code>redis</code>性能会大大降低）</p><p>类似<code>AOF</code>这种较为复杂的基于命令日志<code>/merge/</code>回放的方式，比基于<code>RDB</code>每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有<code>bug</code>。不过<code>AOF</code>为了避免rewrite过程导致的<code>bug</code>，每次<code>rewrite</code>并不是基于旧的指令日志进行<code>merge</code>的，而是<strong>基于当时内存中的数据进行指令的重新构建</strong>，这样健壮性会好一点。</p><h2 id="该选哪种来持久化？"><a href="#该选哪种来持久化？" class="headerlink" title="该选哪种来持久化？"></a>该选哪种来持久化？</h2><ol><li>不要仅仅使用<code>RDB</code>，因为这样会导致你丢失很多数据</li><li>也不要仅仅使用<code>AOF</code>，因为这样有两个问题<ul><li>通过<code>AOF</code>做冷备，没有<code>RDB</code>做冷备来的恢复速度更快</li><li><code>RDB</code>每次简单粗暴生成数据快照，更加健壮，可避免<code>AOF</code>这种复杂的备份和恢复机制的<code>bug</code></li></ul></li><li><code>redis</code>支持同时开启开启两种持久化方式，可综合使用<code>AOF</code>和<code>RDB</code>，用<code>AOF</code>来保证数据不丢失，作为数据恢复的第一选择; 用<code>RDB</code>来做不同程度的冷备，在<code>AOF</code>文件都丢失或损坏不可用的时候，还可使用<code>RDB</code>来进行快速的数据恢复。</li></ol><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>主从(<code>master-slave</code>)架构</p><p>一主多从，主负责写，并且将数据复制到其它的<code>slave</code>节点，从节点负责读。所有的读请求全部走从节点。这样可以轻松实现水平扩容，支撑<strong>读高并发</strong></p><p><img src="/img/redis/551823AEC2EF71D93A52C09647CA57BB.jpg" alt="master-slave架构"></p><h2 id="redis-replication"><a href="#redis-replication" class="headerlink" title="redis replication"></a><code>redis replication</code></h2><ul><li>采用异步方式复制数据到<code>slave</code>节点，从<code>redis2.8</code>开始，<code>slave</code>会周期性地确认自己每次复制的数据量</li><li>一个<code>master</code>可配置多个<code>slave</code></li><li><code>slave</code>也可连接其他的<code>slave</code></li><li><code>slave</code>复制时，不会<code>block master</code>的正常工作</li><li><code>slave</code>在做复制时，也不会<code>block</code>对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，此时就会暂停对外服务了</li><li><code>slave</code>主要用来进行横向扩容，读写分离，扩容<code>slave</code>提高读的吞吐量</li></ul><p>采用主从架构，必须开启<code>master</code>持久化。因为如果关掉<code>master</code>持久化，在<code>master</code>挂机重启时，数据是空的，然后可能一经过复制，<code>slave</code>的数据也丢了。</p><p>另外，需要对<code>master</code>做各种备份方案。万一本地所有文件丢失，从备份中挑选一份<code>rdb</code>去恢复<code>master</code>，这样才能确保启动时有数据，即使采用了高可用机制，<code>slave</code>可以自动接管<code>master</code>，也可能还没检测到<code>master failure</code>，<code>master</code>就自动重启了，还是可能导致所有的<code>slave</code>数据被清空。</p><h2 id="主从复制核心原理"><a href="#主从复制核心原理" class="headerlink" title="主从复制核心原理"></a>主从复制核心原理</h2><p>启动一个<code>slave</code>时，它会发送一个<code>PSYNC</code>命令给<code>master</code>。</p><p>如果这是<code>slave</code>第一次连接到<code>master</code>，就会触发一次<code>full</code> <code>resynchronization</code>（全量复制）。<br>此时<code>master</code>会启动一个后台线程，开始生成一份<code>RDB</code>快照文件，同时还会将从客户端<code>client</code>新收到的所有写命令缓存在内存中。<br><code>RDB</code>文件生成完毕后，<code>master</code>会将这个<code>RDB</code>发送给<code>slave</code>，<code>slave</code>会先写入本地磁盘，然后再从本地磁盘加载到内存中，<br>接着<code>master</code>会将内存中缓存的写命令发送到<code>slave</code>，<code>slave</code>也会同步这些数据。<br><code>slave</code>如果跟<code>master</code>有网络故障，断开连接，会自动重连，连接之后<code>master</code>仅会复制给<code>slave</code>部分缺少的数据</p><p><img src="/img/redis/E3C461B9F65E1C64C14B7784108F55D3.jpg" alt="主从复制核心原理"></p><p>几个小问题需要厘清</p><h3 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h3><p>从<code>redis2.8</code>开始，就支持主从复制的断点续传，如果主从复制过程中，网络断了，可以接着上次复制的地方，继续复制。</p><p><code>master</code>会在内存中维护一个<code>backlog</code>，<code>master</code>和<code>slave</code>都会保存一个<code>replica offset</code>还有一个<code>master run id</code>，<code>offset</code>就是保存在<code>backlog</code>中的。如果<code>master</code>和<code>slave</code>网络断了，<code>slave</code>会让<code>master</code>从上次<code>replica offset</code>开始继续复制，如果没有找到对应的<code>offset</code>，那么就会执行一次全量复制</p><blockquote><p>如果根据<code>host+ip</code>定位<code>master</code>是不靠谱的，如果<code>master</code>重启或数据出现了变化，<code>slave</code>应该根据不同的<code>run id</code>区分</p></blockquote><h3 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h3><p><code>master</code>在内存中直接创建<code>RDB</code>，然后发送给<code>slave</code>，不会在自己本地落盘。只需要在配置文件中开启</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">repl<span class="token operator">-</span>diskless<span class="token operator">-</span>sync yes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h3 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期<code>key</code>处理</h3><p><code>slave</code>不会过期<code>key</code>，只会等待<code>master</code>过期<code>key</code>。如果<code>master</code>过期了一个<code>key</code>，或通过<code>LRU</code>淘汰了一个<code>key</code>，那么会模拟一条<code>del</code>命令发送给<code>slave</code></p><h2 id="主从复制完整流程"><a href="#主从复制完整流程" class="headerlink" title="主从复制完整流程"></a>主从复制完整流程</h2><p><img src="/img/redis/E4236BBC31F337EED9790BB06F7E1FC3.jpg" alt="主从复制完整流程"></p><p><code>slave</code>启动时，会在自己本地保存<code>master</code>的信息，包括<code>master</code>的<code>host</code>和<code>ip</code>，但是复制流程没开始。</p><p><code>slave</code>内部有个定时任务，每秒检查是否有新的<code>master</code>要连接和复制，如果发现，就跟<code>master</code>建立<code>socket</code>网络连接。然后<code>slave</code>发送<code>ping</code>命令给<code>master</code>。如果<code>master</code>设置了<code>requirepass</code>，那么<code>slave</code>必须发送<code>masterauth</code>的口令过去进行认证。<code>master</code>第一次执行全量复制，将所有数据发给<code>slave</code>。而在后续，<code>master</code>持续将写命令，异步复制给<code>slave</code></p><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><ul><li><p><code>master</code>执行<code>bgsave</code> ，在本地生成一份<code>rdb</code>快照文件。</p></li><li><p><code>master</code>将<code>rdb</code>快照文件发送给<code>slave</code>，如果<code>rdb</code>复制时间超过60秒（<code>repl-timeout</code>），那么<code>slave</code>就会认为复制失败，可以适当调大这个参数</p></li><li><p><code>master</code>在生成<code>rdb</code>时，会将所有新的写命令缓存在内存中，在<code>slave</code>保存了<code>rdb</code>之后，再将新的写命令复制给<code>slave</code></p></li><li><p>如果在复制期间，内存缓冲区持续消耗超过64MB，或者一次性超过256MB，那么停止复制，复制失败<br><code>client-output-buffer-limit slave 256MB 64MB 60</code></p></li><li><p><code>slave</code>接收到<code>rdb</code>之后，清空自己的旧数据，然后重新加载<code>rdb</code>到自己的内存中，同时基于旧的数据版本对外提供服务</p></li><li><p>如果<code>slave</code>开启了<code>AOF</code>，那么会立即执行<code>BGREWRITEAOF</code>，重写<code>AOF</code></p></li></ul><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><ul><li>全量复制过程中，如果网络断了，那么<code>slave</code>重新连接<code>master</code>时，会触发增量复制。</li><li><code>master</code>直接从自己的<code>backlog</code>中获取部分丢失的数据，发送给<code>slave</code>，默认<code>backlog</code>就是1MB</li><li><code>master</code>根据<code>slave</code>发送的<code>psync</code>中的<code>offset</code>来从<code>backlog</code>中获取数据</li></ul><h3 id="心跳（heartbeat）"><a href="#心跳（heartbeat）" class="headerlink" title="心跳（heartbeat）"></a>心跳（<code>heartbeat</code>）</h3><ul><li>主从节点互相发送<code>heartbeat</code>信息</li><li><code>master</code>默认每隔10秒发送一次<code>heartbeat</code>，<code>slave</code>每隔1秒发送一个<code>heartbeat</code></li></ul><h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p><code>master</code>每次接收到写命令之后，先在内部写入数据，然后异步发送给<code>slave</code></p><h1 id="如何实现Redis高可用？"><a href="#如何实现Redis高可用？" class="headerlink" title="如何实现Redis高可用？"></a>如何实现<code>Redis</code>高可用？</h1><p><code>redis</code>的高可用架构，叫做<code>failover</code>故障转移，也可叫做主备切换</p><p><code>master</code>在故障时，自动检测，并将某个<code>slave</code>自动切换为<code>master</code>的过程，就叫做主备切换</p><p><code>redis3.x</code>版本开始引入自身的<code>cluster</code>集群机制，已经不需要使用哨兵模式来实现自身的高可用</p><p><code>redis cluster</code>，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。<code>redis cluster</code>支撑N个<code>redis</code>的<code>master</code>，每个<code>master</code>都可以挂载多个<code>slave</code>。整个<code>redis</code>就可横向扩容。如果要支撑更大数据量的缓存，那就横向扩容更多的<code>master</code>节点，每个<code>master</code>就能存放更多的数据。</p><h2 id="redis-cluster介绍"><a href="#redis-cluster介绍" class="headerlink" title="redis cluster介绍"></a><code>redis cluster</code>介绍</h2><ul><li>自动将数据进行分片，每个<code>master</code>上放一部分数据</li><li>提供内置的高可用支持，部分<code>master</code>不可用时，还是可以继续工作的</li></ul><p>在<code>redis cluster</code>架构下，每个<code>redis</code>要开放两个端口，比如一个是<code>6379</code>，另外一个就是加1w的端口号，比如<code>16379</code>。（其实都可以自行在配置文件中指定不同的端口号，只要端口号没被系统占用就行）</p><p><code>16379</code>端口号是用来进行节点间通信的，也就是<code>cluster bus</code>，<code>cluster bus</code>通信是用来进行故障检测、配置更新、故障转移授权。它使用了另外一种二进制的协议，<code>gossip</code>协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><h3 id="内部通信机制"><a href="#内部通信机制" class="headerlink" title="内部通信机制"></a>内部通信机制</h3><p>集群元数据的维护有两种方式：集中式、<code>Gossip</code>协议。</p><p><code>redis cluster</code>节点间采用<code>gossip</code>协议进行通信</p><blockquote><p><code>gossip</code>协议:<br>所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p></blockquote><p><img src="/img/redis/6FDCB17AF939679EF409B494C4073847.jpg" alt="gossip协议"></p><p><code>gossip</code>优点</p><p>元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力</p><p><code>gossip</code>缺点</p><p>元数据的更新有延时，可能导致集群中的一些操作会有一些滞后</p><p>每个节点都有一个专门用于节点间通信的端口，比如之前说的<code>6379</code>，那么用于节点间通信的就是<code>16379</code>端口。每个节点每隔一段时间都会往另外几个节点发送<code>ping</code>消息，同时其它几个节点接收到<code>ping</code>之后返回<code>pong</code></p><p>交换的信息包括故障信息，节点的增加和删除，<code>hash slot</code>信息等等。</p><p><code>gossip</code>协议包含多种消息，诸如<code>ping</code>,<code>pong</code>,<code>meet</code>,<code>fail</code>等等。</p><ul><li><code>meet</code>: 某个节点发送<code>meet</code>给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信</li><li>内部发送了一个<code>gossip meet</code>消息给新加入的节点，通知那个节点去加入我们的集群</li><li><code>ping</code>: 每个节点都会频繁给其它节点发送<code>ping</code>，其中包含自己的状态还有自己维护的集群元数据，互相通过<code>ping</code>交换元数据</li><li><code>pong</code>: 返回<code>ping</code>和<code>meet</code>，包含自己的状态和其它信息，也用于信息广播和更新</li><li><code>fail</code>: 某个节点判断另一个节点<code>fail</code>之后，就发送<code>fail</code>给其它节点，通知其它节点说，某个节点宕机了</li></ul><h3 id="hash-slot算法"><a href="#hash-slot算法" class="headerlink" title="hash slot算法"></a><code>hash slot</code>算法</h3><p><code>redis cluster</code>有固定的<code>16384</code>（2的14次方）个<code>hash slot</code>，对每个<code>key</code>计算<code>CRC16</code>值，然后对<code>16384</code>取模，可以获取<code>key</code>对应的<code>hash slot</code></p><p><code>redis cluster</code>中每个<code>master</code>都会持有部分<code>slot</code>，比如有3个<code>master</code>，那么可能每个<code>master</code>持有5000多个<code>hash slot</code>。<code>hash slot</code>让<code>node</code>的增加和移除很简单，增加一个<code>master</code>，就将其他<code>master</code>的<code>hash slot</code>移动部分过去，减少一个<code>master</code>，就将它的<code>hash slot</code>移动到其他<code>master</code>上去。移动<code>hash slot</code>的成本是非常低的。客户端的<code>api</code>，可以对指定的数据，让他们走同一个<code>hash slot</code>，通过<code>hash tag</code>来实现。</p><p>任何一台机器挂机，另外两个节点不影响。因为<code>key</code>找的是<code>hash slot</code>，不是机器。</p><p><img src="/img/redis/41022A3C81D77421B84BFB25167EC3C8.jpg" alt="hash slot"></p><h2 id="redis-cluster实现高可用"><a href="#redis-cluster实现高可用" class="headerlink" title="redis cluster实现高可用"></a><code>redis cluster</code>实现高可用</h2><h3 id="判断节点挂机"><a href="#判断节点挂机" class="headerlink" title="判断节点挂机"></a>判断节点挂机</h3><p>如果一个节点认为另外一个节点挂机，那么就是<code>pfail</code>: <strong>主观挂机</strong>。如果多个节点都认为另外一个节点挂机了，那么就是<code>fail</code>: <strong>客观挂机</strong></p><p>在<code>cluster-node-timeout</code>内，某个节点一直没有返回<code>pong</code>，那么就被认为<code>pfail</code>。</p><p>如果一个节点认为某个节点<code>pfail</code>了，那么会在<code>gossip ping</code>消息中，<code>ping</code>给其他节点，如果超过半数的节点都认为<code>pfail</code>了，那么就会变成<code>fail</code>。</p><h3 id="从节点过滤"><a href="#从节点过滤" class="headerlink" title="从节点过滤"></a>从节点过滤</h3><p>对挂机的<code>master</code>，从其所有的<code>slave</code>中，选择一个切换成<code>master</code>。</p><p>检查每个<code>slave</code>与<code>master</code>断开连接的时间，如果超过了<code>cluster-node-timeout</code> ,那么就没有资格切换成<code>master</code>。</p><h3 id="从节点选举"><a href="#从节点选举" class="headerlink" title="从节点选举"></a>从节点选举</h3><p>每个<code>slave</code>都根据自己对<code>master</code>复制数据的<code>offset</code>，来设置一个选举时间，<code>offset</code>越大（复制数据越多）的<code>slave</code>，选举时间越靠前，优先进行选举</p><p>所有的<code>master</code>开始<code>slave</code>选举投票，给要进行选举的<code>slave</code>进行投票，如果大部分<code>master</code>（<code>N/2 + 1</code>）都投票给了某个<code>slave</code> ，那么选举通过，这个<code>slave</code>就可变成<code>master</code>。</p><p>然后，<code>slave</code>开始执行主备切换，切换成<code>master</code>。</p><h1 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a><code>Redis</code>缓存</h1><p>目前大多数公司对<code>redis</code>的应用在于构建分布式缓存方面，因此对于<code>redis</code>缓存使用，面试官会问下列一些问题</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>指缓存在某一时刻数据全部失效，所有对数据查询请求全部跑到<code>DB</code>，<code>DB</code>瞬时因为请求压力太大，产生挂机或耗时处理。严重的，甚至会让<code>DB</code>也挂掉。导致整体系统处于不可用状态。</p><p>缓存数据全部失效有两种可能:</p><ol><li>缓存服务器挂掉了</li><li>缓存数据中部分数据的缓存有效时间在某一个时刻全部集体失效，虽然缓存服务器还是可用状态，但是其中大部分缓存数据已不存在，对数据进行查询的请求只能走<code>DB</code></li></ol><p>解决方案:</p><ul><li>保证<code>redis</code>高可用，使用<code>redis cluster</code>避免全盘崩溃</li><li>本地<code>ehcache</code>缓存+<code>hystrix</code>限流&amp;降级，避免<code>DB</code>挂机</li><li><code>redis</code>数据做持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据</li><li>在原有的缓存有效时间上增加一个随机值，比如1-5分钟随机，或使用<code>java</code>的<code>random</code>方法。保证每个缓存数据有效时间的重复率降低，就不太会引发集体失效的事情</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>黑客发起的恶意攻击或是人为向缓存数据发起了一个缓存和<code>db</code>都不存在的数据查询请求。这个不存在的数据每次请求发现缓存中没有就会去<code>DB</code>查询，这样就失去了缓存存在意义。请求流量大时，可导致<code>DB</code>挂机不可用。</p><p>解决方案:</p><ul><li>将不存在的数据缓存起来，并设置一个过期时间，下次有相同的不存在数据查询请求过来，在缓存失效之前，都可直接从缓存中取出这个数据</li><li>在缓存之前，设置布隆过滤器，实际上是一个<code>bitMap</code>结构。当一个元素被加入时，将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，只要看看这些点是不是都是1就（大约）知道集合中有没有它了。如果这些点有任何一个0，则被检元素一定不存在；如果都是1，则被检元素很可能存在。不存在就直接返回（针对黑客攻击都采用这一方案）</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>某个<code>key</code>非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个<code>key</code>在失效瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。又被称之为缓存并发</p><p>解决方案:<br>使用分布式锁，保证对于每个<code>key</code>同时只有一个线程去查询，其他线程没有获得分布式锁，因此只能等待。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。下面会详细讲<code>redis</code>分布式锁实现。</p><p>至于某些资料说将数据设置为”永不过期“，个人认为是治标不治本的方法。容易引起缓存和<code>DB</code>数据不一致问题。</p><h2 id="缓存和DB数据双写一致"><a href="#缓存和DB数据双写一致" class="headerlink" title="缓存和DB数据双写一致"></a>缓存和<code>DB</code>数据双写一致</h2><p><code>DB</code>数据随着时间可能会发生变化，而缓存数据不及时同步更新就会不一致。所以需要做到最终一致。</p><p>目前做法是</p><ol><li>先写<code>DB</code>，再删除缓存（<code>Cache Aside</code>模式）</li><li>先删除缓存，再写<code>DB</code></li></ol><p>其实都有问题<br>如果1，在删除缓存前，写<code>DB</code>的线程挂了，没有删除掉缓存，则会出现数据不一致<br>如果2，删除了缓存，还没有来得及写<code>DB</code>，另一个线程就来读取，发现缓存为空，则去DB中读取数据写入缓存，此时缓存中就为脏数据。<br>本质是因为写和读是并发的，没法保证顺序,所以会出现数据不一致问题。</p><p>解决方案:</p><ul><li><p>情况1，异步更新缓存(基于订阅<code>binlog</code>的同步机制)<br><code>binlog</code>增量订阅消费+消息队列+增量数据更新到缓存<br>步骤</p><ol><li>写<code>DB</code></li><li>数据更新日志写入<code>binlog</code>中</li><li>读取<code>binlog</code>后，解析数据，利用消息队列推送到各节点更新缓存数据</li><li>尝试删除缓存操作</li><li>删除失败，将需要删除的缓存<code>Key</code>发送到消息队列中</li><li>从队列中拿到要删除的缓存<code>key</code>，再次尝试删除缓存，如果再次删除失败，可重发消息多次尝试;</li></ol><blockquote><p>总的来说就是提供一个”重试保障机制”，如果删除缓存失败，可将删除失败的key发送到消息队列，再进行重试删除操作</p></blockquote></li><li><p>情况2，延时双删策略+缓存超时设置<br>写<code>DB</code>前后都进行<code>redis.del</code>(<code>key</code>操作，并设定合理的有效时间)。<br>步骤</p><ol><li><p>先删缓存</p></li><li><p>再写<code>DB</code></p></li><li><p>休眠500毫秒<br>那么，这个500毫秒怎么确定的，具体休眠多久呢？</p><p>评估自己项目的读数据业务逻辑的耗时。目的是确保读请求结束，写请求可以删除读请求造成的缓存脏数据</p><p>还要考虑<code>redis</code>和<code>DB</code>主从同步的耗时。最后写数据的休眠时间应该在读数据业务逻辑的耗时基础上，加几百ms</p></li><li><p>再删缓存<br>给缓存设置有效时间，用来保证最终一致性。所有的写操作以<code>DB</code>为准，只要缓存有效时间到了，则后面的读请求自然会从<code>DB</code>中读取新值然后回填缓存</p></li></ol><blockquote><p>结合延时双删策略+缓存超时设置，最差情况是在有效时间内数据存在不一致，且增加了写请求的耗时</p></blockquote></li></ul><h1 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a><code>Redis</code>分布式锁</h1><h2 id="单Redis节点"><a href="#单Redis节点" class="headerlink" title="单Redis节点"></a>单<code>Redis</code>节点</h2><p>使用<code>setnx</code>命令创建一<code>key</code>，这样就算加锁。</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">SET resource_name my_random_value NX PX <span class="token number">30000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><ul><li><code>my_random_value</code>是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的</li><li><code>NX</code>表示只有<code>key</code>不存在的时候才会设置成功。（如果此时存在这个<code>key</code>，那么设置失败，返回<code>nil</code>）</li><li><code>PX 30000</code>意思是30s后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了</li></ul><p>释放锁就是删除<code>key</code>，一般可以用<code>lua</code>脚本删除，判断<code>value</code>一样才删除</p><div class="code-wrapper"><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。if redis.call("get",KEYS[1]) == ARGV[1] then    return redis.call("del",KEYS[1])else    return 0end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>这段<code>Lua</code>脚本在执行的时候要把前面的<code>my_random_value</code>作为<code>ARGV[1]</code>的值传进去，把<code>resource_name</code>作为<code>KEYS[1]</code>的值传进去。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><p>锁必须要设置一个过期时间。否则当一个客户端获取锁成功之后，假如它崩溃了，或者网络不可用导致它再也无法和<code>Redis</code>节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁。这个过期时间被称为锁的有效时间<code>lock validity time</code>。获得锁的客户端必须在这个时间之内完成对共享资源的访问</p></li><li><p>获取锁操作不应该写成</p> <div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">SETNX resource_name my_random_valueEXPIRE resource_name <span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>虽然这两个命令和前面描述中的<code>SET</code>命令执行效果相同，但却不是原子的。如果客户端在执行完<code>SETNX</code>后崩溃了，那么就没有机会执行<code>EXPIRE</code>了，导致它一直持有这个锁</p></li><li><p>设置一个随机字符串<code>my_random_value</code>保证了一个客户端释放的锁必须是自己持有的那个锁。假设获取锁时<code>SET</code>的不是随机字符串，而是固定值，那么可能会发生下面的执行序列</p><ul><li>客户端1获取锁成功。</li><li>客户端1在某个操作上阻塞了很长时间。</li><li>过期时间一到，锁自动释放。</li><li>客户端2获取到了对应同一个资源的锁。</li><li>客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。</li></ul><p>之后，客户端2在访问共享资源的时候，就没有锁为它提供保护了</p></li><li><p>释放锁的操作必须使用Lua脚本来实现。释放锁其实包含三步操作：<code>GET</code>、判断和<code>DEL</code>，用<code>Lua</code>脚本来实现能保证这三步的原子性。否则，如果把这三步操作放到客户端逻辑中去执行的话，就有可能发生与前面问题3类似的执行序列</p><ul><li>客户端1获取锁成功。</li><li>客户端1访问共享资源。</li><li>客户端1为了释放锁，先执行<code>GET</code>操作获取随机字符串的值。</li><li>客户端1判断随机字符串的值，与预期的值相等。</li><li>客户端1由于某个原因阻塞住了很长时间。</li><li>过期时间到了，锁自动释放了。</li><li>客户端2获取到了对应同一个资源的锁。</li><li>客户端1从阻塞中恢复过来，执行<code>DEL</code>操作，释放掉了客户端2持有的锁。</li></ul></li><li><p>假如<code>Redis</code>节点挂机了，那么所有客户端就都无法获得锁，服务变得不可用。为了提高可用性，给这个<code>Redis</code>节点挂一个<code>Slave</code>，当<code>Master</code>不可用时，系统自动切到<code>Slave</code>上（<code>failover</code>）。但由于<code>Redis</code>的主从复制（<code>replication</code>）是异步的，这可能导致<code>failover</code>过程中丧失锁了的安全性。考虑下面的执行序列:</p><ul><li>客户端1从<code>Master</code>获取了锁</li><li><code>Master</code>挂机了，存储锁的<code>key</code>还没有来得及同步到<code>Slave</code>上。</li><li><code>Slave</code>升级为<code>Master</code></li><li>客户端2从新<code>Master</code>获取到了对应同一个资源的锁</li></ul><p>于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破</p></li></ol><p>基于单<code>Redis</code>节点的分布式锁无法解决这个问题5。而正是这个问题催生了<code>RedLock</code>的出现</p><h2 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h2><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="/img/redis/E8FE04BB912A5E2A30210D36DE4785E1.jpg" alt="Redission原理图"></p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p><code>Lua</code>脚本</p><div class="code-wrapper"><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">if</span> (redis.call(<span class="token string">'exists'</span>, KEYS[1]) == 0) then         redis.call(<span class="token string">'hset'</span>, KEYS[1], ARGV[2], 1)</span><span class="token punctuation">;</span>         <span class="token directive"><span class="token keyword">redis.call('pexpire',</span> KEYS[1], ARGV[1])</span><span class="token punctuation">;</span>          <span class="token directive"><span class="token keyword">return</span> nil</span><span class="token punctuation">;</span>          <span class="token directive"><span class="token keyword">end</span></span><span class="token punctuation">;</span><span class="token directive"><span class="token keyword">if</span> (redis.call(<span class="token string">'hexists'</span>, KEYS[1], ARGV[2]) == 1) then        redis.call(<span class="token string">'hincrby'</span>, KEYS[1], ARGV[2], 1)</span><span class="token punctuation">;</span>        <span class="token directive"><span class="token keyword">redis.call('pexpire',</span> KEYS[1], ARGV[1])</span><span class="token punctuation">;</span>         <span class="token directive"><span class="token keyword">return</span> nil</span><span class="token punctuation">;</span>        <span class="token directive"><span class="token keyword">end</span></span><span class="token punctuation">;</span><span class="token directive"><span class="token keyword">return</span> redis.call(<span class="token string">'pttl'</span>, KEYS[1])</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>为什么要用<code>lua</code>?<br>通过封装在<code>lua</code>脚本中发送给<code>redis</code>，保证执行的原子性</p><p>解释</p><p><code>KEYS[1]</code>:表示你加锁的那个<code>key</code>，比如说</p><div class="code-wrapper"><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">RLock</span> lock = redisson.getLock(“myLock”)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>这里你自己设置了加锁的那个锁<code>key</code>就是<code>myLock</code>。</p><p><code>ARGV[1]</code>:表示锁的有效期，默认30s<br><code>ARGV[2]</code>:表示表示加锁的客户端ID,类似于下面这样<br><code>8743c9c0-0795-4907-87fd-6c719a6b4586:1</code></p><p>用<code>exists myLock</code>命令判断，如果要加锁的那个锁<code>key</code>不存在就进行加锁,接着执行<code>pexpire myLock 30000</code>命令，设置<code>myLock</code>这个锁<code>key</code>的生存时间是30秒(默认)</p><h3 id="锁互斥"><a href="#锁互斥" class="headerlink" title="锁互斥"></a>锁互斥</h3><p>如果客户端2尝试加锁，执行了同样的一段<code>lua</code>脚本，第一个<code>if</code>判断会执行<code>exists myLock</code>，发现<code>myLock</code>这个锁<code>key</code>已经存在了。</p><p>接着第二个<code>if</code>判断，判断一下，<code>myLock</code>锁<code>key</code>的<code>hash</code>数据结构中，是否包含客户端2的<code>ID</code>，但明显不是，包含的是客户端1的<code>ID</code>。</p><p>所以，客户端2会获取到<code>pttl myLock</code>返回的一个数字，这个数字代表了<code>myLock</code>这个锁<code>key</code>的剩余生存时间。比如还剩15000毫秒的生存时间。</p><p>此时客户端2会进入一个<code>while</code>循环，不停的尝试加锁。</p><h3 id="watch-dog自动延期机制"><a href="#watch-dog自动延期机制" class="headerlink" title="watch dog自动延期机制"></a><code>watch dog</code>自动延期机制</h3><p>客户端1加锁的锁<code>key</code>默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办？</p><p>只要客户端1一旦加锁成功，就会启动一个<code>watch dog</code>看门狗，这是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁<code>key</code>，那就会不断的延长锁<code>key</code>的生存时间。续命操作</p><h3 id="可重入加锁机制"><a href="#可重入加锁机制" class="headerlink" title="可重入加锁机制"></a>可重入加锁机制</h3><p>如果客户端1已经持有这把锁，可重入的加锁会如何</p><div class="code-wrapper"><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token comment">#重入加锁</span><span class="token directive"><span class="token keyword">RLock</span> lock = redisson.getLock(<span class="token string">"myLock"</span>)lock.lock()</span><span class="token punctuation">;</span>//业务代码<span class="token directive"><span class="token keyword">lock.lock()</span></span><span class="token punctuation">;</span>//业务代码<span class="token directive"><span class="token keyword">lock.unlock()</span></span><span class="token punctuation">;</span><span class="token directive"><span class="token keyword">lock.unlock()</span></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>分析上面<code>lua</code>代码<br>第一个<code>if</code>判断不成立，<code>exists myLock</code>会显示锁<code>key</code>已经存在了</p><p>第二个<code>if</code>会成立，因为<code>myLock</code>的<code>hash</code>数据结构中包含的客户端1的<code>ID</code></p><p>此时就会执行可重入加锁的逻辑，用<code>incrby</code>这个命令，对客户端1的加锁次数，累加1</p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><div class="code-wrapper"><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">if</span> (redis.call(<span class="token string">'exists'</span>, KEYS[1]) == 0) then       redis.call(<span class="token string">'publish'</span>, KEYS[2], ARGV[1])</span><span class="token punctuation">;</span>        <span class="token directive"><span class="token keyword">return</span> <span class="token number">1</span></span><span class="token punctuation">;</span>         <span class="token directive"><span class="token keyword">end</span></span><span class="token punctuation">;</span><span class="token directive"><span class="token keyword">if</span> (redis.call(<span class="token string">'hexists'</span>, KEYS[1], ARGV[3]) == 0) then      return nil</span><span class="token punctuation">;</span>     <span class="token directive"><span class="token keyword">end</span></span><span class="token punctuation">;</span><span class="token directive"><span class="token keyword">local</span> counter = redis.call(<span class="token string">'hincrby'</span>, KEYS[1], ARGV[3], -1)</span><span class="token punctuation">;</span> <span class="token directive"><span class="token keyword">if</span> (counter > 0) then     redis.call(<span class="token string">'pexpire'</span>, KEYS[1], ARGV[2])</span><span class="token punctuation">;</span>      <span class="token directive"><span class="token keyword">return</span> <span class="token number">0</span></span><span class="token punctuation">;</span> <span class="token directive"><span class="token keyword">else</span> redis.call(<span class="token string">'del'</span>, KEYS[1])</span><span class="token punctuation">;</span>      <span class="token directive"><span class="token keyword">redis.call('publish',</span> KEYS[2], ARGV[1])</span><span class="token punctuation">;</span>      <span class="token directive"><span class="token keyword">return</span> <span class="token number">1</span></span><span class="token punctuation">;</span>     <span class="token directive"><span class="token keyword">end</span></span><span class="token punctuation">;</span><span class="token directive"><span class="token keyword">return</span> nil</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>执行<code>lock.unlock()</code>，释放分布式锁，每次对<code>myLock</code>数据结构中的那个加锁次数减1。如果发现加锁次数是0了，说明客户端1已不再持有锁，此时就会用：<code>del myLock</code>命令，从<code>redis</code>里删除这个<code>key</code>。<br>然后另外的客户端2就可尝试加锁。</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>见<a href="3135569683.html#%E5%8D%95Redis%E8%8A%82%E7%82%B9">单Redis节点</a>问题5，<code>redis</code>主从异步复制导致<code>redis</code>分布式锁的最大缺陷:<br>在<code>redis master</code>实例挂掉时，可能导致多个客户端同时完成加锁。所以还是要实现<code>RedLock</code></p><h2 id="集群Redis节点（RedLock）"><a href="#集群Redis节点（RedLock）" class="headerlink" title="集群Redis节点（RedLock）"></a>集群<code>Redis</code>节点（<code>RedLock</code>）</h2><p>运行<code>RedLock</code>算法的客户端依次执行下面各个步骤，来完成获取锁的操作</p><ol><li>获取当前时间（毫秒数）</li><li>按顺序依次向N个<code>Redis</code>节点执行获取锁的操作。这个获取操作跟单<code>Redis</code>节点获取锁的过程相同，包含随机字符串<code>my_random_value</code>，也包含过期时间(比如<code>PX 30000</code>，即锁的有效时间)。为保证在某个<code>Redis</code>节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(<code>time out</code>)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个<code>Redis</code>节点获取锁失败以后，应该立即尝试下一个<code>Redis</code>节点。这里的失败，应该包含任何类型的失败，比如该<code>Redis</code>节点不可用，或者该<code>Redis</code>节点上的锁已经被其它客户端持有</li><li>计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数<code>Redis</code>节点（<code>&gt;= N/2+1</code>）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(<code>lock validity time</code>)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</li><li>如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。</li><li>如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于<code>N/2+1</code>，或整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应立即向所有<code>Redis</code>节点发起释放锁的操作（即前面介绍的<code>Lua</code>脚本）</li></ol><p>当然，上面描述的只是获取锁的过程，而释放锁的过程比较简单: 客户端向所有<code>Redis</code>节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。</p><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><ol><li><p>如果有节点发生崩溃重启，还是会对锁的安全性有影响的。具体的影响程度跟<code>Redis</code>对数据的持久化程度有关。<br>假设一共有5个<code>Redis</code>节点：A, B, C, D, E。设想发生了如下的事件序列:</p><ul><li>客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。</li><li>节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</li><li>节点C重启后，客户端2锁住了C, D, E，获取锁成功。</li></ul><p>这样，客户端1和客户端2同时获得了锁（针对同一资源）,需要延迟重启解决。也就是说，一个节点崩溃后，先不立即重启，等待一段时间再重启，这段时间应该大于锁的有效时间(<code>lock validity time</code>)。这样这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p></li><li><p>释放锁的时候，客户端应该向所有<code>Redis</code>节点发起释放锁的操作。即使当时向某个节点获取锁没有成功，在释放锁的时候也不应该漏掉这个节点。why？设想这样一种情况，客户端发给某个<code>Redis</code>节点的获取锁请求成功到达了该<code>Redis</code>节点，这个节点也成功执行了<code>SET</code>操作，但是它返回给客户端的响应包丢失了。在客户端看来，获取锁的请求由于超时而失败，但在<code>Redis</code>这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些<code>Redis</code>节点同样发起请求</p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://gitee.com/shishan100/Java-Interview-Advanced">中华石杉–互联网Java进阶面试训练营</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w">基于Redis的分布式锁到底安全吗？（上）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/4CUe7OpM6y1kQRK8TOC_qQ">基于Redis的分布式锁到底安全吗？（下）</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1d741127ZA?p=5">2020最全Redis分布式锁全集</a></p></li></ol><h1 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a><a href="/Redis">推荐书单</a></h1>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂方法模式</title>
    <link href="/posts/1213826201.html"/>
    <url>/posts/1213826201.html</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>又名虚拟构造函数（<code>VirtualConstructor</code>）模式或多态性工厂（<code>Polymorphic Factory</code>）模式。</p><p>它定义了一个创建产品对象的工厂接口，将实际创建对象的工作推迟到子类中。</p><p><img src="/img/factory/CFE6A0B618DC5178A0FFCA022F07E96B.png" alt="工厂方法"></p><p>为何要这样做？可见下列代码</p><p>代码实现场景:<br>有一家造车公司，旗下有<code>brand_one</code>,<code>brand_two</code>两个车辆品牌，每部车都有自己的车型名，品牌编号(品牌编号是用来区分某辆车是属于何种品牌下的)，我们用1和2作为品牌编号，来区分。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token punctuation">(</span>access <span class="token operator">=</span> <span class="token class-name">AccessLevel</span><span class="token punctuation">.</span>PRIVATE<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Constants</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> BRAND_ONE <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> BRAND_TWO <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IVehicle</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vehicle</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> id<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> brandCode<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@EqualsAndHashCode</span><span class="token punctuation">(</span>callSuper <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BrandOne</span> <span class="token keyword">extends</span> <span class="token class-name">Vehicle</span> <span class="token keyword">implements</span> <span class="token class-name">IVehicle</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"BrandOne\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@EqualsAndHashCode</span><span class="token punctuation">(</span>callSuper <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BrandTwo</span> <span class="token keyword">extends</span> <span class="token class-name">Vehicle</span> <span class="token keyword">implements</span> <span class="token class-name">IVehicle</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"BrandTwo\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NoFactory</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">IVehicle</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> brandCode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">IVehicle</span> vehicle <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>BRAND_ONE <span class="token operator">==</span> brandCode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      vehicle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrandOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>BRAND_TWO <span class="token operator">==</span> brandCode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      vehicle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrandTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> vehicle<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span><span class="token class-name">NoFactory</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>乍一看，<code>Client</code>类代码没有任何问题。但是假设如果有第三种品牌，那么在创建完<code>BrandThree</code>类之外，还要在<code>Constants</code>中加上</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> BRAND_THREE <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>这个字符串变量。除此之外，还要修改<code>NoFactory</code>类的<code>createProduct</code>方法中的<code>if</code>那段判断，加上第3种，<code>BrandThree</code>类的<code>new</code>操作。那就肯定破坏了<code>SOLID</code>原则中的开闭原则。</p><p>另外，虽然上述代码是个例子，但是在一个具体的业务逻辑对象(比如<code>NoFactory</code>)里，除了实现业务逻辑之外，还要负责判断<code>new</code>哪些个对象，这显然也明显没有符合单一职责原则。</p><p>所以，我们代码写得时间长了，不仅仅要考虑功能的实现和系统可用性问题，还要多多考虑可抽象，可重用的可能性。因此工厂方法模式就应运而生了。</p><p>在具体介绍工厂方法模式之前，需要介绍一下一种不算23种设计模式之中的设计模式–简单工厂模式。目前被使用的很多，也是更好理解工厂方法模式的基础</p><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>对于产品种类比较少的情况，可使用这种模式方便地创建所需产品。</p><p>使用该模式的<code>client</code>客户端只需传入工厂<code>Factory</code>类的参数，并不需要关心如何创建对象的逻辑。</p><p>具体<code>uml</code>图如下</p><p><img src="/img/factory/B19B5DEEA9DD7ED79DE13AAF711789A2.png" alt="简单工厂"></p><p>按照上图可知该模式主要包含3种角色。</p><ol><li>简单工厂类（<code>SimpleFactory</code>）<br>该模式的核心，负责实现所有<code>Product</code>实例的内部创建逻辑。工厂类的<code>createProduct</code>方法可被外界直接调用，创建所需的<code>Product</code>对象</li><li>抽象产品（<code>Product</code>）<br>是所有简单工厂类创建的对象的父类，负责描述所有实例公共逻辑的接口</li><li>具体产品（<code>ConcreteProduct</code>）<br>该模式的创建目标</li></ol><h3 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h3><p>我们以前述<code>NoFactory</code>类代码中的<code>Vehicle</code>，<code>BrandOne</code>，<code>BrandTwo</code>等类的逻辑为例子，可编写下列源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">IVehicle</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> brandCode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>brandCode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">case</span> BRAND_ONE<span class="token operator">:</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BrandOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> BRAND_TWO<span class="token operator">:</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BrandTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 传入工厂Factory类的参数BRAND_ONE</span>    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span><span class="token class-name">SimpleFactory</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>BRAND_ONE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 传入工厂Factory类的参数BRAND_TWO</span>    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span><span class="token class-name">SimpleFactory</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>BRAND_TWO<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>其中<code>IVehicle</code>就是<code>Product</code>角色，<code>BrandOne</code>和<code>BrandTwo</code>就是具体的<code>ConcreteProduct</code>产品。<code>Client</code>类调用<code>SimpleFactory</code>，传入具体的产品品牌（<code>Constants</code>中定义）值，创建需要的具体产品对象。运行<code>Client</code>类结果截图如下:</p><p><img src="/img/factory/62722340134AC61405F1493C2DD0C212.jpg" alt="运行结果"></p><p>可见打印出的各自具体产品类的<code>doSomething</code>方法中的内容。<code>SimpleFactory</code>类中的<code>createProduct</code>方法符合单一职责原则，只做创建具体产品这一件事。</p><p>但是，如果有第三种具体产品，除了新建<code>BrandThree</code>类之外，<code>Constants</code>类中要新加第三种产品品牌值，还要修改<code>SimpleFactory</code>类中的<code>createProduct</code>方法，因此还是违反了开闭原则。</p><p>这个时候，我们需要再次进行改进，使用反射机制，让第三种具体产品类和原来两种产品在被使用时才被实例化，这样就能保证符合开闭原则。</p><h3 id="反射实例"><a href="#反射实例" class="headerlink" title="反射实例"></a>反射实例</h3><p>改进的具体代码如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">IVehicle</span><span class="token punctuation">></span><span class="token punctuation">></span></span> registerProductMap <span class="token operator">=</span>      <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">registerProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> brandCode<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">IVehicle</span><span class="token punctuation">></span></span> vehicleClazz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    registerProductMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>brandCode<span class="token punctuation">,</span> vehicleClazz<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">IVehicle</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> brandCode<span class="token punctuation">)</span>      <span class="token keyword">throws</span> <span class="token class-name">NoSuchMethodException</span><span class="token punctuation">,</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">,</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span>          <span class="token class-name">IllegalAccessException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">IVehicle</span><span class="token punctuation">></span></span> productClazz <span class="token operator">=</span> registerProductMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>brandCode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> productClazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>      <span class="token keyword">throws</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchMethodException</span><span class="token punctuation">,</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span>          <span class="token class-name">IllegalAccessException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">SimpleFactory</span><span class="token punctuation">.</span><span class="token function">registerProduct</span><span class="token punctuation">(</span>BRAND_ONE<span class="token punctuation">,</span> <span class="token class-name">BrandOne</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">SimpleFactory</span><span class="token punctuation">.</span><span class="token function">registerProduct</span><span class="token punctuation">(</span>BRAND_TWO<span class="token punctuation">,</span> <span class="token class-name">BrandTwo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span><span class="token class-name">SimpleFactory</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>BRAND_ONE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span><span class="token class-name">SimpleFactory</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>BRAND_TWO<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>运行<code>Client</code>类结果和之前一样。</p><p>请见<code>createProduct</code>方法最后一行</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">return</span> productClazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>可知，产品在被使用时，我们通过获取构造方法实例化了新实例</p><p>但是众所周知，反射性能不是很高，因此在有性能要求的场景下，不太合适（当然，现在几乎所有公司都对性能要求很高）</p><p>因此可以换个思路，对于前述方式，我们不把每个产品class对象注册到map对象里，我们直接把每个产品对象实例注册进去，让我们试试看</p><h3 id="直接实例"><a href="#直接实例" class="headerlink" title="直接实例"></a>直接实例</h3><p>我写的代码如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">IVehicle</span><span class="token punctuation">></span></span> registerProductMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">registerProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> brandCode<span class="token punctuation">,</span> <span class="token class-name">IVehicle</span> vehicle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    registerProductMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>brandCode<span class="token punctuation">,</span> vehicle<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">IVehicle</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> brandCode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> registerProductMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>brandCode<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>      <span class="token keyword">throws</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchMethodException</span><span class="token punctuation">,</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span>          <span class="token class-name">IllegalAccessException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">SimpleFactory</span><span class="token punctuation">.</span><span class="token function">registerProduct</span><span class="token punctuation">(</span>BRAND_ONE<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">BrandOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">SimpleFactory</span><span class="token punctuation">.</span><span class="token function">registerProduct</span><span class="token punctuation">(</span>BRAND_TWO<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">BrandTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span><span class="token class-name">SimpleFactory</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>BRAND_ONE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span><span class="token class-name">SimpleFactory</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>BRAND_TWO<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>运行<code>Client</code>类结果也是一样</p><p>这样，我们执行<code>SimpleFactory</code>类的<code>createProduct</code>方法，就能直接获取到某个具体产品对象实例，无需再做实例化工作。</p><p>但这样，我之前说过，在产品种类比较少的时候，你可以直接<code>new</code>一个对象实例放入<code>map</code>，然后用简单工厂类的<code>createProduct</code>方法，直接从<code>map</code>里拿出对象实例。如果有很多很多产品，你就要写很多行放<code>map</code>的<code>put</code>操作语句，然后调用很多次<code>createProduct</code>方法。这样不便于日后代码维护，代码量虽然很多（有些公司<code>kpi</code>考核有一项是提交代码行数，提得越多，这一项<code>kpi</code>考核分数越高），但不觉得很臃肿么？(当然我并不是说，不应该把”代码提交行数”作为<code>kpi</code>考核指标，而是”代码提交行数”只应该是<code>kpi</code>考核众多指标中的一种，不应该把它作为重要的考核指标之一)</p><p>所以我个人不认为简单工厂方法算设计模式中的一种。且本来23种设计模式中也没有它。只是因为对于产品种类比较少的场景，能比较方便和快速的实现我们的需求。但代码的可扩展性其实是很差的。</p><p>因此，我们还是回来继续介绍工厂方法模式</p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>开头我们说过了工厂方法的概念以及为何使用的原因。也展现过它的<code>uml</code>图，我们重新把这张图拿出来深入讲一下</p><p><img src="/img/factory/CFE6A0B618DC5178A0FFCA022F07E96B.png" alt="工厂方法"></p><p>从这张图，可知工厂方法的实现，要有4种角色。有两种和简单工厂一样</p><ol><li>抽象工厂类（<code>Factory</code>）<br>模式的核心，任何具体工厂类都必须要实现该接口</li><li>具体工厂类（<code>ConcreteFactory</code>）<br>除了实现抽象工厂类之外，它还承担了创建具体产品对象的职责</li><li>抽象产品（<code>Product</code>）<br>所有被创建的对象的共同父类，即所有具体产品对象的父类或接口</li><li>具体产品（<code>ConcreteProduct</code>）<br>该对象由某个专门负责创建它的具体工厂类创建，所以和具体工厂类是一一对应的关系。</li></ol><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BrandOneFactory</span> <span class="token keyword">implements</span> <span class="token class-name">VehicleFactory</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">IVehicle</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BrandOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BrandTwoFactory</span> <span class="token keyword">implements</span> <span class="token class-name">VehicleFactory</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">IVehicle</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BrandTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">VehicleFactory</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">IVehicle</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">VehicleFactory</span> brandOneFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrandOneFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    brandOneFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">VehicleFactory</span> brandTwoFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrandTwoFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    brandTwoFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><code>Vehicle</code>，<code>BrandOne</code>，<code>BrandTwo</code>等类代码见前述，这里就不一一详述。</p><p>和简单工厂模式代码相比，其实就是简单工厂类拆分成抽象和具体两个角色的工厂类。这两个角色将实际创建产品对象的具体逻辑和定义分开来。每个具体工厂类（抽象工厂类的子类）负责创建某个具体产品。也就是开头所说的“定义了一个创建产品对象的工厂接口，将实际创建对象的工作推迟到子类中”</p><p>另外它改正了简单工厂破坏关闭原则的缺点。如果要增加第三个产品，只需要再扩展新建一个具体工厂类，也无需再对任何工厂类代码进行修改（无论抽象还是具体工厂类）。</p><p>但是，基于最初描述的代码实现场景，这家公司业务开始扩大化，进军新能源汽车制造领域，那同样是这两个品牌，创建产品时，我们如何来区分制造的是普通车还是新能源车？</p><p>这样，在工厂方法模式的基础上，就产生了抽象工厂模式~</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>抽象工厂模式是工厂方法模式的升级。</p><p>为创建一组相互关联或依赖的对象提供接口，无需关心这些对象的具体实现方式。</p><p>在前述开始有新能源车场景下，通过它来创建我们需要的产品对象</p><p>具体uml图如下</p><p><img src="/img/factory/74F23CACFEF4670CFD1E23B4192F12A1.jpg" alt="抽象工厂"></p><p>图中可知，和工厂方法一样，也分4种角色</p><ol><li>抽象工厂类（<code>AbstractFactory</code>）<br>模式的核心，任何具体工厂类都必须要实现该接口</li><li>具体工厂类（<code>ConcreteFactory</code>）<br>除了实现抽象工厂类之外，它还包含选择合适的产品对象创建逻辑</li><li>抽象产品（<code>AbstractProduct</code>）<br>负责定义产品共同点，实现不同产品的最抽象定义</li><li>具体产品（<code>ConcreteProduct</code>）<br>实现抽象产品的抽象定义。抽象工厂模式创建的任何产品对象都将是其中一个具体产品对象的实例。</li></ol><h3 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h3><p>具体创建不同类型（普通还是新能源？），不同品牌（<code>brand_one</code>还是<code>brand_two</code>？）产品的完整代码如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BrandOneVehicle</span> <span class="token keyword">implements</span> <span class="token class-name">IVehicle</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Vehicle BrandOne\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BrandTwoVehicle</span> <span class="token keyword">implements</span> <span class="token class-name">IVehicle</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Vehicle BrandTwo\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BrandOneNewEnergyVehicle</span> <span class="token keyword">implements</span> <span class="token class-name">INewEnergyVehicle</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"NewEnergyVehicle BrandOne\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BrandTwoNewEnergyVehicle</span> <span class="token keyword">implements</span> <span class="token class-name">INewEnergyVehicle</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"NewEnergyVehicle BrandTwo\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IVehicle</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">INewEnergyVehicle</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BrandOneFactory</span> <span class="token keyword">implements</span> <span class="token class-name">VehicleFactory</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">IVehicle</span> <span class="token function">createVehicleProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BrandOneVehicle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">INewEnergyVehicle</span> <span class="token function">createNewEnergyVehicleProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BrandOneNewEnergyVehicle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BrandTwoFactory</span> <span class="token keyword">implements</span> <span class="token class-name">VehicleFactory</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">IVehicle</span> <span class="token function">createVehicleProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BrandTwoVehicle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">INewEnergyVehicle</span> <span class="token function">createNewEnergyVehicleProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BrandTwoNewEnergyVehicle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">VehicleFactory</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">IVehicle</span> <span class="token function">createVehicleProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">INewEnergyVehicle</span> <span class="token function">createNewEnergyVehicleProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">BrandOneFactory</span> brandOneFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrandOneFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BrandTwoFactory</span> brandTwoFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrandTwoFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    brandOneFactory<span class="token punctuation">.</span><span class="token function">createVehicleProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    brandTwoFactory<span class="token punctuation">.</span><span class="token function">createVehicleProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    brandOneFactory<span class="token punctuation">.</span><span class="token function">createNewEnergyVehicleProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    brandTwoFactory<span class="token punctuation">.</span><span class="token function">createNewEnergyVehicleProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>运行<code>client</code>类<code>main</code>方法结果如下图</p><p><img src="/img/factory/35B175A65AA8F4C7446054BB83BD3DAD.jpg" alt="运行结果"></p><p>在上述代码中<code>VehicleFactory</code>作为抽象工厂类，是所有具体工厂类都要实现的接口，和工厂方法模式里抽象工厂类角色承担的职责是一样的。唯一不一样地方，是这个类内部定义了两种类型产品（普通和新能源）创建方式。而简单工厂模式里的<code>VehicleFactory</code>接口没有对创建何种类型产品做细分。这也就是我为啥说抽象工厂是工厂方法的升级的原因之一，抽象工厂进一步扩展了产品的定义。</p><p><code>BrandOneFactory</code>和<code>BrandTwoFactory</code>两个具体工厂类，分别实现了具体类型的产品对象创建逻辑，让<code>Client</code>自由选择是创建普通，还是新能源类型的产品。选择权给了具体调用它们的<code>Client</code>类。</p><p><code>INewEnergyVehicle</code>和<code>IVehicle</code>作为抽象产品角色，定义了普通和新能源两种类型车辆产品共同点，各自是具体产品<code>BrandOneNewEnergyVehicle</code>，<code>BrandTwoNewEnergyVehicle</code>，<code>BrandOneVehicle</code>，<code>BrandTwoVehicle</code>的抽象定义，在<code>Client</code>类中创建的4种产品对象都是它们的具体对象实例。</p><p>从以上代码和描述可知，产品品牌和类型形成了一个关系依赖矩阵，见下列表格</p><table><thead><tr><th align="left"></th><th align="left">普通</th><th align="left">新能源</th></tr></thead><tbody><tr><td align="left">品牌1</td><td align="left">BrandOneVehicle</td><td align="left">BrandOneNewEnergyVehicle</td></tr><tr><td align="left">品牌2</td><td align="left">BrandTwoVehicle</td><td align="left">BrandTwoNewEnergyVehicle</td></tr></tbody></table><p>此时如果我们增加品牌3的确没问题，新建一个具体工厂类就ok了。的确符合开闭原则。但如果是新建一种类型，<code>VehicleFactory</code>这个抽象工厂类就要加个方法。那相应的<code>BrandOneFactory</code>和<code>BrandTwoFactory</code>这两个具体工厂类也要加实现方法。</p><p>所以说抽象工厂并没有完全符合开闭原则。此外，相对于简单工厂和工厂方法，抽象工厂代码抽象性更高，理解上也更难点。而且实际业务场景下，也不是所有产品都可抽象成普通和新能源两种类型，从而形成上面这个关系依赖矩阵。</p><p>也就是说，在不可抽象和抽象性较低的情况下，抽象工厂模式并不适用。我们要在理解业务逻辑基础上，明白那些产品可抽象或者抽象性较高，才能使用抽象工厂模式进行代码实现，反之，则不行。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://gitee.com/darkranger/beating-interviewer/tree/master/src/main/java/com/wujunshen/designpattern/creational/factory">本文示例源码地址</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>创建型模式</tag>
      
      <tag>简单工厂</tag>
      
      <tag>工厂方法</tag>
      
      <tag>抽象工厂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMM</title>
    <link href="/posts/3489062241.html"/>
    <url>/posts/3489062241.html</url>
    
    <content type="html"><![CDATA[<p>Java内存模型（JMM）</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>规范JVM如何提供按需禁用缓存和编译优化的方法。这些方法包括<code>volatile</code>、<code>synchronized</code>和<code>final</code>三个关键字，以及六项<code>Happens-Before</code>规则</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>解决多线程通过对共享内存进行通信时，会存在的本地内存数据不一致(可见性问题)、编译器对代码指令重排序(有序性问题)、处理器对代码乱序执行(原子性问题)等问题</p><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>先看一下物理机内存模型</p><ol><li><p>CPU直接读取<br>计算机发展早期，CPU处理速度和内存读写速度相匹配，所以CPU直接从内存中读取数据</p><p><img src="/img/jmm/85AB4E9C-2FEA-4A13-875D-7A9144E9CC73.png" alt="CPU直接读取"></p></li><li><p>单缓存读取<br>CPU处理技术不断发展，内存没有多大变化，内存读写速度远远跟不上CPU处理速度，故在CPU和内存之间引入高速缓存。它的特点是速度快，内存小且昂贵</p><p><img src="/img/jmm/307BCD65-8BC7-499A-8D83-C863A077F650.png" alt="单缓存读取"></p></li><li><p>多级缓存读取<br>现在发展成缓存变成了多级缓存，CPU也从单核发展成多核。单核CPU只含有一套L1，L2，L3缓存<br>如果CPU多核，每核都含有一套L1(甚至和L2)缓存，而共享L3(或者和L2)缓存。<br>当CPU读取数据时，首先从一级缓存中查找，如果没有找到，再从二级缓存中查找，如果还没有就从三级缓存或内存中查找</p><p><img src="/img/jmm/35D9AB1D-EC54-4E2C-9995-CB9C27254149.png" alt="多缓存读取"></p></li></ol><p>发展到第3种情况，就可能存在前述可见性，有序性和原子性等问题，我们一个一个问题描述形成和来源原因</p><ol><li><p>数据不一致(可见性问题)<br>多核CPU，多线程情况下，每个CPU核都至少有一个L1缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的CPU核上执行，则它们会在各自的cache中保留一份共享内存的缓冲。由于可并行执行，可能会出现多个线程同时写各自的缓存的情况，而各自cache之间的数据就有可能不同。也就是说，在多核CPU中，每个CPU核的缓存里，<strong>关于同一数据的缓存内容可能不一致</strong></p></li><li><p>指令重排序(有序性问题)<br>编译器编译和处理器运行时，会做指令重排。主要目的是为了进行性能优化。<br><strong>编译器重排</strong>是为了在CPU计算时，如果要访问某个值，可以利用寄存器中已有的值，不用去内存再读取，从而提升性能。<br><strong>处理器重排</strong>是为了把具有相似功能单元的指令接连起来执行，从而减少流水线中断的情况。因为CPU有多个功能单元（获取、解码、运算和获取结果），一条指令也分为多个功能单元。所以在第一条指令执行还没完毕时，可以执行第二条指令，但前提是这两条指令的功能单元相同或类似，这也就是所谓的<strong>cpu流水线技术</strong><br>如图</p><p><img src="/img/jmm/65F691E0-B889-4B29-9C9A-7A0AD805332D.png" alt="cpu流水线技术"></p><p>指令1和2都是5个功能单元，假设每个单元耗时1毫秒执行，那么两条指令各自执行耗时5毫秒。如果指令2等指令1执行完再执行，那要等5毫秒，但是图中两条指令头一个功能单元都是IF，这个时候指令2就可以不必等待指令1全部执行完再执行，只要等1毫秒就可以开始执行，就算指令1还没执行结束也可以，这样指令2只需等待1毫秒时间，等待速度提升了5倍。但是流水线技术一旦被中断，重新进入流水线操作需要cpu和其他硬件等待一定的硬件周期时间，性能就差了。所以为了减少流水线中断情况，处理器会进行重排序操作。<br>但是这样都会把代码顺序打乱。指令被重排，可能就不会按照程序员的意愿去执行了</p></li><li><p>处理器对代码乱序执行(原子性问题)<br>为了使处理器内部的运算单元能尽量被充分利用，它可能会对输入的代码进行乱序执行处理。这就是所谓的<strong>处理器优化</strong>。但是看起来初衷很好，其实还有问题。主要是处理器虽然会在计算后，将乱序执行的结果重组，保证该结果与顺序执行的结果一致，可惜并不能保证程序中各个语句计算的先后顺序与代码的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果时，它的顺序性并不能靠代码的先后顺序来保证</p></li></ol><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>为了解决前述这些三大性质(可见性，有序性，原子性)问题，引入了JMM。大致结构如下图</p><p><img src="/img/jmm/36282CBE-203E-4955-A412-517A0CF04BC4.png" alt="JMM结构"></p><ol><li>JMM规定所有的变量都存储在主内存中，每个线程有自己的工作内存，线程的工作内存保存了该线程中用到的变量的主内存副本拷贝</li><li>线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存</li><li>不同的线程间也无法直接访问互相工作内存中的变量，线程间变量如果需要互相传递，都需要自己的工作内存和主内存之间进行数据同步来进行</li></ol><p><code>volatile</code>关键字提供了被其修饰的变量在被修改后可立即同步到主内存的功能，被其修饰的变量在每次使用之前都会从主内存刷新。因此，解决了可见性问题。除<code>volatile</code>，<code>synchronized</code>和<code>final</code>关键字也解决了可见性问题。</p><p>除此之外，<code>synchronized</code>和<code>volatile</code>能保证方法和代码块内的操作是有序性的。但<code>synchronized</code>还可保证操作的原子性。而<code>volatile</code>关键字只会禁止指令重排。</p><p>总结下来，就是</p><ul><li><code>volatile</code>解决可见性和有序性问题</li><li><code>synchronized</code>能解决所有三大性质问题</li><li><code>final</code>只能解决可见性问题</li></ul><p>下面会针对这三个关键字进一步阐述是如何解决三大性质问题，并对JMM的结构做更深入的解说</p><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>先见下列文字</p><p><code>final</code>关键字的可见性是指：被final修饰的字段在构造方法中一旦被初始化完成，并且构造方法没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值–引用自《<a href="https://weread.qq.com/web/bookDetail/cf1320d071a1a78ecf19254">深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）</a>》12.3.5第二小节</p><blockquote><p>推测java对final关键字解决可见性问题的初衷是: <strong>当一个对象包含final修饰的变量时，其他线程能够看到已经初始化好的final变量</strong></p></blockquote><p>另外解释一下this引用逃逸:<br>某对象在执行完构造方法之前，其他线程就已持有了该对象的引用，调用尚未构造完全的对象方法会引发错误</p><p>比如下列代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">ExceptionUtils</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalThisEscape</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> <span class="token class-name">FinalThisEscape</span> obj<span class="token punctuation">;</span>  <span class="token comment">/** final常量会保证在构造器内完成初始化（但是仅限于未发生this逃逸的情况下，具体见多线程对final保证可见性的实现） */</span>  <span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>  <span class="token comment">/** 错误的构造方法 */</span>  <span class="token keyword">public</span> <span class="token class-name">FinalThisEscape</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment">// this引用逃逸</span>    obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalThisEscape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>              <span class="token class-name">FinalThisEscape</span> finalThisEscape <span class="token operator">=</span> obj<span class="token punctuation">;</span>              <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> finalThisEscape<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NullPointerException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"final变量x未被初始化,&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JMM</tag>
      
      <tag>Java内存模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile</title>
    <link href="/posts/4266433718.html"/>
    <url>/posts/4266433718.html</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>主要是为了解决可见性问题。相对synchronized来说，volatile更加轻量级。可以理解成一个轻量级的锁。它能保证java多线程开发中，共享变量被某个线程修改后，其他线程能读到最新已被修改的值。至于它还解决了有序性问题，是因为它通过内存屏障概念禁止了指令重排序，这些其实说到底都是和硬件语义有关。</p><p>所以在具体了解volatile之前，需要对硬件层面的原理做一下说明，这样才能更好理解volatile的工作原理，即明白为啥volatile能实现可见性和有序性，但不能保证原子性。</p><p>虽然前述<a href="3489062241.html">JMM</a>部分已做了简单介绍，但是还不完整，下面来进行完整说明</p><h1 id="硬件层面原理"><a href="#硬件层面原理" class="headerlink" title="硬件层面原理"></a>硬件层面原理</h1><h2 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h2><p>我们再把之前多级缓存读取那张图重新贴一下</p><p><img src="/img/volatile/E0AE6141-85FA-4BD2-AA4A-B583DB9CF7BF.png" alt="多级缓存读取"></p><p>在多核多cpu情况下，多核是指在一个cpu中集成了两个或多个完整的计算引擎(内核),这样可以支持多任务并行操作。从多线程调度的角度来说，每个线程会映射到各个cpu核中并行操作。cpu有一组CPU寄存器，它是cpu用来直接访问和处理数据的单元，是一个临时放数据的空间。</p><p>一般cpu都会从内存读取数据到寄存器，然后进行操作，但前述已知，内存处理速度远低于cpu，导致cpu处理指令时往往需要很多时间来等待内存做准备工作，于是在寄存器和主内存间添加了cpu缓存，cpu缓存速度快，容量小且昂贵。若cpu总是操作主内存中的同一地址数据，容易影响cpu执行速度，此时cpu缓存就可把从内存中读取的数据暂时保存起来。在cpu寄存器读取内存中同一位置数据时，可直接从缓存中读取，无需直接从主内存读取。</p><p>但是需要注意的是，寄存器并不是每次都可以从缓存中读取数据，万一不是同一个内存地址的数据，那寄存器还是必须绕过cpu缓存从内存中读取。所以并不是每次都从缓存中读取数据，这种现象叫做缓存命中，能从缓存中读取就是命中，不能就是没命中。总结下来，就是当一个cpu访问主内存时，会先读取一部分主内存数据到cpu缓存(如果缓存中存在需要的数据，就直接从缓存中读取)，进而再读取cpu缓存数据到寄存器，当cpu需要写数据到主内存时，同样会先刷新寄存器中的数据到cpu缓存，然后再把数据刷新到主内存中。</p><p>在前述<a href="3489062241.html">JMM</a>部分，已知每个线程都有一个所谓的工作内存。通过前面描述，其实可以明白这个东西其实就是cpu寄存器和高速缓存的一个抽象。简单说可以当做是cpu中的寄存器部分+L1-L3三级cpu高速缓存(仔细看上图，L3是多核cpu共享的，L1-L2是每个cpu核独享的)。而主内存其实就是<code>RAM(random access memory</code>,随机存储器),也就是通常所说的电脑内存。今后要是有面试官问你主内存对应计算机硬件什么部分，你大可以大言不惭的说就是内存条。</p><h2 id="Java线程与硬件映射关系"><a href="#Java线程与硬件映射关系" class="headerlink" title="Java线程与硬件映射关系"></a>Java线程与硬件映射关系</h2><p>在目前已知各大操作系统中，人们其实是基于一对一的线程模型来实现Java线程。一对一线程模型概念，就是<strong>通过编程语言层面的应用程序去间接调用系统内核的线程模型</strong>。</p><p>比如Java，Java虚拟机内部是调用当前操作系统的内核线程来完成当前任务。所谓内核线程(<code>Kernel-Level Thread</code>，<code>KLT</code>)是由操作系统内核(<code>Kernel</code>)支持的线程，它由操作系统内核来完成线程切换，内核通过操作调度器对线程执行调度，并将线程的任务映射到各个cpu上。每个内核线程可视为内核的一个影分身,这也是操作系统可同时处理多任务的原因。</p><p>但是在编程语言层面，应用程序一般不会直接去调用内核线程，取而代之是用一种轻量级的进程(<code>Light Weight Process</code>)，也就是线程，由于每个轻量级进程都会映射到一个内核线程，因此可通过轻量级进程调用内核线程，进而让操作系统内核把一个个任务映射到一个个cpu上，这种轻量级进程与内核线程1对1的关系也就是一对一的线程模型。</p><h2 id="原子指令操作"><a href="#原子指令操作" class="headerlink" title="原子指令操作"></a>原子指令操作</h2><p>因为是一对一线程模型，所以针对多线程并发操作映射于硬件的关系，下面可以具体说一下读写数据时候，在硬件层面到底发生了什么。</p><p>由前述<a href="3489062241.html">JMM</a>，主内存和工作内存之间会同步变量数据。那么，如何让主内存和工作内存互相之间，实现数据同步呢？在JMM中，它定义了8种指令操作来实现。这8种操作每一种都是原子操作</p><p>8种原子指令操作如下:</p><ul><li>lock(锁定)<br>作用于主内存中的共享变量，它把一个共享变量标识为一个线程独占状态</li><li>unlock(解锁)<br>作用于主内存中的共享变量，它把一个处于锁定状态的共享变量释放出来，释放后的共享变量才可被其他线程锁定</li><li>read(读取)<br>作用于主内存的共享变量，它把一个共享变量的值从主内存传到线程的工作内存中，方便之后的load动作使用</li><li>load(载入)<br>作用于工作内存中的共享变量，它把read操作从主内存中得到的共享变量值放入工作内存中的共享变量副本</li><li>use(使用)<br>作用于工作内存中的共享变量，它把工作内存中共享变量值传给执行引擎，虚拟机每次执行一个需要使用到该变量值的字节码指令时，就会执行这个操作</li><li>assign(赋值)<br>作用于工作内存中的共享变量，它把从执行引擎接收到的值赋给工作内存的共享变量副本，虚拟机每次执行一个给变量赋值的字节码指令时,就会执行这个操作</li><li>store(存储)<br>作用于工作内存的共享变量，它把工作内存中共享变量值传给主内存中，方便之后的write操作使用</li><li>write(操作)<br>作用于主内存的共享变量，它把store操作从工作内存中得到的共享变量值放入主内存的共享变量中</li></ul><p>其中lock和unlock操作是用于总线锁机制来解决缓存数据不一致问题。总线锁机制就是当一个cpu核执行一个线程去访问数据做操作时，它会向总线发送一个lock信号，此时其他线程去访问主内存数据，就会被阻塞。这样cpu核可独享这个主内存的共享变量。它操作结束后，会发送unlock信号，让其他线程可以对主内存数据进行访问。可以理解成通过把内存和cpu之间的通信锁住，把并行化操作变成串行操作，但这样，其他线程都会被阻塞住，会导致很严重的性能问题，与多核多线程并行操作提升程序性能的目的相悖。</p><p>所以后来可以通过其他6种指令操作来实现可见性。</p><p>如下图，叙述一下指令操作的整个流程</p><p><img src="/img/volatile/86F235F0-EF8F-4B94-B691-BE7047B13815.png" alt="指令操作流程"></p><p>假设在多线程并发操作情况下，主内存中共享变量data原来值为0。线程1和线程2都要对data进行自增+1操作，且线程1先进行操作。此时整个流程为</p><ol><li>主内存通过read操作，读取到data&#x3D;0</li><li>主内存把值load到线程1的工作内存的共享变量副本data&#x3D;0</li><li>将工作内存中共享变量data值传给执行引擎，线程1的虚拟机需要对data进行自增+1操作，所以会use它</li><li>线程1的虚拟机给data变量值赋值为1，将新值data&#x3D;1传给，即assign给工作内存的共享变量副本</li><li>store操作将值传回主内存</li><li>把data&#x3D;1通过主内存进行write操作，写入到主内存共享变量中<br>7-12线程2对共享变量data操作类似1，不做详述</li></ol><p>此外，JMM规定</p><ul><li>变量从主内存同步到工作内存的过程，需要顺序执行read和load操作</li><li>变量从工作内存同步到主内存的过程，需要顺序执行store和write操作</li></ul><p>但只要求这4个操作必须按顺序执行，并没有规定必须是连续执行</p><p>其实JMM对于这些原子指令操作还有另外一些规则，大致罗列一下:</p><ol><li>不允许某个线程丢弃它最近的assign操作，即共享变量在工作内存中被改变了之后，必须把该变化同步回主内存</li><li>不允许某个线程无原因的（没有发生过任何assign操作）把共享变量值从工作内存同步回主内存</li><li>一个新共享变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(load或assign)的共享变量，也就是对一个共享变量实施use和store操作之前，必须先执行过了load和assign操作</li><li>一个共享变量在同一时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，多次执行lock后，一定要执行相同次数的unlock操作，共享变量才会被解锁</li><li>如果对一个共享变量执行lock操作，将会清空工作内存中此共享变量的值，在执行引擎use这个共享变量前，需要重新执行load或assign操作初始化共享变量值</li><li>如果一个共享变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的共享变量</li><li>对一个共享变量执行unlock操作之前，必须先把此共享变量同步回主内存(执行store和write操作)</li></ol><p>这里有一个问题是线程2操作时，怎么知道data变量值已经为1，而不是重新读0出来再进行自增操作？<br>这就需要说到下面的缓存一致性协议，这也是除了总线锁机制之外，另外一种实现可见性的手段</p><h2 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h2><p>缓存一致性协议最出名的是<code>Intel</code>公司的<code>MESI</code>协议，导致现在一说到缓存一致性协议，都马上会说<code>MESI</code>协议。其实这是不对的，<code>MESI</code>协议只是现在比较标配的一种缓存一致性协议而已(常见的协议还有<code>MSI</code>、<code>MOSI</code>等)。它的功能是保证每个缓存(工作内存)中使用的共享变量副本内容是一致的。</p><p>如今的<code>cpu</code>不再是按字节访问内存，而是以64字节为单位的块(<code>chunk</code>)读取内存。这就是缓存行。它可被简单理解为<code>cpu</code>缓存中的最小缓存单位。而且，共享变量在<code>cpu</code>缓存中的存储就是以缓存行为单位，一个缓存行可以存储多个变量，存满当前缓存行字节数64即可。当<code>cpu</code>读取一个特定的内存地址时，整个缓存行可将变量从主内存换入缓存。</p><p>缓存一致性协议的核心思想:<br><strong>当<code>cpu</code>写数据时，如果发现操作的变量是共享变量，若在其他<code>cpu</code>中也存在该变量的共享变量副本，会发出信号通知其他<code>cpu</code>将该变量的置为无效状态，因此当其他<code>cpu</code>需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那就会直接从内存中重新读取</strong></p><p>前述线程1，线程2例子中，只要线程1执行store和write操作时，发现变量data是共享变量，且线程2的工作内存中也有data变量的共享变量副本，它就会发出信号通知线程2将data变量置为无效，之后继续执行自己的store和write操作直到结束。在线程2需要对data变量执行read和load操作时，发现自己工作内存中的data变量缓存行是无效的，就直接从主内存即内存中重新读取共享变量data的值，这个时候线程1已执行完store和write操作，data变量在主内存中的值已变为1，那么线程2读取到的data变量值就是1，进行后续use操作就会把data变量值从1自增到2，之后线程2的store和write操作执行时，data变量值就是2了，不会重新再是读取到0后的自增值1了。</p><p>但是在细节上，缓存一致性协议还有下面一些内容</p><p>它会在cpu缓存中保存一个标记位，以此来标记四种状态。另外，每个缓存不仅知道自己的读写操作，也会监听其它缓存的读写操作，这就是嗅探(snooping)功能。否则它怎么会知道何时发出信号通知其他cpu把缓存行中的变量设为无效呢？</p><p>四种状态依次为:</p><ol><li>M(被修改的,Modify)<br>处于这一状态的数据，只在本cpu核中有缓存数据，而其他核中没有。同时其状态相对于内存中的值来说，是已被修改的，只是没有更新到内存中</li><li>E(独占的,Exclusive)<br>处于这一状态的数据，只有在本cpu中有缓存，且其数据没有修改，与内存一致</li><li>S(共享的,Share)<br>处于这一状态的数据在多个cpu中都有缓存，且与内存一致</li><li>I(无效的,Invalid)<br>本cpu中的这份缓存已经无效</li></ol><p>cpu的数据读取会遵循下列这些原则（嗅探功能，<code>snopping</code>）</p><ol><li>处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主内存地址的操作。如果监听到，则必须在此操作执行前把其缓存行中的数据写回cpu</li><li>处于S状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求。如果监听到，则必须把其缓存行状态设置为I</li><li>处于E状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主内存地址的操作。如果监听到，则必须把其缓存行状态设置为S</li></ol><p>当cpu需要读数据时，如果其缓存行的状态是I的，则需要从内存中读取，并把自己状态变成S，如果不是I，则可以直接读取缓存中的值，但在此之前，必须要等待其他cpu监听结果，如其他cpu也有该数据的缓存且状态是M，则需要等待其把缓存更新到内存之后，再读取</p><p>当cpu需要写数据时，只有在其缓存行是M或者E的时候才能执行，否则需要发出特殊的RFO指令(Read Or Ownership，这是一种总线事务)，通知其他cpu设置缓存无效(I)，这种情况下性能开销是相对较大的。在写入完成后，修改其缓存状态为M</p><h2 id="缓存一致性协议的不足和改进"><a href="#缓存一致性协议的不足和改进" class="headerlink" title="缓存一致性协议的不足和改进"></a>缓存一致性协议的不足和改进</h2><p>不足:<br>缓存一致性协议也存在一些问题。因为各cpu缓存行状态是通过消息传递来进行。如果某个cpu要对一个共享变量进行写操作，第一步需要发送一个让其他cpu失效缓存行的消息给它们。且要等到它们的确认回执才能继续进行写操作。那么该cpu在这段时间内都会处于阻塞状态</p><p><img src="/img/volatile/8A3C65C3-1CD9-4161-BC8C-5BA0FB8A3816.png" alt="不足"></p><p>所以为了避免因为阻塞带来的性能浪费。这里就引入了Store Buffer机制</p><p>还是以上述cpu例子继续说，它在对共享变量进行写操作时，直接把值写入到store buffer里，然后同时发送缓存行无效消息给其它cpu，接着继续进行其它操作。当收到其他所有cpu发回的确认回执后，再将store buffer里的数据存储至缓存行中。最后再执行store,write操作将缓存行中的共享变量值同步到主内存</p><p>但是这还会存在两个问题</p><ol><li>共享变量值什么时候提交是不确定的，因为需要等待其他cpu给确认回执后，才会进行数据同步。这其实是一个异步操作</li><li>引入了store buffer后，cpu会先尝试从store buffer中读取值，如果store buffer中有数据，则直接从store buffer中读取，否则就会再从缓存行中读取</li></ol><p>看似这不是问题啊，但是请看下面例子</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> data<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> exeToCPU<span class="token punctuation">&#123;</span>  data<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>  isFinish<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> exeToOtherCPUs<span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>isFinish<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">assert</span> data<span class="token operator">==</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>我们用伪代码表示，exeToCPU和exeToOtherCPUs分别是在某个cpu和其它cpu上执行的操作,data和isFinish都是共享变量(比较low的说明，请多担待)</p><p>假如cpu的缓存行中缓存了共享变量isFinish,且状态为E,而data可能是S。此时,cpu执行时，会先把data&#x3D;10 的指令写入到store buffer中。且通知给其他缓存了data的cpu。在等待其他cpu返回确认回执时，cpu会继续执行isFinish&#x3D;true这个指令。而因为当前cpu缓存了isFinish且状态为E，所以可直接修改isFinish&#x3D;true</p><p>这时其它某个cpu发起read操作去读取isFinish值可能为true，但是value值不等于10(因为value&#x3D;10还没写入到主内存啊，即使其它某个cpu已经无效了自己缓存行中的data变量，但是它从主内存读到的data值不一定是10)</p><p>在这种情况下，我们可认为是cpu在乱序执行，也可认为也是一种重排序，而这种重排序会带来可见性问题</p><p>虽然这种情况不常见，但的确会发生，这样我们之前保证可见性的一切手段其实就不能完全满足了，所以我们接着引入了内存屏障这个概念(也就是说它不光是为了解决有序性问题，也为了完全保证可见性而出现的)来解决上述这两个问题</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障(memory barrier):<br>将store buffer中指令写入到主内存，从而使其他访问同一共享变量的线程保证有可见性</p><p>内存屏障指令包括读屏障、写屏障、全屏障</p><ul><li>读屏障(Load Memory Barrier)<br>cpu在读屏障之后的读操作，都在读屏障之后执行。配合写屏障，使得写屏障之前的主内存更新对于读屏障之后的读操作是可见的</li><li>写屏障(Store Memory Barrier)<br>告诉cpu在写屏障之前,所有已存储在store buffer中的数据同步到主内存。简单说，就是使得写屏障之前的指令结果对写屏障之后的读或写是可见的</li><li>全屏障(Full Memory Barrier)<br>确保屏障前的内存读写操作结果提交到主内存之后，再执行屏障后的读写操作</li></ul><p>有了它之后，对于前述例子，data&#x3D;10写入到store buffer之后，有一个写屏障，那么store buffer中的data&#x3D;10会同步到主内存，其他cpu发起读操作，写屏障之后的读写操作都可见它之前的指令结果，也就是都可见data和isFinish这两个变量和其最新值10和true，那么其他cpu都能读到data变量最新值10，也就避免出现了可见性问题</p><p>总结一下，内存屏障作用是通过防止cpu对主内存的乱序访问，来保证共享变量和其值的可见性。</p><p>但内存屏障是如何出现的呢？前述的lock指令，其实就相当于实现了一种内存屏障</p><h2 id="内存屏障的进一步解释"><a href="#内存屏障的进一步解释" class="headerlink" title="内存屏障的进一步解释"></a>内存屏障的进一步解释</h2><p>前述<a href="3489062241.html">JMM</a>已说重排序包括编译器和处理器重排序两种。如下图</p><p><img src="/img/volatile/5B7B6DF9-BA01-4BDD-87C4-060580603C5D.png" alt="重排序"></p><p>2和3属于处理器重排序。这些重排序可能会导致可见性问题，但前述内存屏障已说了一部分如何保证可见性的内容，但还没有更加详细说明。我们分别对即处理器重排序和编译器重排序再做说明</p><h3 id="处理器重排序"><a href="#处理器重排序" class="headerlink" title="处理器重排序"></a>处理器重排序</h3><p>JMM会要求编译器生成指令时，插入内存屏障来禁止处理器重排序(当然并不是所有程序都会出现重排序问题)。由此既实现了可见性，又实现了有序性。我们接着往下说为啥可见性和有序性都实现了。</p><ol><li>屏障分类<br>JMM中把内存屏障分为四类，下列表格说明</li></ol><table><thead><tr><th align="left">屏障类型</th><th align="left">指令示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">LoadLoad</td><td align="left">Load1;LoadLoad;Load2;</td><td align="left">确保Load1数据装载先于Load2以及所有后续Load指令装载</td></tr><tr><td align="left">StoreStore</td><td align="left">Store1;StoreStore;Store2;</td><td align="left">确保Store1数据对其它cpu可见(刷新到主内存)先于Store2以及所有后续store指令存储</td></tr><tr><td align="left">LoadStore</td><td align="left">Load1;LoadStore;Store2;</td><td align="left">确保Load1数据装载先于Store2以及所有后续Store指令刷新到主内存</td></tr><tr><td align="left">StoreLoad</td><td align="left">Store1;StoreLoad;Load2;</td><td align="left">确保Store1数据对其它cpu可见(刷新到主内存)先于Load2以及所有后续store指令存储</td></tr></tbody></table><blockquote><p>StoreLoad使该屏障之前所有主内存访问指令(包括load和store指令)完成之后，才执行该屏障之后的内存访问指令。它的开销是4种屏障中最大的。在大多数cpu实现中，它是个万能屏障，兼具其它三种内存屏障的功能</p></blockquote><ol start="2"><li><p>屏障插入策略<br>对于volatile关键字操作，JMM提供的内存屏障插入策略如下:</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障</li><li>在每个volatile读操作的后面再插入一个LoadStore屏障</li></ul><p> 结合上述内存屏障分类和插入策略，见下图是如何来实现可见性和有序性</p></li></ol><p><img src="/img/volatile/46D74D9D-04D0-452C-B020-B15CB9A31CE8.png" alt="可见性和有序性"></p><blockquote><p>看左边<code>volatile</code>写这一部分，因为后面有<code>StoreLoad</code>屏障，保证共享变量值已同步到主内存，屏障之后的操作都能读取到主内存中共享变量最新值，实现了可见性。<br>右边部分，通过<code>LoadLoad</code>和<code>LoadStore</code>两个屏障，禁止了所有读和写操作和<code>volatile</code>读操作的指令重排序，实现了有序性</p></blockquote><h3 id="编译器的重排序"><a href="#编译器的重排序" class="headerlink" title="编译器的重排序"></a>编译器的重排序</h3><p>编译器重排序和处理器重排序的原则一样，遵守<strong>数据依赖性原则</strong>，这是实现有序性的一个重点</p><p>编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序，如下面代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>b<span class="token operator">=</span>a<span class="token punctuation">;</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>a<span class="token operator">=</span>b<span class="token punctuation">;</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>这3种情况在单线程里,如果改变代码的执行顺序，都会导致结果不一致，所以重排序不会对这类指令做优化。这种规则也称为as-if-serial(假装串行)。不管怎么重排序，对单个线程来说执行结果不能变。</p><p>下面代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//1</span><span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">//2</span><span class="token keyword">int</span> result<span class="token operator">=</span>a<span class="token operator">*</span>b<span class="token punctuation">;</span> <span class="token comment">//3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>1和3、2和3存在数据依赖，所以在最终执行指令中，3不能重排序到1和2之前，否则程序会报错。由于1和2不存在数据依赖，所以可重排序1和2的顺序</p><p>由上两部分可知，内存屏障是如何来禁止编译器和处理器重排序的</p><h1 id="volatile实现可见性"><a href="#volatile实现可见性" class="headerlink" title="volatile实现可见性"></a>volatile实现可见性</h1><p>大部分已在硬件层面原理章节记述。这里做个总结:</p><p>多核多cpu情况下，若某个线程对声明了volatile关键字的变量(共享变量)进行写操作</p><ol><li>JVM会向cpu发送一条带有lock前缀的指令，lock指令通过总线锁机制，确保回写主内存的操作是原子性的，让缓存行数据(共享变量值)写回了主内存。但其它线程因此会被阻塞，它们自己工作内存中存储的共享变量值仍然是老值，所以并不能保证可见性</li><li>由此还需MESI缓存一致性协议，每个cpu缓存通过嗅探功能检查自己的共享变量副本值是否过期，当发现自己缓存行处于S状态(说明自己的缓存行存储的变量是共享变量)，且对应的主内存地址被修改时(有其它cpu缓存对主内存的共享变量发起写请求)，就会设置当前缓存行为无效，需要对共享变量数据进行读写时就会重新从主内存中加载共享变量值</li><li>但这样也没完全保证可见性。还存在cpu等待缓存行无效确认消息时间过长和没有及时读取到主内存中共享变量最新值等问题。由此还需Store Buffer机制和内存屏障。而lock前缀指令就相当于一个内存屏障，这样发生指令重排时，不会把后面的指令重排到内存屏障之前的位置。在内存屏障之前，变量所在的缓存行数据(共享变量值)已写回了主内存</li></ol><p>总而言之，如果面试中除了能说出来MESI缓存一致性协议，再能解释清楚嗅探功能是如何让各cpu缓存进行通信，知道需要在什么时机下，无效自己共享变量所在的缓存行;什么时机下，可以放心大胆读取主内存中的共享变量。然后能更进一步说明Store Buffer和内存屏障，那么基本上就说清楚了volatile是如何实现可见性的了。</p><h1 id="volatile实现有序性"><a href="#volatile实现有序性" class="headerlink" title="volatile实现有序性"></a>volatile实现有序性</h1><p>前述处理器和编译器重排序章节，说明了volatile关键字如何通过内存屏障来实现禁止重排序，但是也说的并不详细。这里再具体说明一下，会提到后续Happens-Before规则中有关volatile的部分(Happens-Before规则后续会详细说)</p><h2 id="volatile通过内存屏障禁止指令重排序最佳示例"><a href="#volatile通过内存屏障禁止指令重排序最佳示例" class="headerlink" title="volatile通过内存屏障禁止指令重排序最佳示例"></a>volatile通过内存屏障禁止指令重排序最佳示例</h2><p>通过前面代码示例，我们知道volatile关键字在通过内存屏障禁止编译器重排序方面是通过as-if-serial(假装串行)原则来实现，这里有个最佳示例就是设计模式中单例模式的双重锁模式，代码如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">AccessLevel</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">NoArgsConstructor</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token punctuation">(</span>access <span class="token operator">=</span> <span class="token class-name">AccessLevel</span><span class="token punctuation">.</span>PRIVATE<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/** volatile关键字保证可见性 同时禁用指令重排（jdk1.5后生效） */</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>  <span class="token comment">/**   * 双重检查锁实现单例模式 推荐这样写，既保证线程安全，又延迟加载   *   * @return singleton instance   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p> 为啥要使用volatile关键字修饰singleton？</p><p>主要因为<code>singleton = new Singleton();</code>这句，这不是一个原子操作，事实上在JVM中这句话做了下面3步</p><ol><li>给singleton分配内存</li><li>调用Singleton的构造方法来初始化成员变量</li><li>将singleton对象指向分配的内存空间(执行完这步singleton就不是null了)</li></ol><p>但由于指令重排，上述2和3的顺序是不能保证的，最终的执行顺序可能是123也可能是132<br>若是后者，则在3结束后，2未执行之前，另一个线程执行<code>if (singleton == null)</code>，此时singleton已经不是null，但却没有初始化，所以该线程会直接返回singleton，然后使用，自然就会报错</p><p>但是根据前述内存屏障用来禁止编译器指令重排序的<strong>数据依赖性原则</strong>，存在数据依赖关系的两个操作的执行顺序不会变，那么2和3顺序在singleton被volatile关键字修饰之后，他们顺序保证是先2后3，就不会出现132这样顺序</p><h2 id="Happens-Before规则中volatile规则"><a href="#Happens-Before规则中volatile规则" class="headerlink" title="Happens-Before规则中volatile规则"></a>Happens-Before规则中volatile规则</h2><p>volatile关键字禁止指令重排序其实有两层意思</p><ol><li>当程序执行到volatile变量的读或写操作时，在其前面的操作，若涉及变量的更改肯定已全部经进行完成了，且结果已对后面的操作可见，在其后面的操作肯定都还没有开始进行</li><li>在进行指令优化时，不能将对volatile变量进行访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行(内存屏障发挥作用)</li></ol><p>这解释下来就是Happens-Before规则中volatile规则</p><p>volatile变量规则:<br>对一个volatile变量的写操作先行于之后对这个变量的读操作，这个”之后”指的是时间上的先后顺序</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>volatile关键字通过内存屏障实现了禁止指令重排序功能。内存屏障保证了特定操作的执行顺序(实现有序性)，也保证了共享变量的可见性(实现可见性)</p><p>且因为处理器和编译器都能进行指令重排序，如果在指令之间插入一条内存屏障，会告诉编译器和处理器不管在任何情况下，不管啥指令都不能和这条内存屏障进行指令重排序，也就是说，通过插入内存屏障禁止内存屏障前后的指令进行重排序。它的另外一个作用就是强制刷出各个cpu缓存的数据到主内存，让其他任何cpu上的线程(1对1线程模型)都能读取到这些数据的最新值(可见性)</p><h1 id="volatile为何不保证原子性"><a href="#volatile为何不保证原子性" class="headerlink" title="volatile为何不保证原子性"></a>volatile为何不保证原子性</h1><p>我参阅了一些网上资料说volatile在某些情况下可以保证原子性，其实这是有条件限制的。平时之所以说volatile不能保证原子性，主要是针对i++这种复合操作，这种操作即使有volatile关键字修饰也不能保证原子性，可能会引发数据不一致问题</p><p>为了讲的更加透彻点，我们用两个例子来说明</p><h2 id="i-情况"><a href="#i-情况" class="headerlink" title="i++情况"></a>i++情况</h2><p>用之前所用的<code>int data=0;data=10</code>的例子来说明(见缓存一致性协议的不足和改进章节)</p><p>如果这里是</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">int</span> data<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>data<span class="token operator">++</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>假设线程a和线程b两个线程同时从主内存中读取data值，那此时两个线程保存的data值都是0，此时线程a对data进行了自增计算，然后线程b也对data进行了自增计算。按照前述强刷主内存data值，其他线程data值在其工作内存先失效，再从主内存读取data最新值的原理，线程a中data值变为1，线程b根据可见性读取到data&#x3D;1后，再自增，结果应该是data&#x3D;2。但是运行结果居然还是1！</p><p>实际上，此时针对data变量，实际是做了下面三步原子操作</p><ol><li>线程读取data</li><li>temp&#x3D;data+1</li><li>data&#x3D;temp</li></ol><p>当data&#x3D;0的时，两个线程同时读入data值，然后线程a执行了temp&#x3D;data+1操作，注意此时的data值还没有变化，然后线程b也执行了temp&#x3D;data+1操作，这时两个线程保存的data值都是0，temp值都是1，然后线程a执行data&#x3D;temp(1)操作，此时data值会立即刷新到主内存并通知其他线程保存的data值失效，此时线程b需要重新读取data值。那么此时线程b保存的data值就是1，同时它保存的temp还是1，然后线程b执行data&#x3D;temp(1)，所以导致计算结果比预期少了1，它还以为data值是1，执行data++操作，预期结果应该是2，谁知道居然还是1</p><p>上述例子就表明了volatile保证不了原子性。但是要想能保证，从上面例子可知只要符合下述两条规则就可以了</p><ol><li>运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量值<br>线程b犯得“错误”就是它运算结果依赖于变量data当前值1，要么就是只让线程a改变data值，线程b它不插手data值修改</li><li>变量不需要与其他的状态变量共同参与不变约束<br>data变量不要和temp变量搅合在一起。temp变量被赋值为1，其值在两个线程里都不变，但data要执行自增操作，不需要和temp变量一起接受不变约束。所以这个时候不能让temp值赋给data</li></ol><blockquote><p>如果不符合上述两条规则，要通过加锁(使用synchronized、java.util.concurrent中的锁或原子类)来保证原子性</p></blockquote><h2 id="i-x3D-1情况"><a href="#i-x3D-1情况" class="headerlink" title="i&#x3D;1情况"></a>i&#x3D;1情况</h2><p>这种情况下，JMM有个很奇怪的规定: 针对64位的数据类型，(就是long和double啦),允许虚拟机将没有被volatile修饰的64位数据读写操作划分为两次32位的操作来进行，即允许虚拟机自行选择是否要保证64位数据类型的load、store、read和write这四个操作的原子性</p><p>这也被称为long和double的非原子性协定(Non-Atomic Treatment of double and long Variables)</p><p>所以会出现一个现象，即多个线程共享一个未声明为volatile关键字的long或double类型变量，且同时对其进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的数值(有时被称为“半个变量”)。</p><p>这种现象经过测试，在64位Java虚拟机下不会出现，但是在32位Java虚拟机下有时会出现，特别是long类型的变量出现概率最高。所以从java9开始，Java虚拟机增加了一个实验性的参数<code>-XX: +AlwaysAtomicAccesses</code>(这是JEP 188对JMM更新的一部分内容)来约束虚拟机对所有数据类型进行原子性访问。而double类型，如今cpu一般都包含专门用于处理浮点数据的浮点运算器(Floating Point Unit，FPU)，用来专门处理单、双精度的浮点数据，所以针对double类型，这种现象哪怕在32位虚拟机下也几乎不会出现</p><p>但是如果平时开发用的版本还是java8时候，可以用volatile来修饰long和double类型变量来杜绝上述现象。此时，volatile起的作用就是保证原子性。原因在于: volatile本身不保证获取和设置操作的原子性，仅保持修改的可见性。但是JMM保证声明为volatile的long和double类型变量的get、set操作是原子性的(见<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.7">Java语言规范文档(jls-17)</a>中”<code>Writes and reads of volatile long and double values are always atomic</code>“这句)</p><p>从上可知，在实际开发中，需要volatile关键字来保证原子性的情况并不多见。<br>至少我总结下来，要同时满足下列几个条件:</p><ol><li>Java虚拟机是32位</li><li>java版本是低于java9的</li><li>变量类型为long或double类型，且大概率是long类型变量时候</li></ol><p>因此我同意《<a href="https://weread.qq.com/web/bookDetail/cf1320d071a1a78ecf19254">深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）</a>》一书作者在书中12.3.4小节所说那段话</p><blockquote><p>笔者的看法是，在实际开发中，除非该数据有明确可知的线程竞争，否则我们在编写代码时一般不需要因为这个原因刻意把用到的long和double变量专门声明为volatile</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://gitee.com/darkranger/beating-interviewer/tree/master/src/main/java/com/wujunshen/thread/jmm">本文所有示例源码地址</a></p></li><li><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.7">Java语言规范文档(jls-17)</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>volatile</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo</title>
    <link href="/posts/4129633176.html"/>
    <url>/posts/4129633176.html</url>
    
    <content type="html"><![CDATA[<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h2 id="10层模型"><a href="#10层模型" class="headerlink" title="10层模型"></a>10层模型</h2><ol><li>service接口层: 给服务提供者和消费者实现</li><li>config配置层: 对 dubbo 进行各种配置</li><li>proxy服务代理层: 无论是服务提供者还是消费者，dubbo 都会生成代理，代理之间进行网络通信</li><li>registry服务注册层: 负责服务注册与发现</li><li>cluster集群层: 封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务</li><li>monitor监控层: 对 rpc 接口的调用次数和调用时间进行监控</li><li>protocal远程调用层: 封装 rpc 调用</li><li>exchange信息交换层: 封装请求响应模式，同步转异步</li><li>transport网络传输层: 抽象 mina 和 netty 为统一接口</li><li>serialize数据序列化层: 可复用的一些序列化和反序列化工具，支持5种方式（fastjson、Hessian2、Kryo、fst 及 Java原生支持）。也可扩展自定义的序列化和反序列化工具</li></ol><p><img src="/img/dubbo/2A4D159B-9474-499A-9552-D22CADEBD9D0.png" alt="10层模型"></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><p>provider向注册中心去注册</p></li><li><p>consumer从注册中心订阅服务</p></li><li><p>注册中心会通知consumer注册好的服务</p></li><li><p>consumer调用provider</p></li><li><p>consumer和provider每隔一段时间，都把各自的统计数据异步通知给监控中心</p><p><img src="/img/dubbo/4EC104FF-0A47-44D7-9000-5945490C3FEE.png" alt="流程"></p></li></ol><blockquote><p>注册中心挂了可以继续通信吗？<br>可以，因为初始化时候，消费者会将提供者的地址等元数据信息拉取到本地缓存，所以注册中心挂了还可以继续通信</p></blockquote><p>dubbo10层每个层都有可以考核的面试知识点，以下按照我个人分析一一罗列出来</p><h2 id="dubbo负载均衡策略"><a href="#dubbo负载均衡策略" class="headerlink" title="dubbo负载均衡策略"></a>dubbo负载均衡策略</h2><ul><li><p>random loadbalance<br><code>dubbo</code>默认负载均衡策略是<code>random loadbalance</code>，即随机调用实现负载均衡，可对<code>provider</code>不同实例设置不同的权重，会按照权重来负载均衡，权重越大分配流量越高，一般默认这个就行</p></li><li><p>round robin loadbalance<br>这个负载均衡策略默认均匀地将流量打到各个服务器节点上，但如果各个服务器性能不一样，容易导致性能差的服务器负载过高。所以需要调整权重，让性能差的服务器承载权重小一些，流量少一些</p></li><li><p>least active loadbalance<br>自动感知，服务器性能越差，那么接收的请求越少，越不活跃，此时就会给不活跃，性能差的服务器更少的请求</p></li><li><p>consistant hash loadbalance<br>一致性<code>Hash</code>算法,相同参数的请求一定分发到同一个<code>provider</code>上,<code>provider</code>挂掉时,会基于虚拟节点均匀分配剩余的流量，抖动不会太大。如果需要的不是随机负载均衡，而是要同一类请求都到一个节点，那就使用这个一致性<code>Hash</code>策略</p></li></ul><h2 id="dubbo集群容错策略"><a href="#dubbo集群容错策略" class="headerlink" title="dubbo集群容错策略"></a>dubbo集群容错策略</h2><ul><li>failover cluster模式<br><code>dubbo</code>默认集群容错策略，请求失败就自动切换，自动重试其他服务器，常见于读操作。（失败重试其它机器）<br>可通过以下几种方式配置重试次数</li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>findFoo<span class="token punctuation">"</span></span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">dubbo:</span>reference</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><ul><li>failfast cluster模式<br>一次调用失败就立即失败，常见于非幂等性的写操作，比如新增一条记录（调用失败就立即失败）</li><li>failsafe cluster模式<br>出现异常时忽略掉，常用于不重要的接口调用，比如记录日志<br>配置示例如下</li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">cluster</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>failsafe<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">cluster</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>failsafe<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><ul><li>failback cluster模式<br>失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种</li><li>forking cluster模式<br>并行调用多个<code>provider</code>，只要一个成功就立即返回。常用于实时性要求比较高的读操作，但会浪费更多的服务资源，可通过<code>forks=&quot;2&quot;</code>来设置最大并行数</li><li>broadcacst cluster<br>逐个调用所有的<code>provider</code>。任何一个<code>provider</code>出错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息</li></ul><h2 id="dubbo动态代理策略"><a href="#dubbo动态代理策略" class="headerlink" title="dubbo动态代理策略"></a>dubbo动态代理策略</h2><p>默认使用<code>javassist</code>动态字节码生成，创建代理类。但可通过<code>spi</code>扩展机制配置自己的动态代理策略</p><h2 id="SPI（Service-Provider-Interface）"><a href="#SPI（Service-Provider-Interface）" class="headerlink" title="SPI（Service Provider Interface）"></a>SPI（Service Provider Interface）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>根据<strong>指定的配置</strong>或者<strong>默认的配置</strong>，找到对应的实现类并加载进系统，之后就可以用这个实现类的实例对象</p><p>举例:<br>有一个接口A。A1&#x2F;A2&#x2F;A3分别是接口A的不同实现。通过配置接口A&#x3D;实现A2，那在系统实际运行时，会加载配置，用实现A2实例化一个对象来提供服务</p><p>spi使用场景？<strong>插件扩展</strong>场景，比如开发了一个给别人使用的开源框架，如果想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候spi就有用武之地</p><h3 id="Java中SPI使用"><a href="#Java中SPI使用" class="headerlink" title="Java中SPI使用"></a>Java中SPI使用</h3><ul><li>jdbc<br>java定义了一套jdbc接口，但Java并没提供jdbc的实现类<br>但实际项目运行时，要使用jdbc接口的哪些实现类呢？一般来说，我们要根据自己使用的数据库，比如<code>mysql</code>，将<code>mysql-jdbc-connector.jar</code>引入进来；<code>oracle</code>，就将<code>oracle-jdbc-connector.jar</code>引入进来<br>在系统运行时，碰到使用jdbc的接口，spi会在底层使用引入的那个jar中提供的实现类</li></ul><h3 id="Dubbo中SPI使用"><a href="#Dubbo中SPI使用" class="headerlink" title="Dubbo中SPI使用"></a>Dubbo中SPI使用</h3><p>dubbo也用了spi，不过没有用java的spi机制，而是自己实现了一套spi机制</p><p>举例</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Protocol</span> protocol <span class="token operator">=</span> <span class="token class-name">ExtensionLoader</span><span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span><span class="token class-name">Protocol</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAdaptiveExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>对于这个<code>Protocol</code>接口，<code>dubbo</code>在系统运行时会判断一下应该选用这个<code>Protocol</code>接口的哪个实现类来实例化对象。需要配置文件配置一个<code>Protocol</code>实现类，加载到<code>jvm</code>，然后实例化对象，用这个<code>Protocol</code>实现类就行</p><p>在<code>dubbo</code>里<code>SPI</code>被大量使用，对很多组件都会保留一个接口和多个实现，然后在系统运行时，动态根据配置去找到对应的实现类。如果没配置，就走默认实现</p><p>在dubbo源码中，在<code>/META_INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol</code>下对<code>Protocol</code>接口做了配置</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">dubbo</span><span class="token punctuation">=</span><span class="token value attr-value">com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>如上，将<code>dubbo</code>作为默认key去配置文件里找，配置文件名称与接口全限定名一样，通过<code>dubbo</code>作为key找到默认的实现类<code>com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</code></p><h4 id="自定义扩展dubbo组件的方法"><a href="#自定义扩展dubbo组件的方法" class="headerlink" title="自定义扩展dubbo组件的方法"></a>自定义扩展dubbo组件的方法</h4><p><img src="/img/dubbo/F4598D6B-0547-4618-9C5B-7536AB955CA4.png" alt="自定义扩展dubbo组件方法"></p><ol><li><p>把自定义扩展的组件写完代码，打成<code>jar</code>包，在里面的<code>src/main/resources</code>目录下，新建<code>META-INF/services</code>目录，增加文件: <code>com.alibaba.dubbo.rpc.Protocol</code>，文件内容为<code>my=com.bingo.MyProtocol</code>。然后把<code>jar</code>安装到<code>nexus</code>私服</p></li><li><p>新建<code>dubbo provider</code>工程，在工程里面依赖自定义的组件包<code>jar</code>，然后在<code>spring</code>配置文件里配置</p> <div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>protocol</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”my”</span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”20000”</span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p><code>provider</code>启动时，就会加载<code>jar</code>包里的<code>my=com.bingo.MyProtocol</code>这行配置，接着会根据配置使用自定义好的<code>MyProtocol</code></p></li></ol><p>通过上述方式，就可替换掉大量的<code>dubbo</code>内部的组件</p><h2 id="dubbo服务治理"><a href="#dubbo服务治理" class="headerlink" title="dubbo服务治理"></a>dubbo服务治理</h2><h3 id="服务链式追踪监控"><a href="#服务链式追踪监控" class="headerlink" title="服务链式追踪监控"></a>服务链式追踪监控</h3><p>基于<code>dubbo</code>做的分布式系统，自动记录各个服务之间的互相调用情况，然后自动将服务之间的依赖关系和调用链路生成出来。老实说，这一点<code>dubbo</code>原生做的不好，建议使用<code>skywalking</code>这种apm类型来监控</p><h3 id="服务访问压力以及时长统计"><a href="#服务访问压力以及时长统计" class="headerlink" title="服务访问压力以及时长统计"></a>服务访问压力以及时长统计</h3><p>自动统计各个接口和服务之间的<strong>调用次数</strong>以及<strong>访问延时</strong></p><p>两个级别</p><ul><li>接口粒度<br>每个服务的每个接口每天被调用多少次，<code>TP50/TP90/TP99</code>，三个档次的请求延时分别是多少</li><li>从调用源头开始<br>一个完整的请求链路经过几十个服务之后，完成一次请求，每天全链路走多少次，全链路请求延时的<code>TP50/TP90/TP99</code>，分别是多少</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>服务分层（避免循环依赖）</li><li>调用链路失败监控和报警</li><li>服务鉴权</li><li>每个服务的可用性的监控（接口调用成功率？几个9？<code>SLA</code>，这个在<code>SkyWalking</code>中已经可以实现）</li></ul><h2 id="dubbo服务降级"><a href="#dubbo服务降级" class="headerlink" title="dubbo服务降级"></a>dubbo服务降级</h2><p>配置文件举例</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fooService<span class="token punctuation">"</span></span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.service.FooService<span class="token punctuation">"</span></span>  <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10000<span class="token punctuation">"</span></span> <span class="token attr-name">check</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">mock</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>return null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>调用接口失败时，可通过mock统一返回null<br>mock值也可修改为true，然后再接口同一个路径下实现一个Mock类，命名规则是“接口名称+Mock”后缀。在Mock类里实现自己的降级逻辑<br>代码示例</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServiceMock</span> <span class="token keyword">implements</span> <span class="token class-name">HelloService</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 降级逻辑</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="dubbo失败重试和超时重试"><a href="#dubbo失败重试和超时重试" class="headerlink" title="dubbo失败重试和超时重试"></a>dubbo失败重试和超时重试</h2><p>在配置文件中配置</p><ul><li>timeout<br>一般设置为200ms，个人认为不能超过200ms还没返回</li><li>retries<br>设置retries，一般在读请求时，比如要查询数据，设置个retries，如果第一次没读到，报错，重试指定的次数，尝试再次读取<br>举例如下 <div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxxx<span class="token punctuation">"</span></span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xx<span class="token punctuation">"</span></span> <span class="token attr-name">check</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">async</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span> <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2000<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div>配置<code>timeout=“2000”</code>，意思就是等待2s后，要是还没返回，就撤了，不干等结果。</li></ul><h2 id="dubbo通信协议"><a href="#dubbo通信协议" class="headerlink" title="dubbo通信协议"></a>dubbo通信协议</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>序列化<br>把数据结构或对象转换为二进制串的过程</li><li>反序列化<br>在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</li></ul><p><img src="/img/dubbo/477EE8CB-C8B6-4349-80E2-A7F4B594506A.png" alt="反序列化"></p><h3 id="dubbo支持不同的通信协议"><a href="#dubbo支持不同的通信协议" class="headerlink" title="dubbo支持不同的通信协议"></a>dubbo支持不同的通信协议</h3><ul><li><p>dubbo协议<br>默认协议，单一长连接，进行的是NIO异步通信，基于hessian作为序列化协议。使用的场景：传输数据量小（每次请求在100kb以内），但并发量高的场景。<br>为了支持高并发场景，一般做法就是服务提供者只有几个服务器节点，但是服务消费者有上百个服务器节点，可能每天调用量就达到上亿次！此时用长连接是最合适的，只要跟每个服务消费者维持一个长连接就行，总共就100个左右连接。然后后面基于长连接NIO异步通信，支撑高并发请求长连接，简单说就是建立连接后可以持续发送请求，无须再建立连接<br><img src="/img/dubbo/C5B04C1C-0A39-48DE-9FAD-BB718A5CBF4C.png" alt="长连接"><br>短连接就是每次要发送请求之前，需要先重新建立一次连接<br><img src="/img/dubbo/9EFF8818-80CA-4B4D-83FF-B0B8C2262074.png" alt="短连接"></p></li><li><p>rmi 协议<br>Java 二进制序列化，多个短连接，适合消费者和提供者数量差不多的情况，适用于文件的传输，一般较少用</p></li><li><p>hessian 协议<br>hessian 序列化协议，多个短连接，适用于提供者数量比消费者数量还多的情况，适用于文件的传输，一般较少用</p></li><li><p>http 协议<br>json 序列化</p></li><li><p>webservice<br>SOAP 文本序列化</p></li></ul><h2 id="dubbo序列化协议"><a href="#dubbo序列化协议" class="headerlink" title="dubbo序列化协议"></a>dubbo序列化协议</h2><p><code>dubbo</code>支持<code>hession</code>、<code>Java</code>二进制序列化、<code>json</code>、<code>SOAP</code>文本序列化多种序列化协议</p><p><code>hessian</code>是其默认的序列化协议</p><p>现在还会有个<code>Protocol Buffer</code>数据存储格式，是Google出品的一种轻量且高效的结构化数据存储格式，性能比<code>JSON</code>、<code>XML</code>要高很多</p><p>性能高的原因有两个</p><ol><li>使用<code>proto</code>编译器，自动进行序列化和反序列化，速度非常快，应该比<code>XML</code>和<code>JSON</code>快上20~100倍</li><li>数据压缩效果好，它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://gitee.com/shishan100/Java-Interview-Advanced">中华石杉–互联网Java进阶面试训练营</a></li></ol><h1 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a><a href="/Dubbo">推荐书单</a></h1>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper</title>
    <link href="/posts/987247817.html"/>
    <url>/posts/987247817.html</url>
    
    <content type="html"><![CDATA[<p>主要用途</p><ul><li>分布式集群的集中式元数据存储（Dubbo，Kafka，Hbase）</li><li>Master选举实现HA（高可用）架构（HDFS）</li><li>分布式协调和通知（Kafka）</li><li>分布式锁（java编写的分布式业务系统）</li></ul><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><ul><li>数据模型节点: znode，可认为是一个节点，纯内存保存。和文件系统类似，有层级关系的树形文件结构</li><li>数据一致性: 任何一个zk节点收到写请求之后都会同步给其他机器，保证数据的强一致，连到任何一个zk节点看到的数据都是一致的</li><li>按顺序写: 只有一个zk节点可以写，所有节点都可读，所有写请求会分配一个集群全局唯一的递增编号，叫zxid，保证各客户端发起的写请求都是有序的</li><li>高可用: 只要不挂掉超过一半的节点，都能保证可用，数据不丢失</li><li>高性能: 每一个zk节点都在内存维护数据，所以集群绝对是高并发高性能的</li><li>高并发: 基于纯内存数据结构处理，并发能力高</li><li>集群化部署: 每个zk节点都在内存保存了zk的全部数据，各节点之间互相通信同步数据，客户端连接任何一节点都可访问数据</li></ul><p>如图</p><p><img src="/img/zookeeper/CCDA654CFB8190E20CAE89EEBB340AE9.jpg" alt="架构"></p><p>下面根据上述几点依次说明</p><h2 id="数据模型节点"><a href="#数据模型节点" class="headerlink" title="数据模型节点"></a>数据模型节点</h2><p>zk节点有4种类型:</p><ol><li><p>PERSISTENT 持久化节点<br>节点创建后就一直存在的节点，除非有删除操作来主动删除这个节点。持久化节点的生命周期是永久有效的，不会因为创建该节点的客户端session失效而消失。（session概念见下文）</p></li><li><p>PERSISTENT_SEQUENTIAL 持久化顺序节点<br>这类节点的生命周期和持久化节点一致。额外特性是，在zk中，每个父节点会对它的第一级子节点维护一份顺序编码，记录每个子节点创建的先后顺序。如果创建子节点时，可以设置这个属性，那么在创建过程中，zk会自动为给定节点名加上一个表示顺序的数字后缀来作为新的节点名。这个后缀数字的值上限是整型的最大值。<br>如，创建节点时只需要传入节点“&#x2F;test_”, zk自动会在”test_”后面补充数字顺序</p></li><li><p>EPHEMERAL 临时节点<br>和持久化节点不同，临时节点的生命周期和客户端session绑定。也就是说，如果客户端session失效，这个节点就会被自动删除。注意，session失效不是连接断开。还要注意一件事，就是session失效后，所产生的节点也不是一下子就消失，也要过一段时间，大概是10秒以内。另外，临时节点下面不能创建子节点</p></li><li><p>EPHEMERAL_SEQUENTIAL 临时顺序节点<br>此节点属于临时节点，不过带有顺序编号，客户端session结束，所产生的节点就会消失</p></li></ol><p>节点分三种角色</p><ol><li>Leader 集群启动自动选举一个Leader出来，只有Leader是可写的</li><li>Follower 只能同步数据和提供数据的读取，Leader挂了，Follower可以继续选举新Leader</li><li>Observer 也是只读节点，但Observer不参与选举</li></ol><p>客户端跟zk建立连接是TCP长连接，建立了一个session，可通过心跳感知到session是否存在</p><p>sessionTimeout: 会话超时时间<br>如果客户端和ZK集群连接断开，只要客户端在指定sessionTimeout超时时间内重新连上一个zk节点，就能继续保持session，否则session就超时</p><h3 id="核心机制：Watcher监听回调"><a href="#核心机制：Watcher监听回调" class="headerlink" title="核心机制：Watcher监听回调"></a>核心机制：Watcher监听回调</h3><p>客户端可对znode进行Watcher监听，znode状态改变时回调通知客户端。</p><p>用于协调分布式系统:系统A监听一个数据变化，如果系统B更新了那个数据节点，zk反向通知系统A这个数据节点发生了变化</p><h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><p>通过ZAB协议（ZooKeeper Atomic Broadcast，ZooKeeper原子广播协议）来做数据同步，保证数据一致性。</p><p>协议本身按照之前所述节点类型，是leader和follower主从架构。只有leader可以进行写操作。读操作是leader和follower都可以。</p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>写过程采用2PC事务，过半follower提交机制</p><p>如图</p><p><img src="/img/zookeeper/130DDDCEEE94CD1F325B6C0440F0CAA0.jpg" alt="ZAB"></p><p>整个过程是leader先收到写事务请求，转换成事务proposal（提议）同步给所有follower，每个follower如图左部红框，将proposal写入自己的磁盘日志文件中。然后发送个ack给leader，通知leader自己已收到proposal。</p><p>如果超过半数的follower向leader发起ack，反馈说已收到proposal，leader就再给所有follower发送一个commit信息，让所有follower正式提交写事务，将数据写入到各自的内存存储znode里。</p><p>如果leader挂机了，要重新选举leader，故障leader就算恢复了，也要变成follower。</p><h3 id="ZAB协议流程"><a href="#ZAB协议流程" class="headerlink" title="ZAB协议流程"></a>ZAB协议流程</h3><ol><li><p>集群启动<br>启动时，进入恢复模式，选举一个leader出来，然后leader等待集群中过半的follower跟它进行数据同步，只要过半follower完成数据同步，就退出恢复模式，开始对外提供服务了<br><strong>只要超过一半的节点，认可某节点是leader，就可以被选举为leader节点</strong></p></li><li><p>消息写入<br>进入消息广播模式，只有leader可以接受写请求，但客户端可随便连接leader或者follower，如果客户端连接到follower，follower会把写请求转发给leader<br>leader收到写请求，就把请求同步给所有的follower，过半follower发起ack说收到了，就再发commit给所有的follower，让大家提交写请求事务（见前述核心思想）</p></li><li><p>崩溃恢复<br>如果leader突然挂机，进入恢复模式，重新选举出一个leader节点，只要过半节点承认是leader，就可以选举出一个leader，所以zk很重要的一点是只要挂机的节点数小于整体节点数的一半，就可正常工作</p></li></ol><h4 id="zk数据一致性到底是强一致性还是最终一致性？"><a href="#zk数据一致性到底是强一致性还是最终一致性？" class="headerlink" title="zk数据一致性到底是强一致性还是最终一致性？"></a>zk数据一致性到底是强一致性还是最终一致性？</h4><p>首先搞清楚强一致性和最终一致性的概念</p><ul><li>强一致性<br>只要写入一条数据，立马无论从zk哪个节点上都可以读到这条数据，这就是强一致性。很明显，ZAB协议机制一看就不是强一致性。因为需要leader和全部follower节点都commit了之后，才能让数据写入操作返回，认为写入成功</li><li>最终一致性<br>写入一条数据，返回告知写入成功了，此时有可能马上去其他zk节点上查数据查不到，在短暂时间内是不一致的，但是过一会儿，最终这条数据一定是可以被查到的</li></ul><p>根据前述ZAB协议写入数据流程，过半follower对事务proposal发送ack给leader，leader再发送commit给所有follower，只有follower或者leader进行了commit，这个数据才会被客户端读取到。</p><p>那会有一种可能，就是有的follower已经commit了，但是有的follower还没有commit，这会导致某个客户端连接到follower01，可以读取到刚commit的数据，但连接到follower02，可能还没法读取到</p><p>所以zk不是强一致的，不是说leader节点必须保证一条数据被全部follower节点都commit了，才会读取到数据，而是过程中可能会在不同的follower上读取到不一致的数据，但最终一定会全部commit后达成数据一致</p><p>zk官方给自己的定义: <strong>顺序一致性</strong><br>也就是说zk是最终一致性的，但其实比最终一致性更好一点，因为leader节点一定会保证所有的proposal同步到follower上都是按照顺序来写入，起码顺序不会乱(见下文)。但是全部follower的数据一致确实是最终才能实现一致的</p><blockquote><p>如果非要求强一致性，可以手动调用zk的sync()操作</p></blockquote><h2 id="按顺序写"><a href="#按顺序写" class="headerlink" title="按顺序写"></a>按顺序写</h2><p>按照前述内容，leader节点发起事务Proposal的广播的事务提议，仅仅只是个提议而已，过半follower都ack，leader节点就直接发起commit消息到全部follower节点上，让大家提交；</p><p>这里leader节点发起事务proposal之前，会分配一个全局唯一递增的事务id叫zxid，通过这个zxid来严格保证写顺序，它会为每个follower节点创建一个队列，里面放入要发送给follower的事务proposal，这样来保证了数据同步的顺序性</p><p>每个follower节点收到事务proposal之后，需要立即写入本地磁盘日志中，写入成功之后就可保证数据不会丢失，然后发送一个ack给leader，过半follower都发送了ack，leader就推送commit消息给全部follower，<br>leader节点它自己也会进行commit操作</p><p>commit之后，就意味这个数据可以被读取到了。</p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>有两种数据不一致情况，zk会展现高可用特性，如下:</p><ol><li>leader收到了过半的follower的ack，接着leader自己commit了，还没来得及发送commit给所有follower自己就挂了，此时leader数据跟所有follower数据是不一致的，必须要保证全部follower最终都要commit<br>解决方案:<br>在老leader节点崩溃时，选举一个zxid最大的节点作为新leader节点，它来检查事务日志，如果发现自己磁盘日志里有一个proposal，但是还没提交，说明肯定是之前挂掉的leader没来得及发送commit就崩溃了。<br>此时新leader节点就得作为leader身份把这个proposal发送commit到其他所有的follower上，这就保证了之前老leader提交的事务最终会同步提交到所有follower那边</li><li>leader自己收到一个请求，结果没来得及发送proposal给所有follower，在这之前就挂了，此时这个leader上的请求应该是要被丢弃掉的<br>解决方案:<br>老leader节点自己磁盘日志里有一个事务proposal，它恢复启动后，作为follow节点和新leader进行同步，发现这个事务proposal其实是不应该存在的，就直接丢弃掉就可以了</li></ol><h3 id="情况1中，为啥老leader挂了，要选zxid最大的节点做新leader？"><a href="#情况1中，为啥老leader挂了，要选zxid最大的节点做新leader？" class="headerlink" title="情况1中，为啥老leader挂了，要选zxid最大的节点做新leader？"></a>情况1中，为啥老leader挂了，要选zxid最大的节点做新leader？</h3><p>举例:<br>假设zk集群是5个节点，1个leader + 4个follower</p><p>1个leader把proposal发送给4个follower，其中3个folower（过半）都收到了proposal发送ack给leader，第4个follower没收到proposal</p><p>此时leader执行commit之后挂了，commit没发送给其他的follower，剩余的4个follower，只要3个节点投票一个节点当leader，就是leader</p><p>假设那3个收到proposal的follower都投票第4个没收到proposal的follower当leader。那么这条数据一定永久性丢失了，因为新leader节点自身没有那个proposal，按照前述怎么会把proposal发送给其他所有follower？</p><p>所以只有选择一个拥有最大zxid的节点作为新leader，其他follower就会跟它进行同步，它给每个follower准备一个队列，然后把所有的proposal都发送给follower，只要过半follower都ack了，就会发送commit给那个follower</p><p>所谓的commit操作，就是把这条数据加入内存中的znode树形数据结构里去，然后对外就可以被看到了，也会去通知一些监听这个znode的客户端（还记得Watcher机制么？）</p><p>如果一个follower跟leader完全同步了，就会加入leader的同步follower列表中去，然后过半follower都同步完毕了，就可以对外继续提供服务了</p><h3 id="情况2中，如何发现并丢弃多余的proposal的？"><a href="#情况2中，如何发现并丢弃多余的proposal的？" class="headerlink" title="情况2中，如何发现并丢弃多余的proposal的？"></a>情况2中，如何发现并丢弃多余的proposal的？</h3><p>每一条事务的zxid是64位的，高32位是leader的epoch，可当做是leader的版本（其实不是）;低32位才是自增的zxid</p><p>假设老leader发送出去的proposal，高32位是1，低32位是11358</p><p>情况2中，新leader选举出来时，它的epoch会自增长一位。那么它的proposal，高32位是2，低32位是继续自增的zxid</p><p>然后老leader节点恢复连接了，到集群是follower了，此时发现自己比新leader多出来一条proposal，但是自己的epoch比新leader的epoch低，所以就会丢弃掉这条数据</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>2PC中的过半写机制，只要一半以上的follower节点ack，leader就发送commit给所有follower节点，不用等所有follower节点都准备好发ack，可见性能做了优化</p><p>而且commit操作，是把数据写入内存中的znode树形数据结构里去，纯内存的数据结构能保证性能比较高</p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>前述节点的角色中，第3种角色 observer 节点是不参与leader选举的，也不参与ZAB协议同步时，过半follower去发送ack给leader的那个环节，它只是单纯的接收数据，同步数据，可能数据存在一定的不一致的问题，但是是只读的（zk集群中，只有leader节点可以写操作）</p><p>所以zk集群无论多少台机器，只能是一个leader进行写，单机写入最多每秒上万QPS，这是没法扩展的，所以zk适合写少的场景</p><p>但读呢？follower起码有2个或者4个，读起码可以有每秒几万QPS，如果读请求更多呢？此时就可以引入 observer 节点，她就只是同步数据，提供读服务的，所以可以无限的扩展 observer 节点</p><p>因此 observer 节点存在的意义就是线性扩展zk的读QPS</p><h2 id="集群化部署"><a href="#集群化部署" class="headerlink" title="集群化部署"></a>集群化部署</h2><p>zk集群节点数一般是奇数，因为5个节点可以挂2个，6个节点也可以挂2个，不能让超过一半的节点挂掉，所以5和6效果一致，那奇数个节点可以减少机器开销，</p><p>zk只能是小集群部署，适合读多写少场景</p><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么?"></a>为什么?</h3><p>假设有1个leader + 20个follower，21台机器，20个follower，一个写请求出去，leader要起码等待10台以上的follower返回ack，才能发送commit，才能写请求成功，性能极差</p><p>所以zk的ZAB协议就决定了1个leader + 2个follower的小集群就够了，写请求是无法扩展的，读请求如果量大，可以加 observer 节点，最终就是适合读多写少的场景</p><h1 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h1><h2 id="实现方案一"><a href="#实现方案一" class="headerlink" title="实现方案一"></a>实现方案一</h2><p>某客户端尝试创建临时 znode 节点，创建成功就获取这个锁；此时别的客户端来创建锁就会失败，只能注册个监听器监听这把锁。释放锁就是删除这个 znode 节点，一旦释放掉就会通知客户端，然后等待着的客户端就可再次重新获取锁。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZooKeeperSession</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">CountDownLatch</span> connectedSemaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">ZooKeeper</span> zookeeper<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ZooKeeperSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>zookeeper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZooKeeper</span><span class="token punctuation">(</span><span class="token string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span><span class="token punctuation">,</span> <span class="token number">50000</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ZooKeeperWatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                connectedSemaphore<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ZooKeeper session established......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 获取分布式锁     *      * @param productId     */</span>    <span class="token keyword">public</span> <span class="token class-name">Boolean</span> <span class="token function">acquireDistributedLock</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token string">"/product-lock-"</span> <span class="token operator">+</span> productId<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            zookeeper<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Ids</span><span class="token punctuation">.</span>OPEN_ACL_UNSAFE<span class="token punctuation">,</span> <span class="token class-name">CreateMode</span><span class="token punctuation">.</span>EPHEMERAL<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 相当于是给node注册一个监听器，去看看这个监听器是否存在</span>                    <span class="token class-name">Stat</span> stat <span class="token operator">=</span> zk<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>stat <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    zookeeper<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Ids</span><span class="token punctuation">.</span>OPEN_ACL_UNSAFE<span class="token punctuation">,</span> <span class="token class-name">CreateMode</span><span class="token punctuation">.</span>EPHEMERAL<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ee<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 释放掉一个分布式锁     *      * @param productId     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">releaseDistributedLock</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token string">"/product-lock-"</span> <span class="token operator">+</span> productId<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            zookeeper<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"release the lock for product[id="</span> <span class="token operator">+</span> productId <span class="token operator">+</span> <span class="token string">"]......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 建立zk session的watcher     *      * @author bingo     * @since 2018/11/29     *     */</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ZooKeeperWatcher</span> <span class="token keyword">implements</span> <span class="token class-name">Watcher</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">WatchedEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Receive watched event: "</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">KeeperState<span class="token punctuation">.</span>SyncConnected</span> <span class="token operator">==</span> event<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                connectedSemaphore<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 封装单例的静态内部类     *      * @author bingo     * @since 2018/11/29     *     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ZooKeeperSession</span> instance<span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZooKeeperSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ZooKeeperSession</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> instance<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 获取单例     *      * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ZooKeeperSession</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 初始化单例的便捷方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假设如下执行序列：</p><ol><li>客户端1创建了znode节点&#x2F;lock，获得了锁</li><li>客户端1进入了长时间的GC pause</li><li>客户端1连接到zk的session过期了。znode节点&#x2F;lock被自动删除</li><li>客户端2创建了znode节点&#x2F;lock，从而获得了锁</li><li>客户端1从GC pause中恢复过来，它仍然认为自己持有锁</li></ol><p>最后，客户端1和客户端2都认为自己持有了锁，冲突~<br>所以使用下列方案二</p><h2 id="实现方案二"><a href="#实现方案二" class="headerlink" title="实现方案二"></a>实现方案二</h2><p>创建临时顺序节点。如果有一把锁，被多个客户端竞争，此时多个客户端排队，第一个拿到锁的客户端执行，执行完释放锁；排在后面的每个客户端都会去监听排在自己前面的那个客户端创建的 node ，一旦某个客户端释放了锁，zookeeper 通知排在它后面的客户端，后面的客户端一旦被通知到，就去获取锁，执行操作</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZooKeeperDistributedLock</span> <span class="token keyword">implements</span> <span class="token class-name">Watcher</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">ZooKeeper</span> zk<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> locksRoot <span class="token operator">=</span> <span class="token string">"/locks"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> productId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> waitNode<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> lockNode<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">CountDownLatch</span> connectedLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> sessionTimeout <span class="token operator">=</span> <span class="token number">30000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ZooKeeperDistributedLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> productId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>productId <span class="token operator">=</span> productId<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> address <span class="token operator">=</span> <span class="token string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span><span class="token punctuation">;</span>            zk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZooKeeper</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span> sessionTimeout<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            connectedLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">KeeperException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">WatchedEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">KeeperState<span class="token punctuation">.</span>SyncConnected</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            connectedLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquireDistributedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token function">waitForLock</span><span class="token punctuation">(</span>waitNode<span class="token punctuation">,</span> sessionTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">KeeperException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 传入进去的locksRoot + “/” + productId</span>        <span class="token comment">// 假设productId代表了一个商品id，比如说1</span>        <span class="token comment">// locksRoot = locks</span>        <span class="token comment">// /locks/10000000000，/locks/10000000001，/locks/10000000002</span>            lockNode <span class="token operator">=</span> zk<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>locksRoot <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> productId<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">ZooDefs<span class="token punctuation">.</span>Ids</span><span class="token punctuation">.</span>OPEN_ACL_UNSAFE<span class="token punctuation">,</span> <span class="token class-name">CreateMode</span><span class="token punctuation">.</span>EPHEMERAL_SEQUENTIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 看看刚创建的节点是不是最小的节点</span>       <span class="token comment">// locks：10000000000，10000000001，10000000002</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> locks <span class="token operator">=</span> zk<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span>locksRoot<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>locks<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>lockNode<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>locksRoot<span class="token operator">+</span><span class="token string">"/"</span><span class="token operator">+</span> locks<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//如果是最小的节点,则表示取得锁</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>              <span class="token comment">//如果不是最小的节点，找到比自己小1的节点</span>    <span class="token keyword">int</span> previousLockIndex <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> locks<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lockNode<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>locksRoot <span class="token operator">+</span> “<span class="token operator">/</span>” <span class="token operator">+</span> locks<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               previousLockIndex <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>waitNode <span class="token operator">=</span> locks<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>previousLockIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">KeeperException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">waitForLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> waitNode<span class="token punctuation">,</span> <span class="token keyword">long</span> waitTime<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">KeeperException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Stat</span> stat <span class="token operator">=</span> zk<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>locksRoot <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> waitNode<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>stat <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 删除/locks/10000000000节点</span>            <span class="token comment">// 删除/locks/10000000001节点</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"unlock "</span> <span class="token operator">+</span> lockNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            zk<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>lockNode<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lockNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            zk<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">KeeperException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span><span class="token class-name">String</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="ZK的临时顺序节点为啥被称之为实现ZK分布式锁的天然之选？"><a href="#ZK的临时顺序节点为啥被称之为实现ZK分布式锁的天然之选？" class="headerlink" title="ZK的临时顺序节点为啥被称之为实现ZK分布式锁的天然之选？"></a>ZK的临时顺序节点为啥被称之为实现ZK分布式锁的天然之选？</h2><h3 id="每一个节点都是一个天然的顺序发号器"><a href="#每一个节点都是一个天然的顺序发号器" class="headerlink" title="每一个节点都是一个天然的顺序发号器"></a>每一个节点都是一个天然的顺序发号器</h3><p>每一个节点下面创建临时顺序节点（EPHEMERAL_SEQUENTIAL），新的子节点后面会加上一个顺序编号。这个顺序编号是上一个生成的顺序编号加1。如，用一个发号的节点“&#x2F;test&#x2F;lock”为父亲节点，可以在这个父节点下面创建相同前缀的临时顺序子节点，假定相同的前缀为“&#x2F;test&#x2F;lock&#x2F;seq-”。如果是第一个创建的子节点，那么生成的子节点为&#x2F;test&#x2F;lock&#x2F;seq-0000000000，下一个节点则为&#x2F;test&#x2F;lock&#x2F;seq-0000000001，依次类推</p><p>如下图</p><p><img src="/img/zookeeper/74D199308F00ADAECBA8DE8680E3C0EE.jpg" alt="节点图"></p><h3 id="节点的递增有序性可以确保锁的公平"><a href="#节点的递增有序性可以确保锁的公平" class="headerlink" title="节点的递增有序性可以确保锁的公平"></a>节点的递增有序性可以确保锁的公平</h3><p>zk 分布式锁，首先需要创建一个父节点，尽量是持久化节点，然后每个要获得锁的线程都在这个节点下创建一个临时顺序节点。由于zk节点是按照创建的顺序依次递增的，为了确保公平，可以简单地规定，编号最小的那个节点先获得锁。因此，每个线程在尝试占用锁之前，首先判断自己的编号是不是当前最小的，如果是，则获取到锁</p><h3 id="节点监听机制可以保障占有锁的传递有序而且高效"><a href="#节点监听机制可以保障占有锁的传递有序而且高效" class="headerlink" title="节点监听机制可以保障占有锁的传递有序而且高效"></a>节点监听机制可以保障占有锁的传递有序而且高效</h3><p>每个线程抢占锁之前，先抢号创建自己的ZNode。同样，释放锁的时候，就需要删除抢号的ZNode。在抢号成功之后，如果不是排号最小的节点，就处于等待通知的状态。等谁的通知？等前一个ZNode的通知！当前一个ZNode被删除时，就轮到了自己占有锁的时候。第一个通知第二个、第二个通知第三个，击鼓传花似的依次向后传递。</p><p>zk的节点监听机制能非常完美地实现这种击鼓传花似的信息传递。具体的方法是，每一个等通知的ZNode节点，只需监听或者监视编号在自己前面那个且紧挨在自己前面的那个节点。只要上一个节点被删除了，就再进行一次判断，看看自己是不是序号最小的那个节点，如果是，则获得锁。</p><p>这种优越的机制，能保证由于网络异常或者其他原因造成集群中占用锁的客户端失联时，锁能够被有效释放。一旦占用锁的客户端与zk集群服务器失去联系，这个临时ZNode也将被自动删除。排在它后面的那个节点也能收到删除事件，从而获得锁。所以，在创建节点时，尽量创建临时顺序节点</p><h3 id="节点监听机制能避免羊群效应"><a href="#节点监听机制能避免羊群效应" class="headerlink" title="节点监听机制能避免羊群效应"></a>节点监听机制能避免羊群效应</h3><p>何为<strong>羊群效应</strong>？<br>一个节点挂掉了，所有节点都去监听，然后作出反应，这样会给服务器带来巨大压力</p><p>首尾相接，后面监听前面的方式，可以避免羊群效应。有了临时顺序节点，当一个节点挂掉，只有它后面的那一个节点才能作出反应</p><h2 id="和Redis分布式锁对比"><a href="#和Redis分布式锁对比" class="headerlink" title="和Redis分布式锁对比"></a>和Redis分布式锁对比</h2><p>Redis分布式锁实现见Redis篇，这里只是比较一下各自优劣</p><ul><li><p>redis 分布式锁，需要客户端不断去尝试获取锁，比较消耗性能<br>zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小</p></li><li><p>redis 获取锁的那个客户端要是挂了，那只能等待超时时间到了之后才能释放锁<br>zk 因为创建的是临时 znode 节点，只要客户端挂了，znode 就没了，此时就会自动释放锁</p></li><li><p>zk 分布式锁性能不高。原因是每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能。zk中创建和删除节点只能通过leader节点来执行，然后leader节点还需要将数据同步到所有的follower节点上，这样频繁的网络通信，性能的短板就非常突出</p></li></ul><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><p>redis 分布式锁适用于并发量很大、性能要求很高而可靠性问题可通过其他方案弥补的场景。<br>zk 分布式锁适用于高可用，而并发量不是太高的场景<br>所以，没有谁好谁坏的问题，而是谁更合适的问题~</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://gitee.com/shishan100/Java-Interview-Advanced">中华石杉–互联网Java进阶面试训练营</a></li><li><a href="https://mp.weixin.qq.com/s/4CUe7OpM6y1kQRK8TOC_qQ">基于Redis的分布式锁到底安全吗?(下)</a></li></ol><h1 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a><a href="/Zookeeper">推荐书单</a></h1>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socket</title>
    <link href="/posts/38366605.html"/>
    <url>/posts/38366605.html</url>
    
    <content type="html"><![CDATA[<p>OSI七层协议和TCP&#x2F;IP四层协议里都没有这个socket，它是从哪里出来的？</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><img src="/img/socket/245EC9B3562913665EF27B861E93FB79.jpg" alt="Socket介绍"></p><p>Socket是应用层与TCP&#x2F;IP协议通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。个人认为在OSI七层协议中，它应该属于会话层，正好在传输层之上。上图是按照TCP&#x2F;IP四层协议来画的，可能不清楚</p><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p><img src="/img/socket/DB38C4400DB50BAD59CB391604C8C74F.jpg" alt="Socket工作原理"></p><p>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束</p><p>图中read&#x2F;write操作，并不是直接从物理设备把数据读取到内存中，也不是直接把数据写入到物理设备。无论是read，还是write，都会涉及到缓冲区。具体来说，read是把数据从内核缓冲区复制到进程缓冲区，而write是把数据从进程缓冲区复制到内核缓冲区。</p><p>在Linux系统中，操作系统内核只有一个内核缓冲区。而每个用户程序（进程），有自己独立的缓冲区，叫作进程缓冲区。所以，用户程序的IO读写（不仅仅是指socket读写），在大多数情况下，并没有进行实际的IO操作，而是在进程缓冲区和内核缓冲区之间直接进行数据的交换</p><h2 id="Socket的读写调用流程"><a href="#Socket的读写调用流程" class="headerlink" title="Socket的读写调用流程"></a>Socket的读写调用流程</h2><p><img src="/img/socket/28BE86FDCF2B236DE50E10F9DA67F7BF.jpg" alt="读写流程"></p><ul><li>客户端请求: Linux通过网卡读取客户端的请求数据，将数据读取到内核缓冲区</li><li>获取请求数据: Java服务器通过read系统调用，从Linux内核缓冲区读取数据，再送入Java进程缓冲区</li><li>服务器端业务处理: Java服务器在自己的用户空间中处理客户端的请求。</li><li>服务器端返回数据: Java服务器完成处理后，构建好的响应数据，将这些数据从用户缓冲区写入内核缓冲区。这里用到的是write系统调用</li><li>发送给客户端: Linux内核通过网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议，会将数据发送给目标客户端</li></ul><h2 id="5种IO模型"><a href="#5种IO模型" class="headerlink" title="5种IO模型"></a>5种IO模型</h2><p>所有以下IO过程，都分为两个阶段: 数据的准备和数据的复制</p><h3 id="阻塞IO模型（BIO，Blocking-IO）"><a href="#阻塞IO模型（BIO，Blocking-IO）" class="headerlink" title="阻塞IO模型（BIO，Blocking IO）"></a>阻塞IO模型（BIO，Blocking IO）</h3><p>又名同步阻塞IO，最简单的 I&#x2F;O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。</p><p><img src="/img/socket/E1A56EC3C6D9A8BA08F1330A2C46FCF7.jpg" alt="阻塞IO模型"></p><ol><li>Java启动IO读的read系统调用开始，用户线程就进入阻塞状态</li><li>当系统内核收到read系统调用，就开始准备数据。一开始，数据可能还没有到达内核缓冲区（例如，还没有收到一个完整的socket数据包），这个时候内核就要等待</li><li>内核一直等到完整的数据到达，就会将数据从内核缓冲区复制到用户缓冲区（用户空间的内存），然后内核返回结果（例如返回复制到用户缓冲区中的字节数）</li><li>直到内核返回后，用户线程才会解除阻塞的状态，重新运行起来</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>在内核进行IO执行的两个阶段（数据准备和数据复制），用户线程都被阻塞了</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>应用的程序开发非常简单；在阻塞等待数据期间，用户线程挂起。在阻塞期间，用户线程基本不会占用CPU资源</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>一般情况下，会为每个连接配备一个独立的线程；反过来说，就是一个线程维护一个连接的IO操作。在并发量小的情况下，这样做没有什么问题。但是，当在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，在高并发应用场景下是不可用的</p><h3 id="非阻塞IO模型（Non-blocking-IO）"><a href="#非阻塞IO模型（Non-blocking-IO）" class="headerlink" title="非阻塞IO模型（Non-blocking IO）"></a>非阻塞IO模型（Non-blocking IO）</h3><p>又名同步非阻塞IO，应用进程与内核交互，目的未达到之前，不再一味的等着，而是直接返回。然后通过轮询的方式，不停的去问内核数据准备有没有准备好。如果某一次轮询发现数据已经准备好了，就把数据拷贝到用户缓冲区中。</p><p><img src="/img/socket/E63CC6D32E5BC87C8037FC08759B3FA8.jpg" alt="非阻塞IO模型"></p><ol><li>在内核数据没有准备好的阶段，用户线程发起IO请求时，立即返回。所以，为了读取到最终的数据，用户线程需要不断地发起IO系统调用</li><li>内核数据到达后，用户线程发起系统调用，用户线程阻塞。内核开始复制数据，它会将数据从内核缓冲区复制到用户缓冲区（用户空间的内存），然后内核返回结果（例如返回复制到的用户缓冲区的字节数）</li><li>用户线程读到数据后，才会解除阻塞状态，重新运行起来。也就是说，用户进程需要经过多次的尝试，才能保证最终真正读到数据，而后继续执行</li></ol><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好，就继续轮询，直到完成IO系统调用为止</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>每次发起的IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>不断地轮询内核，这将占用大量的CPU时间，效率低下。总体来说，在高并发应用场景下，同步非阻塞IO也是不可用的。一般Web服务器不使用这种IO模型。这种IO模型一般很少直接使用，而是在其他IO模型中使用非阻塞IO这一特性。在实际的Java开发中，也不会涉及这种IO模型</p><blockquote><p>非阻塞IO，可简称为NIO，但它不是Java中的NIO，虽然它们的英文缩写一样，希望大家不要混淆。Java的NIO（New IO），对应的不是非阻塞IO模型，而是IO多路复用模型（IO multiplexing）</p></blockquote><h3 id="IO复用模型（IO-multiplexing）"><a href="#IO复用模型（IO-multiplexing）" class="headerlink" title="IO复用模型（IO multiplexing）"></a>IO复用模型（IO multiplexing）</h3><p>经典的Reactor反应器设计模式，有时也称为异步阻塞IO, Java中的Selector选择器和Linux中的epoll都是这种模型</p><p><img src="/img/socket/8CC90F851B8EB59022F1B75C13450F74.jpg" alt="IO复用模型"></p><ol><li>选择器注册。在这种模式中，首先，将需要read操作的目标socket网络连接，提前注册到select&#x2F;epoll选择器中，Java中对应的选择器类是Selector类。然后，才可以开启整个IO多路复用模型的轮询流程</li><li>就绪状态的轮询。通过选择器的查询方法，查询注册过的所有socket连接的就绪状态。通过查询的系统调用，内核会返回一个就绪的socket列表。当任何一个注册过的socket中的数据准备好了，内核缓冲区有数据（就绪）了，内核就将该socket加入到就绪的列表中。当用户进程调用了select查询方法，那么整个线程会被阻塞掉</li><li>用户线程获得了就绪状态的列表后，根据其中的socket连接，发起read系统调用，用户线程阻塞。内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区</li><li>复制完成后，内核返回结果，用户线程才会解除阻塞的状态，用户线程读取到了数据，继续执行</li></ol><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>IO多路复用模型的IO涉及两种系统调用（System Call），另一种是select&#x2F;epoll（就绪查询），一种是IO操作。IO多路复用模型建立在操作系统的基础设施之上，即操作系统的内核必须能够提供多路分离的系统调用select&#x2F;epoll。和NIO模型相似，多路复用IO也需要轮询。负责select&#x2F;epoll状态查询调用的线程，需要不断地进行select&#x2F;epoll轮询，查找出达到IO操作就绪的socket连接。IO多路复用模型与同步非阻塞IO模型是有密切关系的。对于注册在选择器上的每一个可以查询的socket连接，一般都设置成为同步非阻塞模型。仅是这一点，对于用户程序而言是无感知的</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>与一个线程维护一个连接的阻塞IO模式相比，使用select&#x2F;epoll的最大优势在于，一个选择器查询线程可以同时处理成千上万个连接（Connection）。系统不必创建大量的线程，也不必维护这些线程，从而大大减小了系统的开销。Java语言的NIO（New IO）技术，使用的就是IO多路复用模型。在Linux系统上，使用的是epoll系统调用</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>本质上，select&#x2F;epoll系统调用是阻塞式的，属于同步IO。都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是说这个读写过程是阻塞的</p><h3 id="信号驱动IO模型（signal-driven-IO）"><a href="#信号驱动IO模型（signal-driven-IO）" class="headerlink" title="信号驱动IO模型（signal driven IO）"></a>信号驱动IO模型（signal driven IO）</h3><p>应用进程在读取文件时通知内核，如果某个socket的某个事件发生了，请向应用进程发一个信号。收到信号后，信号对应的处理函数会进行后续处理</p><p>应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中</p><h3 id="异步IO模型（AIO，asynchronous-IO）"><a href="#异步IO模型（AIO，asynchronous-IO）" class="headerlink" title="异步IO模型（AIO，asynchronous IO）"></a>异步IO模型（AIO，asynchronous IO）</h3><p>异步IO，指的是用户空间与内核空间的调用方式反过来。用户空间的线程变成被动接受者，而内核空间成了主动调用者。有点类似Java中的回调模式，用户空间的线程向内核空间注册了各种IO事件的回调函数，由内核去主动调用。</p><p><img src="/img/socket/4A5045459F013A58F4A6A64466DCBA4E.jpg" alt="异步IO模型"></p><ol><li>当用户线程发起了read系统调用，立刻就可以开始去做其他的事，用户线程不阻塞</li><li>内核就开始了IO的第一个阶段：准备数据。等到数据准备好了，内核就会将数据从内核缓冲区复制到用户缓冲区（用户空间的内存）</li><li>内核会给用户线程发送一个信号（Signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了</li><li>用户线程读取用户缓冲区的数据，完成后续的业务操作</li></ol><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>在数据准备和数据复制两个阶段，用户线程都不是阻塞的。用户线程需要接收内核的IO操作完成的事件，或者用户线程需要注册一个IO操作完成的回调函数</p><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>应用程序仅需要进行事件的注册与接收，其余的工作都留给了操作系统，也就是说，需要底层内核提供支持。理论上来说，异步IO是真正的异步输入输出，它的吞吐量高于IO多路复用模型的吞吐量。就目前而言，Windows系统下通过IOCP实现了真正的异步IO。而在Linux系统下，异步IO模型在2.6版本才引入，目前并不完善，其底层实现仍使用epoll，与IO多路复用相同，因此在性能上没有明显的优势。大多数的高并发服务器端的程序，一般都是基于Linux系统的。因而，目前这类高并发网络应用程序的开发，大多采用IO多路复用模型</p><blockquote><p>Netty框架，使用的就是IO多路复用模型，而不是异步IO模型</p></blockquote><h2 id="5种IO模型深入理解"><a href="#5种IO模型深入理解" class="headerlink" title="5种IO模型深入理解"></a>5种IO模型深入理解</h2><p>上面那节说的公式化和概念化，可能并不是很好理解，使用<a href="38366605.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a>中提供的链接，打个比方进一步说明</p><p>钓鱼时，刚开始鱼是在鱼塘里面的，钓鱼动作的最终结束标志是鱼从鱼塘中被人钓上来，放入鱼篓中。</p><p>这里鱼塘就可以映射成磁盘，中间过渡的鱼钩可以映射成内核缓冲区，最终放鱼的鱼篓可以映射成用户缓冲区。一次完整的钓鱼（IO）操作，是鱼（文件）从鱼塘（磁盘）中转移（复制）到鱼篓（用户缓冲区）的过程</p><h3 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h3><p>我们钓鱼的时候，有一种方式比较惬意，比较轻松，那就是我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼</p><p>这种钓鱼方式相对来说比较简单，对于钓鱼的人来说，不需要什么特制的鱼竿，拿一根够长的木棍就可以悠闲的开始钓鱼了（实现简单）。缺点就是比较耗费时间，比较适合那种对鱼的需求量小的情况（并发低，时效性要求低）</p><h3 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h3><p>我们钓鱼的时候，在等待鱼儿咬钩的过程中，我们可以做点别的事情。但是，我们要时不时的去看一下鱼竿，一旦发现有鱼儿上钩了，就把鱼钓上来</p><p>这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率</p><h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h3><p>我们钓鱼时，为了避免自己一遍一遍的去查看鱼竿，可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来</p><p>这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了</p><h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h3><p>我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来</p><p>这种方式的钓鱼，通过增加鱼竿的方式，可以有效的提升效率</p><p>以上4种都是同步模型，因为钓鱼过程，可以拆分为两个步骤：1、鱼咬钩（数据准备）。2、把鱼钓起来放进鱼篓里（数据复制）。无论以上提到的哪种钓鱼方式，在第二步，都是需要人主动去做的，并不是鱼竿自己完成的。所以，这个钓鱼过程其实还是同步进行的</p><h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>我们钓鱼时，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了</p><p>这种方式的钓鱼，无疑是最省事儿的。啥都不需要管，只需要交给鱼竿就可以了，但是目前linux实现并不完善</p><p>5种模型对比图如下<br><img src="/img/socket/ADF7EAEA1B65D61E782D7A3C687B50D3.jpg" alt="5种模型对比"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>1.<a href="https://mp.weixin.qq.com/s/3C7Iv1jof8jitOPL_4c_bQ">漫话：如何给女朋友解释什么是Linux的五种IO模型？</a></p><h1 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a><a href="/Socket">推荐书单</a></h1>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>Socket</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/posts/3041119952.html"/>
    <url>/posts/3041119952.html</url>
    
    <content type="html"><![CDATA[<p>消息队列使用目的:</p><p><strong>异步</strong>、<strong>削峰</strong>、<strong>解耦</strong></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>RabbitMQ基于AMQP协议，通过使用通用协议就可以做到在不同语言之间传递。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ol><li>server<br>又称broker，接受客户端连接，实现AMQP实体服务。</li><li>connection<br>连接和具体broker网络连接。</li><li>channel<br>网络信道，几乎所有操作都在channel中进行，channel是消息读写的通道。客户端可以建立多个channel，每个channel表示一个会话任务。</li><li>message<br>消息，服务器和应用程序之间传递的数据，由properties和body组成。properties可以对消息进行修饰，比如消息的优先级，延迟等高级特性;body是消息实体内容。</li><li>virtual host<br>虚拟主机，用于逻辑隔离，最上层消息的路由。一个virtual host可以若干个exchange和queue，同一个virtual host不能有同名的exchange或queue。</li><li>exchange<br>交换机，接受消息，根据路由键转发消息到绑定的队列上。</li><li>banding<br>exchange和queue之间的虚拟连接，binding中可以包括routing key</li><li>routing key<br>一个路由规则，虚拟机根据他来确定如何路由一条消息。</li><li>queue<br>消息队列，用来存放消息的队列。</li></ol><h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p>类型有 direct、topic、fanout、headers、durability（是否需要持久化，true为需要）、auto delete</p><p>最后一个绑定Exchange上的队列被删除Exchange也删除。</p><p>主要介绍下列三个:</p><ol><li>direct<br>所有发送到Direct Exchange的消息被转发到RouteKey中指定的Queue,Direct Exchange可以使用默认的默认的Exchange （default<br>Exchange），默认的Exchange会绑定所有的队列，所以Direct可以直接使用Queue名（作为routing key ）绑定。或者消费者和生产者的routing key完全匹配。</li><li>topic<br>是指发送到Topic Exchange的消息被转发到所有关心的Routing key中指定topic的Queue上。Exchange 将routing<br>key和某Topic进行模糊匹配，此时队列需要绑定一个topic。所谓模糊匹配就是可以使用通配符，”#”可以匹配一个或多个词，”* “只匹配一个词。<br>比如”log.#”可以匹配”log.info.test”<br>“log.*” 就只能匹配log.error。</li><li>fanout<br>不处理路由键，只需简单的将队列绑定到交换机上。发送到这个 Exchange 上的消息都会被发送到与它绑定的队列上。Fanout转发是最快的。</li></ol><h1 id="如何实现高可用？"><a href="#如何实现高可用？" class="headerlink" title="如何实现高可用？"></a>如何实现高可用？</h1><p><strong>开启镜像模式</strong></p><p>创建的queue，无论元数据还是queue里的消息都会存在于多个实例上。</p><p>就是说，每个RabbitMQ节点都有这个queue的一个完整镜像，包含queue的全部数据。</p><p>每次写消息到queue，都会自动把消息同步到多个实例的queue上</p><p><img src="/img/rabbitmq/A591C744680EDD96A069B3D1F5A6E5B9.jpg" alt="镜像模式"></p><p><strong>如何开启？</strong></p><p>后台新增镜像集群模式的策略，指定时要求数据同步到所有节点，也可要求同步到指定数量的节点。</p><p>再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去</p><p><strong>优点</strong>:<br>任何一个节点挂了，其它节点还包含 queue 的完整数据， consumer 可以到其它节点上去消费数据。</p><p><strong>缺点</strong>:<br>第一，性能开销大，消息需要同步到所有节点上，导致网络带宽压力和消耗很重<br>第二，不是分布式，没有扩展性可言。如果某个 queue 负载很重，加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展 queue。如果queue 的数据量很大，大到节点容量无法容纳，就不行了</p><h1 id="如何实现消息消费幂等，即不被重复消费？"><a href="#如何实现消息消费幂等，即不被重复消费？" class="headerlink" title="如何实现消息消费幂等，即不被重复消费？"></a>如何实现消息消费幂等，即不被重复消费？</h1><p>见<a href="/posts/2591906323.html#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89%EF%BC%8C%E5%8D%B3%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F">Kafka</a>内容</p><h1 id="如果保证不丢消息？"><a href="#如果保证不丢消息？" class="headerlink" title="如果保证不丢消息？"></a>如果保证不丢消息？</h1><p><img src="/img/rabbitmq/7FABA29BB5EFAE6906C4D54E6961103C.jpg" alt="丢消息情形"></p><p>丢数据分三种情况</p><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>数据发送到 RabbitMQ 时，因为网络问题，可能数据丢了。</p><p>选择 RabbitMQ 提供的事务功能，在生产者发送数据之前开启 RabbitMQ 事务 channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ<br>接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 开启事务</span>channel<span class="token punctuation">.</span>txSelect<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 这里发送消息</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    channel<span class="token punctuation">.</span>txRollback    <span class="token comment">// 这里再次重发这条消息</span><span class="token punctuation">&#125;</span><span class="token comment">// 提交事务</span>channel<span class="token punctuation">.</span>txCommit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>RabbitMQ 事务机制（同步）会让吞吐量下降，因此会很耗性能。</p><p>如果要确保写 RabbitMQ 消息不丢消息，可以开启 confirm 模式，在生产者设置开启 confirm 模式，每次写消息分配一个唯一的 id，然后写入RabbitMQ 中，RabbitMQ 会回传一个 ack 消息，说这个消息 ok<br>了。如果 RabbitMQ 没能处理这个消息，会回调一个 nack 接口，告诉消息接收失败，只能再次重试。但可结合这个机制在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那可以重发。</p><p>事务机制和 confirm 机制最大的不同在于:<br>事务机制是同步，提交一个事务之后会阻塞,但 confirm 机制是异步，发个消息后可以发送下一个消息，然后下一个消息 RabbitMQ 接收了之后会异步回调一个接口通知这个消息已接收到。</p><p>因此在生产者这块为了避免数据丢失，都是用 confirm 机制。</p><h2 id="RabbitMQ服务"><a href="#RabbitMQ服务" class="headerlink" title="RabbitMQ服务"></a>RabbitMQ服务</h2><p>必须开启 RabbitMQ 持久化，就是消息写入之后持久化到磁盘，即使RabbitMQ 挂了，恢复之后会自动读取之前存储的数据，一般情况下数据就不会丢。<br>除非 RabbitMQ 自身还没持久化就挂了，可能会导致少量数据丢失，但发生概率较小。</p><p>设置持久化有两个步骤:</p><ul><li><p>创建 queue 时,设置持久化<br>保证 RabbitMQ 持久化 queue 的元数据，但是不会持久化 queue 里的数据。</p></li><li><p>发送消息时,把消息的 deliveryMode 设置为 2<br>即把消息设置为持久化，此时 RabbitMQ 会将消息持久化到磁盘上去。</p></li></ul><p>必须要同时设置这两个持久化，RabbitMQ 就算挂了再重启，也会从磁盘上重启恢复 queue，恢复这个 queue 的数据。</p><p>但是还有一种可能，就是某个消息写到了 RabbitMQ 中，但还没来得及持久化到磁盘上。此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p><p>所以，持久化可以和生产者的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack ，哪怕持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack，还是可以重发。</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>使用 RabbitMQ 提供的 ack 机制，简而言之，必须关闭 RabbitMQ 的自动 ack，通过一个 api 来调用就可以了，之后每次，确保代码处理完消息时，再在程序里 ack 一次。通过这样的处理方式，如果还没处理完消息，没有<br>ack 时， RabbitMQ 会认为代码还没处理完，就会把这个消息消费动作分配给别的消费者处理，这样消息是不会丢的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/img/rabbitmq/6141BD7C1D6731BC639E9054816B69B8.jpg" alt="丢消息解决方案脑图"></p><h1 id="如何保证消息被消费的顺序？"><a href="#如何保证消息被消费的顺序？" class="headerlink" title="如何保证消息被消费的顺序？"></a>如何保证消息被消费的顺序？</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><img src="/img/rabbitmq/9418C9D261BC18C401FDF0837D241627.jpg" alt="按顺序消费情形"></p><p>如上图，生产者向 RabbitMQ 里发送三条数据，要求的消费顺序依次是data1&#x2F;data2&#x2F;data3。<br>有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1&#x2F;data3。这就没有达到要求的消费顺序。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>拆分成多个 queue，每个 queue 负责一个 consumer；或就一个 queue 对应一个 consumer，然后这个 consumer 内部用内存队列做排队，比如设定消息消费的优先级</p><p><img src="/img/rabbitmq/6BCA2B939EEE4DD7944D5447B3A116EA.jpg" alt="解决方案"></p><h1 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a><a href="/RabbitMQ">推荐书单</a></h1>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本数据结构</title>
    <link href="/posts/3973228452.html"/>
    <url>/posts/3973228452.html</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是用来存储固定大小的同类型元素的</p><p>java里声明数组变量方式如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> myArray<span class="token punctuation">;</span> <span class="token comment">// 首选</span><span class="token keyword">double</span> myArray<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>创建数组方式如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>arraySize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>还可以有多维数组</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Good"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Luck"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"to"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>java.util.Arrays类能方便地操作数组，它提供的所有方法都是静态的</p><ul><li>给数组赋值：通过fill方法</li><li>对数组排序：通过sort方法,按升序</li><li>比较数组：通过equals方法比较数组中元素值是否相等</li><li>查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找法操作</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表在进行循环遍历时效率不高，但是插入和删除时优势明显。java中最出名的是LinkedList</p><p>目前主要是单向链表，它是一种线性表，由节点（Node）组成的，一个链表拥有不定数量的节点。其数据在内存中存储是不连续的，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由N各节点（Node）组成单向链表，每一个Node记录自己这个Node的数据及下一个Node。向外暴露的只有一个头节点（Head），我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</p><p>添加节点的顺序是从右向左的。最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以头节点就可以操作所有节点了。</p><p>总结：节点拥有两个成员：储存的对象、对下一个节点的引用</p><p>另外说一句，数组和链表的区别是数组中每个元素存放的物理地址是连续的，而链表中是不连续的</p><p>下面说一下LinkedList</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList和ArrayList都实现了List接口，但其内部的数据结构不一样。LinkedList基于链表实现的（通过名字也能区分开来），它的插入和删除操作比ArrayList更高效。但随机访问的效率要比ArrayList差。</p><p>jdk源码（java11）</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span>     <span class="token keyword">extends</span> <span class="token class-name">AbstractSequentialList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span>     <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>由源码可知</p><ul><li>LinkedList是一个继承AbstractSequentialList的双向链表。它可当作堆栈、队列或双端队列进行操作</li><li>LinkedList实现List接口，能对它进行队列操作</li><li>LinkedList实现Deque接口，即能当作双端队列使用</li><li>LinkedList实现Cloneable接口，即覆盖了函数clone()，能克隆</li><li>LinkedList实现java.io.Serializable接口，所以它支持序列化，能通过序列化去传输</li><li>LinkedList是非同步的</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>底层的数据结构是基于双向链表，且头结点中不存放数据</p><p>双向链表节点实例保存数据，还有前一个节点的位置信息和后一个节点位置信息</p><h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> first<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> last<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>first是双向链表的头节点，它是双向链表节点所对应的类Node实例。Node中包含成员变量: prev, next, item。prev是上一个节点，next是下一个节点，item是自身所包含的值。size是双向链表中节点实例个数。</p><p>Node类源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token class-name">E</span> item<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> prev<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> prev<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>LinkedList提供了两个构造方法。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">linkBefore</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> succ<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 先找出当前节点的前一个节点</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> succ<span class="token punctuation">)</span><span class="token punctuation">;</span>    succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">else</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">/**  * 根据索引来找节点  */</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// assert isElementIndex(index);</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 先判断给的index是否大于二分之一的size</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token comment">// 如果小于，从first开始</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> <span class="token comment">// 如果大于，就从last开始找</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>根据传入的index，判断是大于二分之一的size，还是小于，如果小于二分之一的size，从first开始找；如果大于二分之一的size，从last开始找</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">E</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">E</span> element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        first <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        last <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    x<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    size<span class="token operator">--</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> element<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>第一个判断是否为first结点<br>是: first引用直接指向当前节点下一个节点<br>否: 前一个节点的next引用指向下一个节点<br>第二个判断是否为last节点<br>是: 最后的last的引用指向前一个节点<br>否: 下一个节点的pre指向前一个节点</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ListItr</span> <span class="token keyword">implements</span> <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> lastReturned<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> nextIndex<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    <span class="token class-name">ListItr</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// assert isPositionIndex(index);</span>        next <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        nextIndex <span class="token operator">=</span> index<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> nextIndex <span class="token operator">&lt;</span> size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lastReturned <span class="token operator">=</span> next<span class="token punctuation">;</span>        next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> nextIndex <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lastReturned <span class="token operator">=</span> next <span class="token operator">=</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> last <span class="token operator">:</span> next<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> nextIndex<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">previousIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lastReturned <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> lastNext <span class="token operator">=</span> lastReturned<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token function">unlink</span><span class="token punctuation">(</span>lastReturned<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> lastReturned<span class="token punctuation">)</span>            next <span class="token operator">=</span> lastNext<span class="token punctuation">;</span>        <span class="token keyword">else</span>            nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>        lastReturned <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        expectedModCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lastReturned <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lastReturned<span class="token punctuation">.</span>item <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lastReturned <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">linkBefore</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>        expectedModCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEachRemaining</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> action<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>modCount <span class="token operator">==</span> expectedModCount <span class="token operator">&amp;&amp;</span> nextIndex <span class="token operator">&lt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>            lastReturned <span class="token operator">=</span> next<span class="token punctuation">;</span>            next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>循环删除需要使用这个</p><p>应用代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> linkedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> linkedList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>跳表是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作</p><p>链表加多级索引的结构，提升查询元素效率。就像一本书，找其中相关内容，可以通过目录依次找到自己需要找到的章节</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>在表尾进行插入和删除操作的线性表。分栈顶，栈底。向一个栈插入新元素称作进栈、入栈或压栈，把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。元素是先进后出（FILO）</p><p>java中Stack方法包括</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token comment">//入栈</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//栈顶元素出栈</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//判定栈是否为空</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//获取栈顶元素</span><span class="token function">search</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token comment">//判端元素num是否在栈中，如果在返回1，不在返回-1。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><code>pop()</code>和<code>peek()</code>区别。<code>pop()</code>会弹出栈顶元素并返回栈顶的值，<code>peek()</code>只获取栈顶的值，栈中元素不会变化</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列的两端都可进出元素，要求数据只能从一端进，从另一端出。是先进先出（FIFO）</p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>同时具有栈和队列特性的数据结构是就是双端队列，java里就是Deque类</p><table><thead><tr><th>队列方法</th><th>deque方法</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td></tr><tr><td>remove()</td><td>removeFirst()</td></tr><tr><td>poll()</td><td>pollFirst()</td></tr><tr><td>element()</td><td>getFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p>当队列用时（FIFO），添加元素是添加到队尾，删除时删除的是头部元素<br>当栈用（FILO）。这时入栈、出栈元素都是在双端队列的头部进行</p><table><thead><tr><th>栈方法</th><th>deque方法</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td></tr><tr><td>pop()</td><td>removeFist()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>java里优先队列PriorityQueue是Queue接口的实现，可以对其中元素进行排序，</p><p>可以放基本数据类型的包装类（如：Integer，Long等）或自定义的类</p><p>对于基本数据类型的包装器类，优先队列中元素默认排列顺序是升序排列（从小到大）</p><p>但对于自己定义的类来说，需要自己定义比较器</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//返回队首元素</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//返回队首元素，队首元素出队列</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//添加元素</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//返回队列元素个数</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//判断队列是否为空，为空返回true,不空返回false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><code>PriorityQueue</code>是基于最小堆原理实现。最小堆是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于其左子节点和右子节的值。</p><p>插入、删除操作的时间复杂度为<code>O(log(n))</code></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>链表</tag>
      
      <tag>跳表</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/posts/4049607742.html"/>
    <url>/posts/4049607742.html</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>保证一个对象只能创建一个实例，此外，还提供对实例的全局访问方法</p><p><img src="/img/singleton/EC73D3A5C7A1958C3DE403CB6C74A2DF.png" alt="单例UML图"></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>需要频繁创建的一些类，使用单例可降低系统的内存压力，减少GC</li><li>某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用</li><li>频繁访问数据库或文件的对象</li></ol><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>目前有下列几种创建方式</p><ul><li>懒汉式—线程不安全<br>最基础的实现方式，线程上下文单例，不需要共享给所有线程，也不需要加synchronize之类的锁来提高性能</li><li>懒汉式—线程安全<br>加上synchronize之类保证线程安全的基础上的懒汉模式，相对性能很低，大部分时间并不需要同步</li><li>饿汉式。<br>在类装载时，创建全局的单例实例</li><li>双检锁式<br>在懒汉式基础上利用synchronize关键字和volatile关键字确保第一次创建时没有线程间竞争。不会产生多个实例，仅第一次创建时同步，性能相对较高</li><li>登记式<br>作为内部类的全局属性存在，内部类被装载时创建实例</li><li>枚举式。<br>java中的枚举类，其本身也是一种单例模式</li></ul><h3 id="懒汉式—线程不安全"><a href="#懒汉式—线程不安全" class="headerlink" title="懒汉式—线程不安全"></a>懒汉式—线程不安全</h3><p>源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyNoSafeSingleton</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">LazyNoSafeSingleton</span> singleton <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">LazyNoSafeSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">LazyNoSafeSingleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 线程会在这里等待</span>      singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazyNoSafeSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>上述代码在单线程场景是没问题的。</p><p>但在多线程场景中，singleton实例为null，会存在两个线程同时调用getInstance方法情况。在这种情况下，假设是线程a和线程b，线程a首先使用新构造器实例化单例对象，同时线程b也会检查singleton实例是否为null，由于a还没完成singleton对象的实例化操作，所以b会发现这个实例是null，那b也会开始实例化单例对象。</p><p>上述场景看似发生概率不大，但在需要较长时间实例化单例对象时候，则发生可能性就很高，所以不能忽视这种情况。</p><h3 id="懒汉式—线程安全"><a href="#懒汉式—线程安全" class="headerlink" title="懒汉式—线程安全"></a>懒汉式—线程安全</h3><p>为了解决上述不安全的问题，有两种解决方法，这两种都可以算是懒汉式—线程安全的方法</p><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySafeSingleton1</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">LazySafeSingleton1</span> singleton <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">LazySafeSingleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">LazySafeSingleton1</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySafeSingleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>在getInstance方法前加上synchronized关键字，使方法变成线程同步的方法。这样如上述两个线程同时调用getInstance方法时候，线程a先调用，线程b后调用，线程b调用时，线程状态由running变为monitor（见synchronize关键字以及线程状态讲解章节），出现阻塞。直到线程a结束调用，线程b才会把状态变回running，此时它调用getInstance方法时，线程a已完成singleton对象的实例化，因此b会发现已有实例，就不会去实例化singleton对象了。</p><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySafeSingleton2</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">LazySafeSingleton2</span> singleton <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">LazySafeSingleton2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">LazySafeSingleton2</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">LazySafeSingleton2</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySafeSingleton2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>synchronized代码块，指定Singleton对象来提供锁，LazySafeSingleton2.class就是起这种作用，作用和方法1类似，但是，不管方法1还是方法2,如果线程a执行时间过长，则后面不光是线程b，甚至线程c,d,e,f,g…都可能会等待线程a结束调用，才能把自己状态变回running，否则一直是monitor状态，则会产生大量的线程阻塞现象。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HungrySingleton</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">HungrySingleton</span> SINGLETON <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token comment">/**   * 通过该方法获取实例对象   *   * @return 实例对象   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">HungrySingleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> SINGLETON<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>类被加载时，静态变SINGLETON会被初始化，此时调用类的私有构造函数，HungrySingleton类的唯一实例就被创建出来了。<br>与懒汉式的区别在于懒汉式在加载时不会将自己实例化，而是在第一次被调用时将自己实例化。饿汉式就是加载时已经将自己实例化，等有需要的时候被调用。<br>饿汉式的优点是没有加锁，性能高，但是缺点是一开始装载时就实例化了对象，浪费内存空间。<br>懒汉式的优点正好相反，在第一次被调用时才实例化对象，节省内存。但是因为synchronize关键字，虽然保证了线程安全，但是性能慢</p><h3 id="双检锁式"><a href="#双检锁式" class="headerlink" title="双检锁式"></a>双检锁式</h3><p>前面几种单例方式，都各自有各自的缺点。那么如何既能节省内存空间，又保证线程安全，还不影响性能呢？</p><p>所以在线程安全的懒汉式方法2的基础上，引入了双检锁式方法，可以说，它也是懒汉式方法之一</p><p>源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyDoubleCheckSingleton</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/** 加volatile禁止指令重排序 */</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">LazyDoubleCheckSingleton</span> singleton <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">LazyDoubleCheckSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">LazyDoubleCheckSingleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 检查是否阻塞</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">LazyDoubleCheckSingleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 检查是否要重新创建</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazyDoubleCheckSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>上述代码有几个问题需要解释</p><ol><li>为啥singleton静态变量要用volatile修饰<br>假设上述代码没有volatile关键字，其他不变，那么singleton &#x3D; new LazyDoubleCheckSingleton();该行代码为了充分利用 CPU，会进行重排序优化。它会做三件事<br>a. 为singleton初始化栈空间<br>b. 为LazyDoubleCheckSingleton分配内存空间，实例化对象<br>c. singleton指向LazyDoubleCheckSingleton实例分配的内存空间<br>因为重排序优化的存在，真正执行的过程中，可能会出现a-b-c顺序，也可能出现a-c-b顺序。如果是 a-c-b，singleton指向LazyDoubleCheckSingleton实例分配的内存空间后，就不是 null，另外一个线程进入判断 null时，就会直接返回singleton，但此时LazyDoubleCheckSingleton实例化还有完成，则可能出现意想不到的异常。所以要加上volatile禁止指令重排序</li><li>根据前述线程安全的懒汉式方法2，在synchronized代码块里已经检查了一次singleton &#x3D;&#x3D; null，为啥这次还要再加一次singleton &#x3D;&#x3D; null检查？<br>这是因为在多线程场景下，前面已经说到了，不管线程安全的懒汉式方法1还是方法2，都会可能产生大量线程阻塞现象，因此要在synchronized代码块外面再包一层 singleton &#x3D;&#x3D; null 检查是否会阻塞，如果singleton不为null，就直接返回LazyDoubleCheckSingleton对象，不会产生阻塞。<br>但是这样一来，synchronized代码块里的singleton &#x3D;&#x3D; null检查也不能省略。这是因为可能会同时有两个线程满足了外面一层 singleton &#x3D;&#x3D; null检查，那么如果在synchronized代码块里面没有singleton &#x3D;&#x3D; null检查，则两个线程都会创建LazyDoubleCheckSingleton实例，那就不是单例了。所以synchronized代码块里也要设置singleton &#x3D;&#x3D; null检查。</li></ol><p>从头对上述代码再撸一遍,在多线程情景下,多个线程调用getInstance方法</p><ol><li>如果singleton不为null，则直接返回LazyDoubleCheckSingleton对象，不需要获取锁，但如果多个线程满足singleton &#x3D;&#x3D; null，则进入synchronized代码块</li><li>多个线程执行到synchronized代码块，线程a会上锁，会再次执行singleton &#x3D;&#x3D; null检查，因为LazyDoubleCheckSingleton对象可能已被之前的线程实例化</li><li>其它线程状态会变成monitor，出现阻塞。等线程a结束调用后，状态变回running。但是执行singleton &#x3D;&#x3D; null检查，发现已经不为null了，则不会再创建LazyDoubleCheckSingleton实例，直接返回LazyDoubleCheckSingleton对象即可</li><li>之后所有进入getInstance方法的线程都不会去获取锁，因为它们在执行第一次singleton &#x3D;&#x3D; null检查时，就已经发现LazyDoubleCheckSingleton对象时已经不为null了</li></ol><p>但是只要用到synchronized关键字就总是要上锁，这样对性能总是会有影响，有没有不使用synchronized关键字，就能创建单例对象的方式呢？有~</p><h3 id="登记式"><a href="#登记式" class="headerlink" title="登记式"></a>登记式</h3><p>源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token comment">/**   * 通过该方法获取实例对象   *   * @return 实例对象   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>SINGLETON<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/** 静态成员内部类，该内部类的实例与外部类的实例没有绑定关系，而且只有被调用到才会装载，从而实现了延迟加载 */</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> SINGLETON <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>使用内部类，利用java自身内部类加载特性，在getInstance方法被调用候才去装载SingletonHolder内部类，从而执行实例化过程。这样既实现了延迟加载，避免了饿汉式的内存空间浪费，又避免使用了synchronized关键字，满足性能不受影响的目的。但是，这就是最完美的单例模式创建方式么？</p><h3 id="两种破坏单例的方式"><a href="#两种破坏单例的方式" class="headerlink" title="两种破坏单例的方式"></a>两种破坏单例的方式</h3><p>首先先解释一下，为啥说登记式还不是最完美的一种单例创建方式。</p><p>有两种破坏单例的方法</p><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>利用前述所有单例模式中，构造方法只是private私有关键字修饰的特点，强制使用反射来访问私有构造方法，强行创建第二个单例对象</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Reflection</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@SneakyThrows</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 懒汉式—线程不安全 false</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>        <span class="token string">"懒汉式—线程不安全 &#123;&#125;"</span><span class="token punctuation">,</span>        <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">LazyNoSafeSingleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">LazyNoSafeSingleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 懒汉式—线程安全 方法1 false</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>        <span class="token string">"懒汉式—线程安全 方法1 &#123;&#125;"</span><span class="token punctuation">,</span>        <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">LazySafeSingleton1</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">LazySafeSingleton1</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 懒汉式—线程安全 方法2 false</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>        <span class="token string">"懒汉式—线程安全 方法2 &#123;&#125;"</span><span class="token punctuation">,</span>        <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">LazySafeSingleton2</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">LazySafeSingleton2</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 饿汉式 false</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"饿汉式 &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">HungrySingleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">HungrySingleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 双检锁式 false</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>        <span class="token string">"双检锁式 &#123;&#125;"</span><span class="token punctuation">,</span>        <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">LazyDoubleCheckSingleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>            <span class="token operator">==</span> <span class="token class-name">LazyDoubleCheckSingleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 登记式 false</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"登记式 &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/**   * 利用反射构造新对象   *   * @param clazz 单例类的class   * @param &lt;T> 单例类   * @return 构造的新对象   */</span>  <span class="token annotation punctuation">@SneakyThrows</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取类的显式构造器</span>    <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> construct <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 可访问私有构造器</span>    construct<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 利用反射构造新对象</span>    <span class="token keyword">return</span> construct<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>看源码，把之前所有描述过的单例创建方式通过一个公用的反射方法，构造出新的单例对象，并和每种getInstance方法创建的单例对象做比较，结果如下图</p><p><img src="/img/singleton/C1DB18FF35DA7C569F641CF00D66D64F.jpg" alt="反射破坏单例代码运行结果"></p><p>所有都为false，也就是说都不是单例对象了，都被破坏了。</p><h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4><p>见下列源码</p><blockquote><p>源码中所有的单例类都实现了Serializable接口，否则会报java.io.NotSerializableException异常</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SerialAndDeSerial</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> FILE_PATH <span class="token operator">=</span> <span class="token string">"/Users/wujunshen/Desktop/xxx.txt"</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@SneakyThrows</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 懒汉式—线程不安全 false</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"懒汉式—线程不安全 &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">LazyNoSafeSingleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 懒汉式—线程安全 方法1 false</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"懒汉式—线程安全 方法1 &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">LazySafeSingleton1</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 懒汉式—线程安全 方法2 false</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"懒汉式—线程安全 方法2 &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">LazySafeSingleton2</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 饿汉式 false</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"饿汉式 &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">HungrySingleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 双检锁式 false</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"双检锁式 &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">LazyDoubleCheckSingleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 登记式 false</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"登记式 &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@SneakyThrows</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">boolean</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">T</span> instance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>FILE_PATH<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>FILE_PATH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> instance <span class="token operator">==</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>执行结果如下图<br><img src="/img/singleton/8E0298395BDCC88A4AF27C2E5CC57C8E.jpg" alt="序列化和反序列化破坏单例代码运行结果"></p><p>破坏原因是readObject方法读入对象时它必定会返回一个新的对象实例，肯定指向新的内存地址。</p><p>那么既然有这样两种破坏单例的方式，如何避免这两种破坏呢？难道所有的单例创建方式都不能逃过这两种破坏么？并不是~</p><h3 id="枚举式"><a href="#枚举式" class="headerlink" title="枚举式"></a>枚举式</h3><p>在《Effective Java》第三版中，作者曾经说“<strong>单元素的枚举类型是实现Singleton单例的最佳方法</strong>”，但是他并没有展开说明为啥是最佳方式。因此我试着解释一下。</p><p>看源码，新建一个单元素的SingletonEnum枚举类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">SingletonEnum</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/** 实例 */</span>  INSTANCE<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingletonEnum</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>将该枚举类反编译，可以发现下面这段</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token punctuation">&#123;</span>  INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonEnum</span><span class="token punctuation">(</span><span class="token string">"INSTANCE"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  $VALUES <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SingletonEnum</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>    INSTANCE  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>这说明该枚举类在static静态块中，就对<code>INSTANCE</code>进行了赋值，那和饿汉式写法如出一辙。 都是在一开始加载时，就实例化了单例对象，在这里，就是一开始实例化了<code>SingletonEnum</code>这个单例对象。</p><p>而且我在<code>SingletonEnum</code>枚举类中只声明了<code>INSTANCE</code>这一个<code>SingletonEnum</code>枚举对象元素，没有其他<code>SingletonEnum</code>枚举对象。因此肯定是单例的。</p><p>另外在java里，某个Java类第一次被真正使用到的时候，静态资源被初始化、Java类的加载和被初始化这3个过程都是线程安全的。所以，从上面反编译的内容来看，该枚举类是线程安全的，因为静态资源被初始化、它本身的加载和被初始化过程都已经在上述内容里有所体现。</p><p>因此，枚举式具有天生单例和线程安全两大特性，非常适合做为单例创建方式的一种。但是这还不足够称为它是最佳方式的理由。因为还有前述两种破坏单例的方式，如果它能抵抗这两种破坏方式，才说明它是最佳创建单例方式。so。。。我们接着说</p><h4 id="如何避免反射带来的破坏？"><a href="#如何避免反射带来的破坏？" class="headerlink" title="如何避免反射带来的破坏？"></a>如何避免反射带来的破坏？</h4><p>试看我写的测试方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Reflection</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@SneakyThrows</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    。。。    <span class="token comment">// 枚举 抛异常java.lang.NoSuchMethodException</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"枚举 &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">SingletonEnum</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">SingletonEnum</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 枚举 抛异常java.lang.IllegalArgumentException</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"枚举 &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token function">destroySingletonEnum</span><span class="token punctuation">(</span><span class="token class-name">SingletonEnum</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/**   * 利用反射构造新对象   *   * @param clazz 单例类的class   * @param &lt;T> 单例类   * @return 构造的新对象   */</span>  <span class="token annotation punctuation">@SneakyThrows</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取类的显式构造器</span>    <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> construct <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 可访问私有构造器</span>    construct<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 利用反射构造新对象</span>    <span class="token keyword">return</span> construct<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@SneakyThrows</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">destroySingletonEnum</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取类的显式构造器</span>    <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> construct <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 可访问私有构造器</span>    construct<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 利用反射构造新对象</span>    <span class="token keyword">return</span> construct<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">,</span> <span class="token number">888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>如果执行main方法里第一行方法，会抛出java.lang.NoSuchMethodException异常，错误截图如下</p><p><img src="/img/singleton/687C537BB9A8A918E67332BCADA5376B.jpg" alt="枚举避免单例被破坏"></p><p>意思就是没有找到无参的构造方法，而枚举类都是继承<code>java.lang.Enum</code>对象，去jdk里看<code>java.lang.Enum</code>对象源码，你会发现它本来就是没有无参构造方法的。</p><p><img src="/img/singleton/C24917BC54134376B94F5566331E8400.jpg" alt="jdk中枚举类使用方法"></p><p><img src="/img/singleton/453248695776D8C5D69CDFFA44A7CEB5.jpg" alt="枚举类唯一一个构造方法源码"></p><p>看上面两张截图红框就可以知道，只有这一个<code>（String，int）</code>的构造方法。</p><p>然后我根据这个构造方法，又写了<code>destroySingletonEnum</code>方法，把main方法里第一行测试代码注释掉，直接执行</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"枚举 &#123;&#125;"</span><span class="token punctuation">,</span><span class="token function">destroySingletonEnum</span><span class="token punctuation">(</span><span class="token class-name">SingletonEnum</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>这一行，发现抛出<code>java.lang.IllegalArgumentException</code>异常。如下图</p><p><img src="/img/singleton/B29257A32F1CCE55C814EC02513FF896.jpg" alt="枚举避免单例被破坏-抛异常"></p><p>那么从图中红线<code>Cannot reflectively create enum objects</code>，已经可以知道java不允许我们用反射来创建枚举对象</p><p>从报错信息找过去，发现这句话是在<code>java.lang.reflect.Constructor</code>类的第484行(我指的是java11版本，其他版本可能不在484行，请看下图第二个红框处)，仔细看该行上下文，可知在<code>newInstance</code>方法中做了强制性的判断，如果修饰符是<code>Modifier.ENUM</code>枚举类型，则直接抛出异常，代码如下图红框处</p><p><img src="/img/singleton/977EE6F9B7DBA16F66F7511DE93C97A3.jpg" alt="java反射类java.lang.reflect.Constructor类源码"></p><p>由此可以看出，java不允许我们用反射来创建枚举对象，那么用枚举方式创建单例对象，反射肯定管不到了，不管它怎么来破坏，都会直接抛异常。那么我们再来看看它又是如何避免序列化和反序列化的破坏的</p><h4 id="如何避免序列化和反序列化带来的破坏？"><a href="#如何避免序列化和反序列化带来的破坏？" class="headerlink" title="如何避免序列化和反序列化带来的破坏？"></a>如何避免序列化和反序列化带来的破坏？</h4><p>还是看源码，我写的测试方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SerialAndDeSerial</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> FILE_PATH <span class="token operator">=</span> <span class="token string">"/Users/wujunshen/Desktop/xxx.txt"</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@SneakyThrows</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    。。。    <span class="token comment">// 枚举 true</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"枚举 &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">SingletonEnum</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@SneakyThrows</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">boolean</span> <span class="token function">destroySingleton</span><span class="token punctuation">(</span><span class="token class-name">T</span> instance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>FILE_PATH<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>FILE_PATH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> instance <span class="token operator">==</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>试着运行一遍，你会发现是true，看下图和前面几种单例创建方式的对比</p><p><img src="/img/singleton/9672DD2290D3828BE7D22DFBE0CE9AE9.jpg" alt="枚举避免序列化和反序列化被破坏"></p><p>那说明枚举方式创建单例对象能很好的避免序列化和反序列化带来的破坏，但是为什么会是这样的呢？</p><ul><li><p>首先<br>序列化写入<code>SingletonEnum</code>对象时，每个枚举类型和枚举名字都是唯一的，所以序列化时，仅仅只是把枚举类型和变量名写入到文件中，在读取文件反序列化成对象时，会使用<code>java.lang.Enum</code>对象的<code>valueOf(Class&lt;T&gt; enumType,String name)</code> 方法，根据枚举类型和变量名查找对应的枚举对象。<br>所以，序列化和反序列的过程中，只是写出和读取了枚举类型和变量名，没有任何关于对象的操作。</p></li><li><p>然后<br>从<code>java.io.ObjectInputStream</code>类的<code>readObject</code>方法开始，看源码，它里面有个重写的<code>readObject0</code>方法，在<code>readObject0</code>方法里的第1590-1591行，可以看到(我指的是java11版本，其他版本可能不在1590-1591行这两行，请搜索<code>TC_ENUM</code>查看)</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">case</span> TC_ENUM<span class="token operator">:</span>      <span class="token keyword">return</span> <span class="token function">checkResolve</span><span class="token punctuation">(</span><span class="token function">readEnum</span><span class="token punctuation">(</span>unshared<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>有判断枚举的readEnum方法，再点击进去看，第2029行有(同上，代码行依据版本有不同)</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Enum</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> en <span class="token operator">=</span> <span class="token class-name">Enum</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">)</span>cl<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>是吧，就是根据这个valueOf方法，找到对应的枚举对象，而且我们是单元素枚举类型，怎么查，找到的都是同一个枚举对象。因此程序结果肯定为true</p></li></ul><h4 id="为什么我们可以说单元素的枚举类型是实现Singleton单例的最佳方法？"><a href="#为什么我们可以说单元素的枚举类型是实现Singleton单例的最佳方法？" class="headerlink" title="为什么我们可以说单元素的枚举类型是实现Singleton单例的最佳方法？"></a>为什么我们可以说<strong>单元素的枚举类型是实现Singleton单例的最佳方法</strong>？</h4><p>总结如下</p><ol><li>枚举类创建方式和饿汉式单例创建方式如出一辙，且由于自身特性肯定是线程安全和单例的，且由于和饿汉式一样不需上锁，因此也无性能问题。</li><li>枚举类内部使用Enum类型判断，来禁止用反射创建多个对象，保证单例不会受到破坏。</li><li>枚举类通过对枚举类型和枚举名字的写入和读取，将对象序列化和反序列化，最终使用valueOf方法匹配枚举变量名找到内存中的唯一对象实例，从而禁止用序列化和反序列化构造多个对象，保证单例不会受到破坏。</li></ol><p>基本上单例模式都讲完了，从前述标题可知，大致有6种创建单例对象的方式，如果懒汉式—线程安全方式再细分，其实可以算是7种。但是只有单元素枚举类型创建方式是最好的方式。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可保证内存里只有一个实例，减少内存开销</li><li>避免对资源的多重占用</li><li>设置全局访问点，可优化和共享资源的访问</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>一般没有接口，扩展困难。如果要扩展，除了要修改原来的代码之外，没有第二种途径，违反开闭原则</li><li>并发测试中，单例不利于代码调试。调试过程中，如果单例中代码没有执行完，就不能模拟生成一个新的对象</li><li>单例的功能代码通常写在一个类中，如果设计不合理，就很容易违背单一职责原则</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>创建型模式</tag>
      
      <tag>单例</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka</title>
    <link href="/posts/2591906323.html"/>
    <url>/posts/2591906323.html</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）"></a>主题（Topic）</h3><p>Kafka将一组消息抽象归纳为一个主题（Topic），一个主题就是对消息的一个分类。生产者将消息发送到特定主题，消费者订阅主题或主题的某些分区进行消费</p><h3 id="消息-Message-x2F-Record"><a href="#消息-Message-x2F-Record" class="headerlink" title="消息(Message&#x2F;Record)"></a>消息(Message&#x2F;Record)</h3><p>消息是Kafka通信的基本单位，由一个固定长度的消息头和一个可变长度的消息体构成。老版本中，每一条消息称为Message；在由Java重新实现的客户端中，每一条消息称为Record。</p><h3 id="分区和副本（Partition-amp-Replica）"><a href="#分区和副本（Partition-amp-Replica）" class="headerlink" title="分区和副本（Partition&amp;Replica）"></a>分区和副本（Partition&amp;Replica）</h3><p>Kafka将一组消息归纳为一个主题，而每个主题又被分成一个或多个分区（Partition）</p><p>每个分区由一系列有序、不可变的消息组成，是一个有序队列。每个分区在物理上对应为一个文件夹，分区的命名规则为主题名称后接“—”连接符，之后再接分区编号，分区编号从0开始，编号最大值为分区的总数减1。每个分区又有一至多个副本（Replica），分区的副本分布在集群的不同代理上，以提高可用性。</p><p>从存储角度上分析，分区的每个副本在逻辑上抽象为一个日志（Log）对象，即分区的副本与日志对象是一一对应的。每个 topic 对应的分区数可以在Kafka启动时所加载的配置文件中配置，也可在创建 topic 时指定。当然，客户端还可以在 topic 创建后修改它的分区数。</p><p>理论上说，Partition 数越多吞吐量越高，但这要根据集群实际环境及业务场景而定。同时，Partition 也是Kafka保证消息被顺序消费以及对消息进行负载均衡的基础。<br><strong>Kafka只能保证一个 Partition 之内消息的有序性，并不能保证跨 Partition 消息的有序性。</strong><br>每条消息被追加到相应的 Partition 中，是顺序写磁盘，因此效率非常高，这是Kafka高吞吐率的一个重要保证。同时与传统消息系统不同的是，Kafka并不会立即删除已被消费的消息，由于磁盘的限制，消息也不会一直被存储，因此Kafka提供两种删除老数据的策略</p><ol><li>基于消息已存储的时间长度，</li><li>基于分区的大小。</li></ol><h3 id="Leader和Follower副本"><a href="#Leader和Follower副本" class="headerlink" title="Leader和Follower副本"></a>Leader和Follower副本</h3><p>由于Kafka副本的存在，就需要保证一个分区的多个副本之间数据的一致性，Kafka会选择该分区的一个副本作为Leader副本，而该分区其他副本即为Follower副本，只有Leader副本才负责处理客户端读&#x2F;写请求，Follower副本从Leader副本同步数据。如果没有Leader副本，那就需要所有的副本都同时负责读&#x2F;写请求处理，同时还得保证这些副本之间数据的一致性，假设有n个副本则需要有n×n条通路来同步数据，这样数据的一致性和有序性就很难保证。</p><p>引入Leader副本后客户端只需与Leader副本进行交互，这样数据一致性及顺序性就有了保证。Follower副本从Leader副本同步消息，对于n个副本只需n-1条通路即可，这样就使得系统更加简单而高效。副本Follower与Leader的角色并不是固定不变的，如果Leader失效，通过相应的选举算法将从其他Follower副本中选出新的Leader副本。</p><h3 id="偏移量（offset）"><a href="#偏移量（offset）" class="headerlink" title="偏移量（offset）"></a>偏移量（offset）</h3><p>任何发布到分区的消息会被直接追加到日志文件（分区目录下以“.log”为文件名后缀的数据文件）的尾部，而每条消息在日志文件中的位置都会对应一个按序递增的偏移量。偏移量是一个分区下严格有序的逻辑值，它并不表示消息在磁盘上的物理位置。由于Kafka几乎不允许对消息进行随机读写，因此Kafka并没有提供额外索引机制到存储偏移量，也就是说并不会给偏移量再提供索引。消费者可以通过控制消息偏移量来对消息进行消费，比如可以指定消费的起始偏移量。为了保证消息被顺序消费，消费者已消费的消息对应的偏移量也需要保存。需要说明的是，消费者对消息偏移量的操作并不会影响消息本身的偏移量。旧版消费者将消费偏移量保存到ZooKeeper当中，而新版消费者是将消费偏移量保存到Kafka内部一个 topic 里。当然，消费者也可以自己在外部系统保存消费偏移量，而无需保存到Kafka中。</p><h3 id="日志段（LogSegment）"><a href="#日志段（LogSegment）" class="headerlink" title="日志段（LogSegment）"></a>日志段（LogSegment）</h3><p>一个日志又被划分为多个日志段（LogSegment），日志段是Kafka日志对象分片的最小单位。与日志对象一样，日志段也是一个逻辑概念，一个日志段对应磁盘上一个具体日志文件和两个索引文件。日志文件是以“.log”为文件名后缀的数据文件，用于保存消息实际数据。两个索引文件分别以“.index”和“.timeindex”作为文件名后缀，分别表示消息偏移量索引文件和消息时间戳索引文件。</p><h3 id="代理（broker）"><a href="#代理（broker）" class="headerlink" title="代理（broker）"></a>代理（broker）</h3><p>Kafka集群就是由一个或多个Kafka实例构成，我们将每一个Kafka实例称为代理（Broker），通常也称代理为Kafka服务器（Kafka Server）。在生产环境中Kafka集群一般包括一台或多台服务器，我们可以在一台服务器上配置一个或多个代理。每一个代理都有唯一的标识id，这个id是一个非负整数。在一个Kafka集群中，每增加一个代理就需要为这个代理配置一个与该集群中其他代理不同的id, id值可以选择任意非负整数即可，只要保证它在整个Kafka集群中唯一，这个id就是代理的名字，也就是在启动代理时配置的broker.id对应的值，由于给每个代理分配了不同的brokerId，这样对代理进行迁移就变得更方便，对消费者来说也是透明的，不影响消费者对消息的消费。</p><h3 id="生产者（Producer）"><a href="#生产者（Producer）" class="headerlink" title="生产者（Producer）"></a>生产者（Producer）</h3><p>生产者（Producer）负责将消息发送给broker，也就是向 broker 发送消息的客户端。</p><h3 id="消费者和消费组（Comsumer-amp-ConsumerGroup）"><a href="#消费者和消费组（Comsumer-amp-ConsumerGroup）" class="headerlink" title="消费者和消费组（Comsumer&amp;ConsumerGroup）"></a>消费者和消费组（Comsumer&amp;ConsumerGroup）</h3><p>消费者（Comsumer）以拉取（pull）方式拉取数据，它是消费的客户端。在Kafka中每一个消费者都属于一个特定消费组（ConsumerGroup），可以为每个消费者指定一个消费组，以groupId代表消费组名称，通过group.id配置设置。</p><p>如果不指定消费组，则该消费者属于默认消费组test-consumer-group。同时，每个消费者也有一个全局唯一的id，通过配置项client.id指定，如果客户端没有指定消费者的id, Kafka会自动为该消费者生成一个全局唯一的id，格式为${groupId}-${hostName}-${timestamp}-${UUID前8位字符}。</p><p><strong>同一个主题的一条消息只能被同一个消费组下某一个消费者消费，但不同消费组的消费者可同时消费该消息。</strong></p><p>消费组是Kafka用来实现对一个主题消息进行广播和单播的手段，实现消息广播只需指定各消费者均属于不同的消费组，消息单播则只需让各消费者属于同一个消费组。</p><h3 id="ISR（In-sync-Replica）"><a href="#ISR（In-sync-Replica）" class="headerlink" title="ISR（In-sync Replica）"></a>ISR（In-sync Replica）</h3><p>Kafka在ZooKeeper中动态维护了一个ISR（In-sync Replica），即保存同步的副本列表，该列表中保存的是与Leader副本保持消息同步的所有副本对应的代理节点id。如果一个Follower副本挂机或是落后太多，则该Follower副本节点将从ISR列表中移除。</p><h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><p>Kafka利用ZooKeeper保存相应元数据信息，Kafka元数据信息包括如代理节点信息、Kafka集群信息、旧版消费者信息及其消费偏移量信息、主题信息、分区状态信息、分区副本分配方案信息、动态配置信息等。Kafka在启动或运行过程当中会在ZooKeeper上创建相应节点来保存元数据信息，通过监听机制，使用这些被注册节点所对应的监听器来监听节点元数据的变化，从而由ZooKeeper负责管理维护Kafka集群，同时ZooKeeper可对Kafka集群进行水平扩展及数据迁移。</p><p><img src="/img/kafka/9244F89BDC9EA65E70F362974629327F.jpg" alt="Kafka集群架构图"></p><h2 id="如何实现高可用？"><a href="#如何实现高可用？" class="headerlink" title="如何实现高可用？"></a>如何实现高可用？</h2><p>Kafka 基本架构:由多个 broker 组成，每个 broker 一个节点;创建一个 topic，topic 可划分为多个 partition，每个partition 可存在于不同的 broker 上，每个 partition 就放一部分数据。<br>天然的分布式消息队列，一个 topic 的数据，是分散放在多个节点上，每个节点放一部分数据</p><p>RabbmitMQ 之类，不是分布式消息队列，就是传统的消息队列，只不过提供了一些集群、 HA(High Availability, 高可用性) 的机制而已，因为无论怎么样，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p><p>Kafka 0.8 之后，提供 HA 机制，即 replica（复制） 副本机制。每个 partition 的数据都会同步到其它节点上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。</p><p><img src="/img/kafka/A142B532FB6EC2FE77D6E31B79D1E51B.jpg" alt="高可用实现图"></p><p>写: leader 会负责把数据同步到所有 follower 上去。<br>读: 直接读 leader 上的数据即可。</p><p>只能读写leader，因为如果可以随意读写每个 follower，那么就要关注数据一致性的问题，系统复杂度太高，容易出问题。 Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样可以提高容错性。</p><h2 id="如何实现消息消费幂等，即不被重复消费？"><a href="#如何实现消息消费幂等，即不被重复消费？" class="headerlink" title="如何实现消息消费幂等，即不被重复消费？"></a>如何实现消息消费幂等，即不被重复消费？</h2><p>Kafka 有个 offset 概念，每个消息写进去，都有一个 offset 代表消息序号，然后 consumer 消费数据之后， 每隔一段时间（定时定期），会把自己消费过的消息 offset 提交一下，表示“我已经消费过了，<br>下次我要是重启，就让我从上次消费到的 offset 来继续消费”。</p><p>如果重启直接 kill 进程了，再重启。会导致consumer 有些消息处理了，但没来得及提交 offset。这样重启之后，少数消息会再次消费一次。这就可能引起消息被重复消费的现象</p><p>结合业务有几个办法:</p><ol><li>拿数据写库，先根据主键查，如果数据有了，就别插入了，update 一下。</li><li>拿数据写redis，每次set就行，天然幂等性</li><li>设置个commit id。消费时候，去db或者redis查，如果查不到说明是第一次消费，消费好消息，把commit id写入db或redis。这样如果第二次和之后几次消费，这个commit id查得到，就不做任何消息消费动作。或者就是利用db的主键唯一键，重复插入时候会报错</li></ol><p><img src="/img/kafka/47180D3F2A28B15A859D40235471F369.jpg" alt="实现消息幂等"></p><h2 id="如果保证不丢消息？"><a href="#如果保证不丢消息？" class="headerlink" title="如果保证不丢消息？"></a>如果保证不丢消息？</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>两个参数需要配置:</p><ol><li>在 producer 端设置 acks&#x3D;all:<br>这是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功。</li><li>在 producer 端设置 retries&#x3D;MAX（很大一个值，表示可以无限次重试）:<br>这是要求一旦写入失败，就无限重试，卡在这里。</li></ol><p>这样 leader 接收到消息，所有的 follower 都同步到了消息以后，才算本次写成功。<br>如果没满足此条件，生产者会自动不断的重试，重试无限次。</p><h3 id="Kafka服务"><a href="#Kafka服务" class="headerlink" title="Kafka服务"></a>Kafka服务</h3><p>假设 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，就少了一些数据。</p><p>所以此时至少设置如下 4 个参数：</p><ol><li>给 topic 设置 replication.factor 参数:<br>这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 min.insync.replicas 参数:<br>这个值也必须大于 1，这是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，这样才能确保 leader 挂了还有一个 follower</li><li>同生产者1</li><li>同生产者2</li></ol><p>这样配置后，可保证在 leader 所在的 broker 发生故障，进行 leader 切换时，数据不会丢失。</p><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>只有1种情况 Kafka 消费者会丢消息:</p><p>消费者那边自动提交了 offset， Kafka 服务以为消费者已消费好消息，但消费者才准备处理消息，此时消费者因为暴力停机或其他原因突然挂了，那么此时这条消息就丢失了。</p><p>解决方案和 RabbitMQ 类似，就是关闭自动提交 offset，处理完之后自己手动提交 offset，就可保证数据不丢失。但可能会有重复消费，假设处理完，还没提交 offset，结果消费者挂了，那肯定会再次重复消费一次，所以自己要保证幂等性。</p><p>如果 Kafka 消费者消费到数据之后，将消息写入一个内存的 queue 里做缓冲。此时系统重启的话，会导致有一定几率出现消息丢失情况。</p><p>这种情况就是消息刚被写入内存 queue，然后消费者自动提交 offset之后，内存 queue 碰到系统重启，在queue里的数据还没来得及进行处理就丢失了。</p><h2 id="如何保证消息被消费的顺序？"><a href="#如何保证消息被消费的顺序？" class="headerlink" title="如何保证消息被消费的顺序？"></a>如何保证消息被消费的顺序？</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>和 RabbitMQ类似，假设一个 topic，有三个 partition。生产者向 Kafka 发送三条数据，要求的消费顺序依次是 data1&#x2F;data2&#x2F;data3。</p><p>在写的时候，依次写入同一个 partition 中，这个 partition 中的数据一定是有序的。</p><p>消费者从 partition 中取数据消费时，也一定是有序的。</p><p>但是如果消费者是单线程消费处理，且处理比较耗时的时候，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，吞吐量会很低。因此使用多线程消费消息时候，可能就会产生消费顺序错乱的问题。</p><p><img src="/img/kafka/92E14FC0AF0DF75CE7CEB8748EB694F6.jpg" alt="顺序消费场景"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>写 N 个内存 queue，data1&#x2F;data2&#x2F;data3 按照顺序写入到同一个内存 queue;然后对于 N 个线程，每个线程分别消费一个内存 queue ，这样三条数据都是多线程中同一个线程消费，这样就能保证顺序。见下图示例</p><p><img src="/img/kafka/91B949E193FD5E4E6611163E80803FE7.jpg" alt="顺序消费解决方案"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://gitee.com/shishan100/Java-Interview-Advanced">中华石杉–互联网Java进阶面试训练营</a></p><h2 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a><a href="/Kafka">推荐书单</a></h2>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP和HTTPS</title>
    <link href="/posts/2464482875.html"/>
    <url>/posts/2464482875.html</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器输入url地址到显示主页的过程"><a href="#浏览器输入url地址到显示主页的过程" class="headerlink" title="浏览器输入url地址到显示主页的过程"></a>浏览器输入url地址到显示主页的过程</h2><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li></ol><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址，例如<code>www.baidu.com</code>，其实不是真正意义上的地址。互联网上每台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度网址。所以需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，整个过程就是DNS解析。它实际上充当了一个翻译的角色。<br>实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的?</p><ul><li>DNS解析是一个递归查询的过程<br>首先在本地域名服务器中查询IP地址，如果没有找到，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到baidu的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: <code>com -&gt; baidu.com -&gt; www.baidu.com</code>。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是<code>www.baidu.com.</code>，并不是我多打了一个<code>.</code>，这个<code>.</code>对应的就是根域名服务器，默认情况下所有的网址的最后一位都是<code>.</code>，既然是默认情况，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所以网址真正的解析过程为: <code>. -&gt; .com -&gt; baidu.com. -&gt; www.baidu.com.</code></li><li>DNS优化<br>上文中请求到baidu的IP地址时，经历了多个步骤，这个过程中存在多个请求。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是使用DNS缓存<br>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存</li><li>DNS负载均衡<br>DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但在用户眼里，它需要的只是处理它的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容</li></ul><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p><ul><li>HTTPS协议<br>HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(或TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间，如图</li></ul><p><img src="/img/http/F05A67251F1BD6454342DF465FDE2C01.jpg" alt="SSL所处位置"></p><ul><li>HTTPS过程<br>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS&#x2F;SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS&#x2F;SSL使用了非对称加密、对称加密以及hash等<br>HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡</li></ul><h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80&#x2F;8080, HTTPS协议443)。<br>HTTP请求报文是由三部分组成: <strong>请求行、请求报头和请求正文</strong></p><ul><li><p>请求行<br>格式如下</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Method Request<span class="token operator">-</span><span class="token constant">URL</span> <span class="token constant">HTTP</span><span class="token operator">-</span>Version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>代码示例</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token constant">GET</span> index<span class="token punctuation">.</span>html <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>常用的方法有: GET、POST、PUT、DELETE、OPTIONS、HEAD</p><p>对这些方法说明见下方表格</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">从指定的资源请求数据</td></tr><tr><td align="left">POST</td><td align="left">向指定的资源提交要被处理的数据</td></tr><tr><td align="left">PUT</td><td align="left">上传指定的 URI 表示</td></tr><tr><td align="left">DELETE</td><td align="left">删除指定资源</td></tr><tr><td align="left">HEAD</td><td align="left">与 GET 相同，但只返回 HTTP 报头，不返回文档主体</td></tr><tr><td align="left">OPTIONS</td><td align="left">返回服务器支持的 HTTP 方法</td></tr><tr><td align="left">CONNECTION</td><td align="left">把请求连接转换到透明的 TCP&#x2F;IP 通道</td></tr></tbody></table><p>GET和POST区别</p><ol><li>GET在浏览器回退时是无害的，而POST会再次提交请求</li><li>GET产生的URL地址可以被Bookmark，而POST不可以</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置</li><li>GET请求只能进行url编码，而POST支持多种编码方式</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li><li>GET参数通过URL传递，POST放在Request body中</li></ol></li><li><p>请求报头<br>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具（postman）等。<br>常见的请求报头有: Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Type、Authorization、Cookie、User-Agent等</p></li><li><p>请求正文<br>当使用POST,PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求报头中有一些与请求正文相关的信息，比如现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application&#x2F;json</p></li></ul><h3 id="服务器处理请求并返回HTTP报文"><a href="#服务器处理请求并返回HTTP报文" class="headerlink" title="服务器处理请求并返回HTTP报文"></a>服务器处理请求并返回HTTP报文</h3><p>这部分对应的就是后端工程师眼中的HTTP。后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般由Web服务器进行，Web服务器有Tomcat, Jetty和Netty等等。</p><p>HTTP响应报文也是由三部分组成: <strong>状态码、响应报头和响应报文</strong></p><ul><li><p>状态码<br>如图</p><p><img src="/img/http/D11A9F3FEB34EAEF8E711FCAA1ECE178.jpg" alt="状态码">常见的状态码有:200、204、301、302、304、400、401、403、404、500</p><table><thead><tr><th align="left">状态码</th><th align="left">英文名</th><th align="left">中文描述</th></tr></thead><tbody><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。<br/>一般用于GET与POST请求</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left">无内容。<br/>服务器成功处理，<br/>但未返回内容。<br/>在未更新网页的情况下，<br/>可确保浏览器继续显示当前文档</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">永久移动。<br/>请求的资源已被永久的移动<br/>到新URI，<br/>返回信息会包括新的URI，<br/>浏览器会自动定向到新URI。<br/>今后任何新的请求都应使用新的<br/>URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">临时移动。<br/>与301类似。<br/>但资源只是临时被移动。<br/>客户端应继续使用原有URI</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="left">未修改。<br/>所请求的资源未修改，<br/>服务器返回此状态码时，<br/>不会返回任何资源。<br/>客户端通常会缓存访问过的资源，<br/>通过提供一个头信息指出<br/>客户端希望只返回<br/>在指定日期之后修改的资源</td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">客户端请求的语法错误，<br/>服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">请求要求用户的身份认证</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">服务器理解请求客户端的请求，<br/>但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法根据客户端的请求<br/>找到资源（网页）。<br/>通过此代码，<br/>网站设计人员可设置<br/>“您所请求的资源无法找到”<br/>的个性页面</td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr></tbody></table><p>301和302区别</p><ol><li>301表示被请求url永久转移到新的url；302表示被请求url临时转移到新的url</li><li>301搜索引擎会索引新url和新url页面的内容；302搜索引擎可能会索引旧url和新url的页面内容</li><li>302会发生网址劫持（URL hijacking），302返回码可能会被别人利用，劫持你的网址。因为搜索引擎索引他的网址，他会返回302跳转到你的页面</li></ol></li><li><p>响应报头<br>常见的响应报头字段有: Server、Connection</p></li><li><p>响应报文<br>服务器返回给浏览器的文本信息，通常指HTML、CSS、JS、图片等文件</p></li></ul><h3 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h3><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应尽可能少的减少reflow和repain。其实如果去面试，知道这个步骤是渲染HTML,CSS,JS文件就行</p><h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p>见前述<a href="/posts/2464482875.html#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B">浏览器输入url地址到显示主页的过程</a></p><h3 id="版本描述"><a href="#版本描述" class="headerlink" title="版本描述"></a>版本描述</h3><h4 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h4><p>指定keep-alive来开启持久连接，默认是短连接，浏览器每次请求都要重新建立一次tcp连接（3次握手），结束就释放tcp连接（4次挥手）</p><h4 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h4><p>默认支持长连接，浏览器打开一个网页之后，底层的tcp连接就保持着，不会立马断开，之后加载css、js之类的请求，都会基于这个tcp连接来走。http1.1还支持host头，也就可以支持虚拟主机；而且对断点续传有支持</p><p>浏览器第一次请求一个网站的一个页面时，会打开一个tcp连接，接着在一段时间内都不关闭，接下来这个网页加载css、js、图片大量的请求全部走同一个tcp连接，频繁的发送请求获取响应，最后过了一段时间，全部结束了，才会去释放那一个tcp连接。大幅度提升了复杂网页打开的速度和性能</p><h4 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h4><p>支持多路复用，基于一个tcp连接并行发送多个请求以及接收响应，解决了http1.1对同一时间同一个域名的请求有限制的问题。二进制分帧，将传输数据拆分为更小的帧（数据包），frame（数据包，帧），提高性能，实现低延迟、高吞吐</p><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>http本身没什么所谓的长连接短连接之说，说白了都是http（应用层）下层的tcp（传输层）连接是长连接还是短连接，tcp连接保持长连接，那么多个http请求和响应都可以通过这一个链接来走。http1.1之后，默认都是长连接了，就底层都是一个网页一个tcp连接，一个网页的所有图片、css、js的资源加载，都走底层一个tcp连接，来多次http请求都可以</p><p>http1.0时，底层的tcp是短连接，一个网页发起的请求，每个请求都是先tcp三次握手，然后发送请求，获取响应，然后tcp四次挥手断开连接；每个请求，都会先连接再断开。短连接，建立连接之后，发送个请求，直接连接就给断开了</p><p>http1.1，tcp长连接，tcp三次握手，建立了连接，无论有多少次请求都是走一个tcp连接的，走了n多次请求之后，然后tcp连接被释放掉了</p><h2 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h2><p>见前述<a href="/posts/2464482875.html#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B">浏览器输入url地址到显示主页的过程</a></p><p>接下来具体说明加密解密过程</p><p><img src="/img/http/9DBB5808358BC238A8B609A4DC0DEECE.jpg" alt="https协议加解密过程"></p><ol><li>浏览器把自己支持的加密规则发送给网站</li><li>网站从这套加密规则里选出来一套加密算法和hash算法，然后把自己的身份信息用证书的方式发回给浏览器，证书里有网站地址、加密公钥、证书颁发机构</li><li>浏览器验证证书的合法性，然后浏览器地址栏上会出现一把小锁；浏览器接着生成一串随机数密码，然后用证书里的公钥进行加密，这块走的非对称加密；用约定好的hash算法生成握手消息的hash值，然后用密码对消息进行加密，然后把所有东西都发给网站，这块走的是对称加密</li><li>网站，从消息里面可以取出来公钥加密后的随机密码，用本地的私钥对消息解密取出来密码，然后用密码解密浏览器发来的握手消息，计算消息的hash值，并验证与浏览器发送过来的hash值是否一致，最后用密码加密一段握手消息，发给浏览器</li><li>浏览器解密握手消息，然后计算消息的hash值，如果跟网站发来的hash一样，握手就结束，之后所有的数据都会由之前浏览器生成的随机密码，然后用对称加密来进行进行加密</li></ol><p>常用的非对称加密是RSA算法，对称加密是AES、RC4等，hash算法就是MD5</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp">HTTP方法: GET 对比 POST</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>HTTP</tag>
      
      <tag>HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程问题整理(下)</title>
    <link href="/posts/2319386778.html"/>
    <url>/posts/2319386778.html</url>
    
    <content type="html"><![CDATA[<h2 id="11-为什么调用start-方法时会执行run-方法，而不能直接调用run-方法？"><a href="#11-为什么调用start-方法时会执行run-方法，而不能直接调用run-方法？" class="headerlink" title="11. 为什么调用start()方法时会执行run()方法，而不能直接调用run()方法？"></a>11. 为什么调用start()方法时会执行run()方法，而不能直接调用run()方法？</h2><p>调用start()方法时，将会创建新的线程，并且执行在run()方法里的代码。但如果直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码</p><h2 id="12-Java中怎样唤醒一个阻塞的线程？"><a href="#12-Java中怎样唤醒一个阻塞的线程？" class="headerlink" title="12. Java中怎样唤醒一个阻塞的线程？"></a>12. Java中怎样唤醒一个阻塞的线程？</h2><p>如果是IO阻塞，创建线程时，加一个数量的阈值，超过该值后则不再创建。或者为每个线程设置标志变量标志该线程是否已经束，三就是直接加入线程组去管理</p><p>如果线程因为调用 wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它</p><h2 id="13-Java中CycliBarriar和CountdownLatch有什么区别？"><a href="#13-Java中CycliBarriar和CountdownLatch有什么区别？" class="headerlink" title="13. Java中CycliBarriar和CountdownLatch有什么区别？"></a>13. Java中CycliBarriar和CountdownLatch有什么区别？</h2><p>CountdownLatch: 一个线程(或者多个)，等待另外N个线程完成某个事情之后才能执行。</p><p>CycliBarriar: N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</p><p>这样应该就清楚一点了，对于CountDownLatch来说，重点是那个“一个线程”, 是它在等待，而另外那N的线程在把“某个事情”做完之后可以继续等待，也可以终止。</p><p>而对于CyclicBarrier来说，重点是那N个线程，他们之间任何一个没有完成，所有的线程都必须等待。</p><ol><li>CyclicBarrier可以多次使用，CountDownLatch只能用一次（为0后不可变）</li><li>Barrier是等待指定数量线程到达再继续处理；Latch是等待指定事件变为指定状态后发生再继续处理，对于CountDown就是计数减为0的事件，但你也可以实现或使用其他Latch，就不是这个事件了</li><li>Barrier是等待指定数量任务完成，Latch是等待其他任务完成指定状态的改变再继续</li></ol><h2 id="14-什么是不可变对象，它对写并发应用有什么帮助？"><a href="#14-什么是不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="14. 什么是不可变对象，它对写并发应用有什么帮助？"></a>14. 什么是不可变对象，它对写并发应用有什么帮助？</h2><p>不可变对象（英语：Immutable object）是一种对象,在被创造之后，它的状态就不可以被改变。</p><p>由于它不可更改，并发时不需要其他额外的同步保证，故相比其他的锁同步等方式的并发性能要好。</p><p>衍生问题：<strong>为什么String是不可变的？</strong></p><ul><li>字符串常量池的需要<br>字符串常量池(String pool, String intern pool, String保留池) 是Java堆内存中一个特殊的存储区域, 当创建一个String对象时,假如此字符串值已经存在于常量池中,则不会创建一个新的对象,而是引用已经存在的对象。</li></ul><p>如下面的代码所示,将会在堆内存中只创建一个实际String对象</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>  <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>示意图如下所示</p><p><img src="/img/question/B320858759DE18DD070CA4862177F09C.jpg" alt="字符串常量池"></p><p>假若字符串对象允许改变,那么将会导致各种逻辑错误,比如改变一个对象会影响到另一个独立对象. 严格来说，这种常量池的思想,是一种优化手段.</p><p>请思考: <strong>假若代码如下所示，s1和s2还会指向同一个实际的String对象吗?</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1<span class="token operator">=</span> <span class="token string">"ab"</span> <span class="token operator">+</span> <span class="token string">"cd"</span><span class="token punctuation">;</span>  <span class="token class-name">String</span> s2<span class="token operator">=</span> <span class="token string">"abc"</span> <span class="token operator">+</span> <span class="token string">"d"</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>也许这个问题违反新手的直觉, 但是考虑到现代编译器会进行常规的优化, 所以他们都会指向常量池中的同一个对象. 或者,你可以用 jd-gui 之类的工具查看一下编译后的class文件</p><ul><li>允许String对象缓存HashCode<br>Java中String对象的哈希码被频繁地使用, 比如在hashMap 等容器中。</li></ul><p>字符串不变性保证了hash码的唯一性,因此可以放心地进行缓存.这也是一种性能优化手段,意味着不必每次都去计算新的哈希码. 在String类的定义中有如下代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment">//用来缓存HashCode  </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><ul><li>安全性<br>String被许多的Java类(库)用来当做参数,例如 网络连接地址URL,文件路径path,还有反射机制所需要的String参数等, 假若String不是固定不变的,将会引起各种安全隐患。</li></ul><p>假如有如下的代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSecure</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SecurityException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token comment">// 如果在其他地方可以修改String,那么此处就会引起各种预料不到的问题/错误</span>     <span class="token function">causeProblem</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="15-多线程环境中遇到的常见问题是什么？如何解决？"><a href="#15-多线程环境中遇到的常见问题是什么？如何解决？" class="headerlink" title="15. 多线程环境中遇到的常见问题是什么？如何解决？"></a>15. 多线程环境中遇到的常见问题是什么？如何解决？</h2><p>多线程和并发程序中常遇到的有Memory-interface、竞争条件、死锁、活锁和饥饿。</p><h3 id="Memory-interface"><a href="#Memory-interface" class="headerlink" title="Memory-interface"></a><strong>Memory-interface</strong></h3><p>（暂无资料）我艹~</p><h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a><strong>竞争条件</strong></h3><p>见<a href="/posts/1239518142.html#9-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%EF%BC%9F%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%E5%92%8C%E8%A7%A3%E5%86%B3%E7%AB%9E%E4%BA%89%EF%BC%9F">并发编程问题整理(中)</a>的第9题</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h3><p>见<a href="/posts/1239518142.html#6-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%AA%E7%94%A8Java%E7%BC%96%E5%86%99%E7%9A%84%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%9F">并发编程问题整理(中)</a>中的第6题</p><h3 id="活锁-livelock"><a href="#活锁-livelock" class="headerlink" title="活锁(livelock)"></a>活锁(livelock)</h3><ul><li><p>概念<br>指事物1可以使用资源，但它让其他事物先使用资源；事物2可以使用资源，但它也让其他事物先使用资源，于是两者一直谦让，都无法使用资源。活锁有一定几率解开。而死锁（deadlock）是无法解开的</p></li><li><p>解决<br>避免活锁的简单方法是采用先来先服务的策略。当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁</p></li></ul><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><ul><li><p>概念<br>是指如果事务T1封锁了数据R,事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁后，系统首先批准了T3的请 求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……T2可能永远等待，这就是饥饿</p></li><li><p>解决<br>用公平锁，每一个调用lock()的线程都会进入一个队列，当解锁后，只有队列里的第一个线程被允许锁住Farlock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部</p></li></ul><p>代码示例<br>公平锁类(FairLock.java)</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FairLock</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">QueueObject</span><span class="token punctuation">></span></span> waitingThreads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">boolean</span> isLocked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">Thread</span> lockingThread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">QueueObject</span> queueObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueueObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> isLockedForThisThread <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      waitingThreads<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>queueObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>isLockedForThisThread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        isLockedForThisThread <span class="token operator">=</span> isLocked <span class="token operator">||</span> waitingThreads<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> queueObject<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLockedForThisThread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          isLocked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          waitingThreads<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>queueObject<span class="token punctuation">)</span><span class="token punctuation">;</span>          lockingThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        queueObject<span class="token punctuation">.</span><span class="token function">doWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          waitingThreads<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>queueObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">throw</span> e<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lockingThread <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token string">"Calling thread has not locked this lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    isLocked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    lockingThread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>waitingThreads<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      waitingThreads<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doNotify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>队列对象类(QueueObject.java)</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QueueObject</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">boolean</span> isNotified <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">doWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>isNotified<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>isNotified <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">doNotify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>isNotified <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>说明</p><blockquote><p>首先lock()方法不再声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。 FairLock新创建一个QueueObject的实例，并对每个调用lock()的线程进行入队列。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，用以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现了FairLock公平性。<br>注意，在同一个同步块中，锁状态依然被检查和设置，以避免出现滑漏条件。还有，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个调用unlock()并随之调用 queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在 synchronized(this)块之外，以避免被monitor嵌套锁死，所以只要没有线程在lock方法的 synchronized(this)块中执行，另外的线程都可以被解锁。<br>最后，注意到queueObject.doWait()在try&#x2F;catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除</p></blockquote><h2 id="16-在java中绿色线程和本地线程区别？"><a href="#16-在java中绿色线程和本地线程区别？" class="headerlink" title="16. 在java中绿色线程和本地线程区别？"></a>16. 在java中绿色线程和本地线程区别？</h2><p>绿色线程执行用户级别的线程，且一次只使用一个OS线程。本地线程用的是OS线程系统，在每个JAVA线程中使用一个OS线程。在执行java时，可通过使用-green或-native标志来选择所用线程是绿色还是本地</p><h2 id="17-线程与进程的区别？"><a href="#17-线程与进程的区别？" class="headerlink" title="17. 线程与进程的区别？"></a>17. 线程与进程的区别？</h2><p>线程是指进程内的一个执行单元,也是进程内的可调度实体.</p><p>与进程的区别</p><ul><li>地址空间<br>进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间</li><li>资源拥有<br>进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源</li><li>线程是处理器调度的基本单位,但进程不是</li><li>二者均可并发执行</li></ul><p>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。进程和线程的区别在于：</p><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。</p><p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p><p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行</p><h2 id="18-什么是多线程中的上下文切换？"><a href="#18-什么是多线程中的上下文切换？" class="headerlink" title="18. 什么是多线程中的上下文切换？"></a>18. 什么是多线程中的上下文切换？</h2><p>操作系统管理很多进程的执行。有些进程是来自各种程序、系统和应用程序的单独进程，而某些进程来自被分解为很多进程的应用或程序。当一个进程从内核中移出， 另一个进程成为活动的，这些进程之间便发生了上下文切换。操作系统必须记录重启进程和启动新进程使之活动所需要的所有信息。这些信息被称作上下文，它描述 了进程的现有状态。当进程成为活动的，它可以继续从被抢占的位置开始执行。</p><p>当线程被抢占时，就会发生线程之间的上下文切换。如果线程属于相同的进程，它们共享相同的地址空间，因为线程包含在它们所属于的进程的地址空间内。这样，进程需要恢复的多数信息对于线程而言是不需要的。尽管进程和它的线程共享了很多内容，但最为重要的是其地址空间和资源，有些信息对于线程而言是本地且唯一 的，而线程的其他方面包含在进程的各个段的内部</p><h2 id="19-死锁与活锁的区别，死锁与饥饿的区别？"><a href="#19-死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="19. 死锁与活锁的区别，死锁与饥饿的区别？"></a>19. 死锁与活锁的区别，死锁与饥饿的区别？</h2><p><strong>死锁</strong>: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生 了死锁，这些永远在互相等待的进程称为死锁进程。 由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象: 死锁</p><p>虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件</p><ul><li><strong>互斥条件</strong><br>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放</li><li><strong>请求和保持条件</strong><br>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放</li><li><strong>不剥夺条件</strong><br>指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</li><li><strong>环路等待条件</strong><br>指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源</li></ul><p><strong>活锁</strong></p><p>指事物1可以使用资源，但它让其他事物先使用资源；事物2可以使用资源，但它也让其他事物先使用资源，于是两者一直谦让，都无法使用资源。</p><p>活锁有一定几率解开。而死锁（deadlock）是无法解开的。</p><p>避免活锁的简单方法是采用先来先服务的策略。当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁</p><p><strong>死锁与饥饿的区别？</strong><br>见前文第15题</p><h2 id="20-Java中用到的线程调度算法是什么？"><a href="#20-Java中用到的线程调度算法是什么？" class="headerlink" title="20. Java中用到的线程调度算法是什么？"></a>20. Java中用到的线程调度算法是什么？</h2><p>计算机通常只有一个CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU的使用权才能执行指令. 所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得CPU的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待CPU,JAVA虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配CPU的使用权</p><p>java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。</p><p>一个线程会因为以下原因而放弃CPU</p><ul><li>java虚拟机让当前线程暂时放弃CPU，转到就绪状态，使其它线程获得运行机会</li><li>当前线程因为某些原因而进入阻塞状态</li><li>线程结束运行</li></ul><p>需要注意的是，线程的调度不是跨平台的，它不仅仅取决于java虚拟机，还依赖于操作系统。在某些操作系统中，只要运行中的线程没有遇到阻塞，就不会放弃CPU；</p><p>在某些操作系统中，即使线程没有遇到阻塞，也会运行一段时间后放弃CPU，给其它线程运行的机会。 java的线程调度是不分时的，同时启动多个线程后，不能保证各个线程轮流获得均等的CPU时间片。 如果希望明确地让一个线程给另外一个线程运行的机会，可以采取以下办法之一。</p><p>调整各个线程的优先级</p><ul><li>让处于运行状态的线程调用Thread.sleep()方法</li><li>让处于运行状态的线程调用Thread.yield()方法</li><li>让处于运行状态的线程调用另一个线程的join()方法</li></ul><h2 id="21-在Java中什么是线程调度？"><a href="#21-在Java中什么是线程调度？" class="headerlink" title="21. 在Java中什么是线程调度？"></a>21. 在Java中什么是线程调度？</h2><p>见上一题</p><h2 id="22-在线程中，怎么处理不可捕捉异常？"><a href="#22-在线程中，怎么处理不可捕捉异常？" class="headerlink" title="22. 在线程中，怎么处理不可捕捉异常？"></a>22. 在线程中，怎么处理不可捕捉异常？</h2><p>捕捉异常有两种方法</p><ol><li>把线程的错误捕捉到，往上抛</li><li>通过线程池工厂，把异常捕捉到，uncaughtException往log4j写错误日志</li></ol><p>示例代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"throwing runtimeException....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>当线程代码抛出运行级别异常之后，线程会中断。主线程不受这个影响，不会处理这个，而且根本不能捕捉到这个异常，仍然继续执行自己的代码</p><p>方法1代码示例</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>wujunshen<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">TestThread</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutorService</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Future</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">ExceptionUtils</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestMain</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">TestThread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">ExecutorService</span> exec <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> exec<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>      exec<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 主要是这句话起了作用，调用get()方法，异常重抛出，包装在ExecutorException</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 这里可以把线程的异常继续抛出去</span>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>方法2代码示例<br>HandlerThreadFactory.java</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ThreadFactory</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>jetbrains<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">NotNull</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HandlerThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> <span class="token class-name">Runnable</span> runnable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">MyUncaughtExceptionHandler</span> myUncaughtExceptionHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">setUncaughtExceptionHandler</span><span class="token punctuation">(</span>myUncaughtExceptionHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>MyUncaughtExceptionHandler.java</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyUncaughtExceptionHandler</span> <span class="token keyword">implements</span> <span class="token class-name">Thread<span class="token punctuation">.</span>UncaughtExceptionHandler</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">uncaughtException</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"write logger here:&#123;&#125;"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>TestMain.java</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>wujunshen<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">TestThread</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutorService</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">ExceptionUtils</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestMain</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">TestThread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">ExecutorService</span> exec <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HandlerThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      exec<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="23-什么是线程组，为什么在Java中不推荐使用？"><a href="#23-什么是线程组，为什么在Java中不推荐使用？" class="headerlink" title="23. 什么是线程组，为什么在Java中不推荐使用？"></a>23. 什么是线程组，为什么在Java中不推荐使用？</h2><p>ThreadGroup线程组表示一个线程的集合。此外，线程组也可以包含其他线程组。线程组构成一棵树，在树中，除了初始线程组外，每个线程组都有一个父线程组。</p><p>允许线程访问有关自己的线程组的信息，但是不允许它访问有关其线程组的父线程组或其他任何线程组的信息。线程组的目的就是对线程进行管理</p><h3 id="线程组为什么不推荐使用"><a href="#线程组为什么不推荐使用" class="headerlink" title="线程组为什么不推荐使用"></a><strong>线程组为什么不推荐使用</strong></h3><p>节省频繁创建和销毁线程的开销，提升线程使用效率。</p><p>衍生问题: <strong>线程组和线程池的区别在哪里？</strong></p><p>一个线程的周期分为：创建、运行、销毁三个阶段。处理一个任务时，首先创建一个任务线程，然后执行任务，完了，销毁线程。而线程处于运行状态的时候，才是真的在处理我们交给它的任务，这个阶段才是有效运行时间。所以，我们希望花在创建和销毁线程的资源越少越好。如果不销毁线程，而这个线程又不能被其他的任务调用，那么就会出现资源的浪费。为了提高效率，减少创建和销毁线程带来时间和空间上的浪费，出现了线程池技术。这种技术是在开始就创建一定量的线程，批量处理一类任务，等待任务的到来。任务执行完毕后，线程又可以执行其他的任务。等不再需要线程的时候，就销毁。这样就省去了频繁创建和销毁线程的麻烦</p><h2 id="24-为什么使用Executor框架比使用应用创建和管理线程好？"><a href="#24-为什么使用Executor框架比使用应用创建和管理线程好？" class="headerlink" title="24. 为什么使用Executor框架比使用应用创建和管理线程好？"></a>24. 为什么使用Executor框架比使用应用创建和管理线程好？</h2><p>大多数并发应用程序是以执行任务（task）为基本单位进行管理的。通常情况下，我们会为每个任务单独创建一个线程来执行。</p><p>这样会带来两个问题</p><ol><li>大量的线程（&gt;100）会消耗系统资源，使线程调度的开销变大，引起性能下降</li><li>对于生命周期短暂的任务，频繁地创建和消亡线程并不是明智的选择。因为创建和消亡线程的开销可能会大于使用多线程带来的性能好处</li></ol><p>一种更加合理的使用多线程的方法是使用线程池（Thread Pool）。 java.util.concurrent 提供了一个灵活的线程池实现：Executor 框架。这个框架可以用于异步任务执行，而且支持很多不同类型的任务执行策略。它还为任务提交和任务执行之间的解耦提供了标准的方法，为使用 Runnable 描述任务提供了通用的方式。 Executor的实现还提供了对生命周期的支持和hook 函数，可以添加如统计收集、应用程序管理机制和监视器等扩展。</p><p>在线程池中执行任务线程，可以重用已存在的线程，免除创建新的线程。这样可以在处理多个任务时减少线程创建、消亡的开销。同时，在任务到达时，工作线程通常已经存在，用于创建线程的等待时间不会延迟任务的执行，因此提高了响应性。通过适当的调整线程池的大小，在得到足够多的线程以保持处理器忙碌的同时，还可以防止过多的线程相互竞争资源，导致应用程序在线程管理上耗费过多的资源</p><h2 id="25-在Java中Executor和Executors的区别？"><a href="#25-在Java中Executor和Executors的区别？" class="headerlink" title="25. 在Java中Executor和Executors的区别？"></a>25. 在Java中Executor和Executors的区别？</h2><p><strong>Executor是接口</strong>，是用来执行 Runnable 任务的；它只定义一个方法- execute(Runnable command)；执行 Ruannable 类型的任务。</p><p><strong>Executors是类</strong>，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。</p><p><strong>Executors几个重要方法</strong></p><ul><li>callable(Runnable task)<br>将 Runnable 的任务转化成Callable的任务</li><li>newSingleThreadExecutor()<br>产生一个ExecutorService对象，这个对象只有一个线程可用来执行任务，若任务多于一个，任务将按先后顺序执行</li><li>newCachedThreadPool()<br>产生一个ExecutorService对象，这个对象带有一个线程池，线程池的大小会根据需要调整，线程执行完任务后返回线程池，供执行下一次任务使用</li><li>newFixedThreadPool(int poolSize)<br>产生一个ExecutorService对象，这个对象带有一个大小为poolSize的线程池，若任务数量大于poolSize，任务会被放在一个queue里顺序执行</li><li>newSingleThreadScheduledExecutor()<br>产生一个ScheduledExecutorService对象，这个对象的线程池大小为1，若任务多于一个，任务将按先后顺序执行</li><li>newScheduledThreadPool(int poolSize)<br>产生一个ScheduledExecutorService对象，这个对象的线程池大小为poolSize，若任务数量大于poolSize，任务会在一个queue里等待执行</li></ul><h2 id="26-如何在Windows和Linux上查找哪个线程使用的CPU时间最长？"><a href="#26-如何在Windows和Linux上查找哪个线程使用的CPU时间最长？" class="headerlink" title="26. 如何在Windows和Linux上查找哪个线程使用的CPU时间最长？"></a>26. 如何在Windows和Linux上查找哪个线程使用的CPU时间最长？</h2><p>其实就是找CPU占有率最高的那个线程</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>任务管理器里面看，如下图<br><img src="/img/question/9479CBE133978F6607FDEE86FE7FAD2C.jpg" alt="Windows任务管理器"></p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>可以用下面的命令将cpu占用率高的线程找出来</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token operator">$</span> ps H <span class="token operator">-</span>eo user<span class="token punctuation">,</span>pid<span class="token punctuation">,</span>ppid<span class="token punctuation">,</span>tid<span class="token punctuation">,</span>time<span class="token punctuation">,</span><span class="token operator">%</span>cpu<span class="token punctuation">,</span>cmd –sort<span class="token operator">=</span><span class="token operator">%</span>cpu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>这个命令首先指定参数’H’，显示线程相关的信息，格式输出中包含</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">user<span class="token punctuation">,</span>pid<span class="token punctuation">,</span>ppid<span class="token punctuation">,</span>tid<span class="token punctuation">,</span>time<span class="token punctuation">,</span><span class="token operator">%</span>cpu<span class="token punctuation">,</span>cmd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>然后再用%cpu字段进行排序。这样就可以找到占用处理器的线程了</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://www.ituring.com.cn/article/111835">Java 多线程面试问题汇总(2014年原创)</a></p></li><li><p><a href="https://zh-wikipedia.mirror.wit.im/w/index.php?search=%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98&title=Special:%E6%90%9C%E7%B4%A2">生产者消费者问题(维基百科中文)</a></p></li><li><p><a href="https://baike.baidu.com/item/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">生产者消费者问题(百度百科)</a></p></li><li><p><a href="https://zh-wikipedia.mirror.wit.im/w/index.php?search=%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98&title=Special:%E6%90%9C%E7%B4%A2&go=%E5%89%8D%E5%BE%80">哲学家就餐问题(维基百科中文)</a></p></li><li><p><a href="https://baike.baidu.com/item/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家就餐问题(百度百科)</a></p></li><li><p><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html">三个实例演示Java Thread Dump日志分析</a></p></li><li><p><a href="https://gitee.com/darkranger/beating-interviewer/tree/master/src/main/java/com/wujunshen/thread">本文所有示例源码地址</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁</tag>
      
      <tag>线程</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程问题整理(中)</title>
    <link href="/posts/1239518142.html"/>
    <url>/posts/1239518142.html</url>
    
    <content type="html"><![CDATA[<p>接<a href="http://www.wujunshen.cn/2022/05/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%B8%8A)/">并发编程问题整理(上)</a>继续</p><h2 id="6-如何解决一个用Java编写的会导致死锁的程序？"><a href="#6-如何解决一个用Java编写的会导致死锁的程序？" class="headerlink" title="6. 如何解决一个用Java编写的会导致死锁的程序？"></a>6. 如何解决一个用Java编写的会导致死锁的程序？</h2><p>Java线程死锁问题往往和一个被称之为哲学家就餐的问题相关联</p><blockquote><p>注：有关哲学家就餐的问题，可查阅维基百科网址<a href="https://zh-wikipedia.mirror.wit.im/w/index.php?search=%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98&title=Special:%E6%90%9C%E7%B4%A2&go=%E5%89%8D%E5%BE%80">哲学家就餐问题</a>和百度百科网址<a href="https://baike.baidu.com/item/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家就餐问题</a></p></blockquote><p>导致死锁的根源在于不适当地运用“synchronized”关键词来管理线程对特定对象的访问</p><p>“synchronized”关键词的作用是，确保在某个时刻只有一个线程被允许执行特定的代码块，因此，被允许执行的线程首先必须拥有对变量或对象的排他性的访问权。当线程访问对象时，线程会给对象加锁，而这个锁导致其它也想访问同一对象的线程被阻塞，直至第一个线程释放它加在对象上的锁。由于这个原因，在使用“synchronized”关键词时，很容易出现两个线程互相等待对方做出某个动作的情形</p><p>死锁程序例子</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">ExceptionUtils</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLock</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> O_1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> O_2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">DeadLock</span> td1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">DeadLock</span> td2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    td1<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    td2<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>td1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>td2<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"flag=&#123;&#125;"</span><span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>O_1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>          <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>O_2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>O_2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>          <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>O_1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>说明</p><ol><li>当类的对象flag&#x3D;1时（T1），先锁定O_1,睡眠500毫秒，然后锁定O_2</li><li>而T1在睡眠的时候另一个flag&#x3D;0的对象（T2）线程启动，先锁定O_2,睡眠500毫秒，等待T1释放O_1</li><li>T1睡眠结束后需要锁定O_2才能继续执行，而此时O_2已被T2锁定</li><li>T2睡眠结束后需要锁定O_1才能继续执行，而此时O_1已被T1锁定</li><li>T1、T2相互等待，都需要对方锁定的资源才能继续执行，从而死锁</li></ol><p>避免死锁的一个通用的经验法则是: 当几个线程都要访问共享资源A、B、C时，保证使每个线程都按照同样的顺序去访问它们，比如都先访问A，再访问B和C</p><p>如把<code> Thread t2 = new Thread(td2);</code> 改成 <code>Thread t2 = new Thread(td1);</code></p><p>还有一种方法是对对象进行synchronized，加大锁定的粒度，如上面的例子中使得进程锁定当前对象，而不是逐步锁定当前对象的两个子对象O_1和O_2。这样就在t1锁定O_1之后， 即使发生休眠，当前对象仍然被t1锁定，t2不能打断t1去锁定O_2，等t1休眠后再锁定O_2，获取资源，执行成功。然后释放当前对象t2，接着t1继续运行。</p><p>代码如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">ExceptionUtils</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLock</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">DeadLock</span> td1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">DeadLock</span> td2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    td1<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    td2<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>td1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>td2<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"flag=&#123;&#125;"</span><span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>说明</p><p>代码修改成<code>public synchronized void run()&#123;..&#125;</code>,去掉子对象锁定。对于一个成员方法加synchronized关键字，实际上是以这个成员方法所在的对象本身作为对象锁。此例中，即对td1，td2这两个Deadlock对象进行加锁</p><p>第三种解决死锁的方法是使用实现Lock接口的重入锁类（ReentrantLock），代码如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Lock</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantLock</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">ExceptionUtils</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLock</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">DeadLock</span> td1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">DeadLock</span> td2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    td1<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    td2<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>td1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>td2<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"flag=&#123;&#125;"</span><span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>说明</p><p>代码行<code>lock.tryLock()</code>是测试对象操作是否已在执行中，如果已在执行中则不再执行此对象操作，立即返回false，达到忽略对象操作的效果</p><h2 id="7-什么是原子操作，Java中的原子操作是什么？"><a href="#7-什么是原子操作，Java中的原子操作是什么？" class="headerlink" title="7. 什么是原子操作，Java中的原子操作是什么？"></a>7. 什么是原子操作，Java中的原子操作是什么？</h2><p>所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间切换到另一个线程。</p><p>java中的原子操作介绍</p><p>jdk1.5的包为java.util.concurrent.atomic</p><p>这个包里面提供了一组原子类。其基本特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性。</p><p>即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，但不会阻塞线程（synchronized 会把别的等待的线程挂，或者说只是在硬件级别上阻塞了)</p><p>其中的类可以分成4组</p><ul><li>AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference</li><li>AtomicIntegerArray，AtomicLongArray</li><li>AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</li><li>AtomicMarkableReference，AtomicStampedReference，AtomicReferenceArray</li></ul><p>Atomic类的作用</p><ul><li>使得让对单一数据的操作，实现了原子化</li><li>使用Atomic类构建复杂的，无需阻塞的代码</li><li>访问对2个或2个以上的atomic变量（或者对单个atomic变量进行2次或2次以上的操作）通常认为是需要同步的，以达到让这些操作能被作为一个原子单元</li></ul><p>AtomicBoolean&#x2F;AtomicInteger&#x2F;AtomicLong&#x2F;AtomicReference这四种基本类型用来处理布尔，整数，长整数，对象四种数据</p><ul><li>构造函数（两个构造函数）<ul><li>默认的构造函数: 初始化的数据分别是false，0，0，null</li><li>带参构造函数: 参数为初始化的数据</li></ul></li><li>set()和get()方法: 可以原子地设定和获取atomic的数据。类似于volatile，保证数据会在主存中设置或读取</li><li>getAndSet()方法<ul><li>原子的将变量设定为新数据，同时返回先前的旧数据</li><li>其本质是get()操作，然后做set()操作。尽管这2个操作都是atomic，但是他们合并在一起的时候，就不是atomic。在Java的源程序的级别上，如果不依赖synchronized的机制来完成这个工作，是不可能的。只有依靠native方法才可以</li></ul></li><li>compareAndSet()和weakCompareAndSet()方法<ul><li>这两个方法都是conditional modifier方法。这2个方法接受2个参数，一个是期望数据(expected)，一个是新数据(new)；如果atomic里面的数据和期望数据一致，则将新数据设定给atomic的数据，返回true，表明成功；否则就不设定，并返回false</li></ul></li><li>对于AtomicInteger、AtomicLong还提供了一些特别的方法。getAndIncrement()、incrementAndGet()、getAndDecrement()、decrementAndGet ()、addAndGet()、getAndAdd()以实现一些加法，减法原子操作(注意 –i、++i不是原子操作，其中包含有3个操作步骤：第一步，读取i；第二步，加1或减1；第三步：写回内存)</li></ul><p>例子-使用AtomicReference创建线程安全的堆栈</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span></span><span class="token class-name">AtomicReference</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">AccessLevel</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">AllArgsConstructor</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedStack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> stacks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">T</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> oldNode<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> newNode<span class="token punctuation">;</span>    <span class="token comment">// 这里的处理非常的特别，也是必须如此的</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      oldNode <span class="token operator">=</span> stacks<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> oldNode<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>stacks<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>oldNode<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> e<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> oldNode<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> newNode<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      oldNode <span class="token operator">=</span> stacks<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      newNode <span class="token operator">=</span> oldNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>stacks<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>oldNode<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> oldNode<span class="token punctuation">.</span>object<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@AllArgsConstructor</span><span class="token punctuation">(</span>access <span class="token operator">=</span> <span class="token class-name">AccessLevel</span><span class="token punctuation">.</span>PRIVATE<span class="token punctuation">)</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">T</span> object<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="8-Java中的volatile关键字是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？"><a href="#8-Java中的volatile关键字是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？" class="headerlink" title="8. Java中的volatile关键字是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？"></a>8. Java中的volatile关键字是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？</h2><p>volatile在多线程中是用来同步变量的。 线程为了提高效率，将某成员变量(如A)拷贝了一份（如B），线程中对A的访问其实访问的是B。只在某些动作时才进行A和B的同步。因此存在A和B不一致的情况</p><p>volatile就是用来避免这种情况的。volatile告诉jvm， 它所修饰的变量不保留拷贝，直接访问主内存中的（也就是上面说的A) 变量</p><p>一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中。以下例子展现了volatile的作用</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StoppableTask</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> pleaseStop<span class="token punctuation">;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pleaseStop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// do some stuff...</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tellMeToStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    pleaseStop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>假如pleaseStop没有被声明为volatile，线程执行run的时候检查的是自己的副本，就不能及时得知其他线程已经调用tellMeToStop()修改了pleaseStop的值。</p><p>volatile一般情况下不能代替synchronized，因为volatile不能保证操作的原子性，即使只是i++，实际上也是由多个原子操作组成<br><code>read i; inc; write i</code></p><p>假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。如果配合Java 5增加的atomic wrapper classes，对它们的increase之类的操作就不需要synchronized。</p><p>volatile和synchronized的不同是最容易解释清楚的。volatile是变量修饰符，而synchronized则作用于一段代码或方法；看如下三句get代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i1<span class="token punctuation">;</span><span class="token keyword">volatile</span> <span class="token keyword">int</span> i2<span class="token punctuation">;</span><span class="token keyword">int</span> i3<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">geti1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> i1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">geti2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> i2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">geti3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> i3<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>得到存储在当前线程中i1的数值。多个线程有多个i1变量拷贝，而且这些i1之间可以互不相同。换句话说，另一个线程可能已经改变了它线程内的i1值，而这个值可以和当前线程中的i1值不相同。事实上，Java有个思想叫“主”内存区域，这里存放了变量目前的“准确值”。每个线程可以有它自己的 变量拷贝，而这个变量拷贝值可以和“主”内存区域里存放的不同。因此实际上存在一种可能：“主”内存区域里的i1值是1，线程1里的i1值是2，线程2里 的i1值是3——这在线程1和线程2都改变了它们各自的i1值，而且这个改变还没来得及传递给“主”内存区域或其他线程时就会发生。</p><p>而 geti2()得到的是“主”内存区域的i2数值。用volatile修饰后的变量不允许有不同于“主”内存区域的变量拷贝。换句话说，一个变量经 volatile修饰后在所有线程中必须是同步的；任何线程中改变了它的值，所有其他线程立即获取到了相同的值。理所当然的，volatile修饰的变量存取时比一般变量消耗的资源要多一点，因为线程有它自己的变量拷贝更为高效。</p><p>既然volatile关键字已经实现了线程间数据同步，又要 synchronized干什么呢？它们之间有两点不同。首先，synchronized获得并释放监视器——如果两个线程使用了同一个对象锁，监视器能强制保证代码块同时只被一个线程所执行——这是众所周知的事实。但是，synchronized也同步内存：事实上，synchronized在“ 主”内存区域同步整个线程的内存。因此，执行geti3()方法做了如下几步:</p><ol><li>线程请求获得监视this对象的对象锁（假设未被锁，否则线程等待直到锁释放）</li><li>线程内存的数据被消除，从“主”内存区域中读入</li><li>代码块被执行</li><li>对于变量的任何改变现在可以安全地写到“主”内存区域中（不过geti3()方法不会改变变量值）</li><li>线程释放监视this对象的对象锁</li></ol><p>因此volatile只是在线程内存和“主”内存间同步某个变量的值，而synchronized通过锁定和解锁某个监视器同步所有变量的值。显然synchronized要比volatile消耗更多资源</p><h2 id="9-什么是竞争条件？如何发现和解决竞争？"><a href="#9-什么是竞争条件？如何发现和解决竞争？" class="headerlink" title="9. 什么是竞争条件？如何发现和解决竞争？"></a>9. 什么是竞争条件？如何发现和解决竞争？</h2><p>两个线程同步操作同一个对象，使这个对象的最终状态不明——叫做竞争条件。竞争条件可以在任何应该由程序员保证原子操作的，而又忘记使用synchronized的地方。</p><p>唯一的解决方案就是加锁。</p><p>Java有两种锁可供选择</p><ul><li><p>对象或者类(class)的锁。每一个对象或者类都有一个锁。使用synchronized关键字获取。 synchronized加到static方法上面就使用类锁，加到普通方法上面就用对象锁。除此之外synchronized还可以用于锁定关键区域块(Critical Section)。 synchronized之后要制定一个对象(锁的携带者)，并把关键区域用大括号包裹起来<code>synchronized(this)&#123;// critical code&#125;</code></p></li><li><p>显示构建的锁(java.util.concurrent.locks.Lock)，调用lock的lock方法锁定关键代码</p></li></ul><h2 id="10-如何使用thread-dump？如何分析Thread-dump？"><a href="#10-如何使用thread-dump？如何分析Thread-dump？" class="headerlink" title="10. 如何使用thread dump？如何分析Thread dump？"></a>10. 如何使用thread dump？如何分析Thread dump？</h2><p>Thread Dump是非常有用的诊断Java应用问题的工具，每一个Java虚拟机都有及时生成显示所有线程在某一点状态的thread-dump的能力。虽然各个 Java虚拟机打印输出格式上略微有一些不同，但是Thread dumps出来的信息包含线程；线程的运行状态、标识和调用的堆栈；调用的堆栈包含完整的类名，所执行的方法，如果可能的话还有源代码的行数</p><h3 id="SUN"><a href="#SUN" class="headerlink" title="SUN"></a>SUN</h3><p>JVM 产生ThreadDumpSolaris OS</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token operator">&lt;</span>ctrl<span class="token operator">></span><span class="token operator">-</span>’\’ <span class="token operator">(</span>Control<span class="token operator">-</span>Backslash<span class="token operator">)</span>kill <span class="token operator">-</span>QUIT <span class="token operator">&lt;</span>PID<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><h3 id="HP-UX-x2F-UNIX-x2F-Linux"><a href="#HP-UX-x2F-UNIX-x2F-Linux" class="headerlink" title="HP-UX&#x2F;UNIX&#x2F;Linux"></a>HP-UX&#x2F;UNIX&#x2F;Linux</h3><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">Kill <span class="token operator">-</span><span class="token number">3</span> <span class="token operator">&lt;</span>PID<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">直接对MSDOS窗口的程序按Ctrl<span class="token operator">-</span>break<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>有些Java应用服务器是在控制台上运行，如Weblogic，为了方便获取threaddump信息，在weblogic启动的时候，会将其标准输出重定向到一个文件， 用<code>&quot;nohup ./startWebLogic .sh &gt; log.out &amp;&quot;命令，执行&quot;kill -3 &lt;pid&gt;&quot;</code>，Thread dump就会输出到log.out里。</p><p>Tomcat的Thread Dump会输出到命令行控制台或者logs的catalina.out文件里。为了反映线程状态的动态变化，需要接连做三次以上thread dump，每次间隔10-20s</p><h3 id="IBM-JVM-产生Thread-Dump"><a href="#IBM-JVM-产生Thread-Dump" class="headerlink" title="IBM JVM 产生Thread Dump"></a>IBM JVM 产生Thread Dump</h3><p>在AIX上用IBM的JVM，内存溢出时默认地会产生javacore文件（关于cpu的）和heapdump文件(关于内存的)。 如果没有,则参照下列方法</p><ol><li><p>在server启动前设置下面环境变量（可以加在启动脚本中）</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log">export IBM_HEAPDUMP<span class="token operator">=</span><span class="token boolean">true</span>export IBM_HEAP_DUMP<span class="token operator">=</span><span class="token boolean">true</span>export IBM_HEAPDUMP_OUTOFMEMORY<span class="token operator">=</span><span class="token boolean">true</span>export IBM_HEAPDUMPDIR<span class="token operator">=</span><span class="token operator">&lt;</span>directory path<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>用set命令检查参数设置，确保没有设置DISABLE_JAVADUMP，然后启动server</p></li><li><p>执行kill -3 命令可以生成javacore文件和heapdump文件<br>拿到java thread dump后，你要做的就是查找”waiting for monitor entry”的thread，如果大量thread都在等待给同一个地址上锁（因为对于Java，一个对象只有一把锁），这说明很可能死锁发生了。比如</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token string">"service-j2ee"</span> prio<span class="token operator">=</span><span class="token number">5</span> tid<span class="token operator">=</span><span class="token number">0x024f1c28</span> nid<span class="token operator">=</span><span class="token number">0x125</span> waiting for monitor entry<span class="token punctuation">[</span><span class="token number">62a3e000</span><span class="token punctuation">.</span><span class="token punctuation">.</span>62a3f690<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atcom<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>enterprise<span class="token punctuation">.</span>resource<span class="token punctuation">.</span>IASNonSharedResourcePool<span class="token punctuation">.</span>internalGetResource<span class="token operator">(</span>IASNonSharedResourcePool<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">625</span><span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> <span class="token operator">-</span> waiting tolock <span class="token operator">&lt;</span><span class="token number">0x965d8110</span><span class="token operator">></span> <span class="token operator">(</span>a com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>enterprise<span class="token punctuation">.</span>resource<span class="token punctuation">.</span>IASNonSharedResourcePool<span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atcom<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>enterprise<span class="token punctuation">.</span>resource<span class="token punctuation">.</span>IASNonSharedResourcePool<span class="token punctuation">.</span>getResource<span class="token operator">(</span>IASNonSharedResourcePool<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">520</span><span class="token operator">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p>为了确定问题，常常需要在隔两分钟后再次收集一次thread dump，如果得到的输出相同，仍然是大量thread都在等待给同一个地址上锁，那么肯定是死锁了。</p><p>如何找到当前持有锁的线程是解决问题的关键。方法是搜索thread dump，查找”<code>locked &lt;0x965d8110&gt;</code>“， 找到持有锁的线程</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> <span class="token string">"Thread-20"</span> daemon prio<span class="token operator">=</span><span class="token number">5</span> tid<span class="token operator">=</span><span class="token number">0x01394f18</span>nid<span class="token operator">=</span><span class="token number">0x109</span> runnable <span class="token punctuation">[</span><span class="token number">6716f000</span><span class="token punctuation">.</span><span class="token punctuation">.</span>6716fc28<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atjava<span class="token punctuation">.</span>net<span class="token punctuation">.</span>SocketInputStream<span class="token punctuation">.</span>socketRead0<span class="token operator">(</span>Native Method<span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atjava<span class="token punctuation">.</span>net<span class="token punctuation">.</span>SocketInputStream<span class="token punctuation">.</span>read<span class="token operator">(</span>SocketInputStream<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">129</span><span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> at oracle<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ns<span class="token punctuation">.</span>Packet<span class="token punctuation">.</span>receive<span class="token operator">(</span>Unknown Source<span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atoracle<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ns<span class="token punctuation">.</span>DataPacket<span class="token punctuation">.</span>receive<span class="token operator">(</span>Unknown Source<span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atoracle<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ns<span class="token punctuation">.</span>NetInputStream<span class="token punctuation">.</span>getNextPacket<span class="token operator">(</span>Unknown Source<span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atoracle<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ns<span class="token punctuation">.</span>NetInputStream<span class="token punctuation">.</span>read<span class="token operator">(</span>Unknown Source<span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atoracle<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ns<span class="token punctuation">.</span>NetInputStream<span class="token punctuation">.</span>read<span class="token operator">(</span>Unknown Source<span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atoracle<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ns<span class="token punctuation">.</span>NetInputStream<span class="token punctuation">.</span>read<span class="token operator">(</span>Unknown Source<span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atoracle<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>ttc7<span class="token punctuation">.</span>MAREngine<span class="token punctuation">.</span>unmarshalUB1<span class="token operator">(</span>MAREngine<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">929</span><span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atoracle<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>ttc7<span class="token punctuation">.</span>MAREngine<span class="token punctuation">.</span>unmarshalSB1<span class="token operator">(</span>MAREngine<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">893</span><span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atoracle<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>ttc7<span class="token punctuation">.</span>Ocommoncall<span class="token punctuation">.</span>receive<span class="token operator">(</span>Ocommoncall<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">106</span><span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atoracle<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>ttc7<span class="token punctuation">.</span>TTC7Protocol<span class="token punctuation">.</span>logoff<span class="token operator">(</span>TTC7Protocol<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">396</span><span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> <span class="token operator">-</span> locked <span class="token operator">&lt;</span><span class="token number">0x954f47a0</span><span class="token operator">></span> <span class="token operator">(</span>aoracle<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>ttc7<span class="token punctuation">.</span>TTC7Protocol<span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atoracle<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>driver<span class="token punctuation">.</span>OracleConnection<span class="token punctuation">.</span>close<span class="token operator">(</span>OracleConnection<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1518</span><span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> <span class="token operator">-</span> locked <span class="token operator">&lt;</span><span class="token number">0x954f4520</span><span class="token operator">></span> <span class="token operator">(</span>aoracle<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>driver<span class="token punctuation">.</span>OracleConnection<span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atcom<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>enterprise<span class="token punctuation">.</span>resource<span class="token punctuation">.</span>JdbcUrlAllocator<span class="token punctuation">.</span>destroyResource<span class="token operator">(</span>JdbcUrlAllocator<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">122</span><span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atcom<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>enterprise<span class="token punctuation">.</span>resource<span class="token punctuation">.</span>IASNonSharedResourcePool<span class="token punctuation">.</span>destroyResource<span class="token operator">(</span>IASNonSharedResourcePool<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">872</span><span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atcom<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>enterprise<span class="token punctuation">.</span>resource<span class="token punctuation">.</span>IASNonSharedResourcePool<span class="token punctuation">.</span>resizePool<span class="token operator">(</span>IASNonSharedResourcePool<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1086</span><span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> <span class="token operator">-</span> locked <span class="token operator">&lt;</span><span class="token number">0x965d8110</span><span class="token operator">></span> <span class="token operator">(</span>acom<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>enterprise<span class="token punctuation">.</span>resource<span class="token punctuation">.</span>IASNonSharedResourcePool<span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atcom<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>enterprise<span class="token punctuation">.</span>resource<span class="token punctuation">.</span>IASNonSharedResourcePool<span class="token operator">$</span>Resizer<span class="token punctuation">.</span>run<span class="token operator">(</span>IASNonSharedResourcePool<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1178</span><span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atjava<span class="token punctuation">.</span>util<span class="token punctuation">.</span>TimerThread<span class="token punctuation">.</span>mainLoop<span class="token operator">(</span>Timer<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">432</span><span class="token operator">)</span><span class="token punctuation">[</span><span class="token date number">27/Jun/2006</span><span class="token operator">:</span><span class="token time number">10:03:08</span><span class="token punctuation">]</span> <span class="token level warning important">WARNING</span> <span class="token operator">(</span><span class="token number">26140</span><span class="token operator">)</span><span class="token operator">:</span> CORE3283<span class="token operator">:</span> stderr<span class="token operator">:</span> atjava<span class="token punctuation">.</span>util<span class="token punctuation">.</span>TimerThread<span class="token punctuation">.</span>run<span class="token operator">(</span>Timer<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">382</span><span class="token operator">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>在这个例子里，持有锁的线程在等待Oracle返回结果，却始终等不到响应，因此发生了死锁。</p><p>如果持有锁的线程还在等待给另一个对象上锁，那么还是按上面的办法顺藤摸瓜，直到找到死锁的根源为止。 另外，在thread dump里还会经常看到这样的线程，它们是等待一个条件而主动放弃锁的线程。例如</p><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token string">"Thread-1"</span> daemon prio<span class="token operator">=</span><span class="token number">5</span> tid<span class="token operator">=</span><span class="token number">0x014e97a8</span> nid<span class="token operator">=</span><span class="token number">0x80</span> in Object<span class="token punctuation">.</span>wait<span class="token operator">(</span><span class="token operator">)</span> <span class="token punctuation">[</span><span class="token number">68c6f000</span><span class="token punctuation">.</span><span class="token punctuation">.</span>68c6fc28<span class="token punctuation">]</span>at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">.</span>wait<span class="token operator">(</span>Native Method<span class="token operator">)</span> <span class="token operator">-</span> waiting on <span class="token operator">&lt;</span><span class="token number">0x95b07178</span><span class="token operator">></span> <span class="token operator">(</span>a java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token operator">)</span>at com<span class="token punctuation">.</span>iplanet<span class="token punctuation">.</span>ias<span class="token punctuation">.</span>util<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">.</span>remove<span class="token operator">(</span>BlockingQueue<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">258</span><span class="token operator">)</span><span class="token operator">-</span> locked <span class="token operator">&lt;</span><span class="token number">0x95b07178</span><span class="token operator">></span> <span class="token operator">(</span>a java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token operator">)</span> at com<span class="token punctuation">.</span>iplanet<span class="token punctuation">.</span>ias<span class="token punctuation">.</span>util<span class="token punctuation">.</span>threadpool<span class="token punctuation">.</span>FastThreadPool<span class="token operator">$</span>ThreadPoolThread<span class="token punctuation">.</span>run<span class="token operator">(</span>FastThreadPool<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">241</span><span class="token operator">)</span>at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>run<span class="token operator">(</span>Thread<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">534</span><span class="token operator">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>有时也会需要分析这类线程，尤其是线程等待的条件。</p><p>其实，Java thread dump并不只用于分析死锁，其它Java应用运行时古怪的行为都可以用thread dump来分析</p><p>在Java SE 5里，增加了jstack的工具，也可以获取thread dump。在Java SE 6里，通过jconsole的图形化工具也可以方便地查找涉及object monitors 和java.util.concurrent.locks死锁</p><p>参考文章：<a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html">三个实例演示 Java Thread Dump 日志分析</a></p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁</tag>
      
      <tag>线程</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程问题整理(上)</title>
    <link href="/posts/2468624859.html"/>
    <url>/posts/2468624859.html</url>
    
    <content type="html"><![CDATA[<p>2014年我曾经整理过相关的java并发编程的面试题目，这里重新整理一下</p><h2 id="1-有T1、T2、T3三个线程，如何怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"><a href="#1-有T1、T2、T3三个线程，如何怎样保证T2在T1执行完后执行，T3在T2执行完后执行？" class="headerlink" title="1. 有T1、T2、T3三个线程，如何怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"></a>1. 有T1、T2、T3三个线程，如何怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</h2><p><strong>使用join方法</strong></p><p>join方法的功能是使异步执行的线程变成同步执行。即调用线程实例的start方法后，该方法会立即返回，如果调用start方法后，需要使用一个由这个线程计算得到的值，就必须使用join方法。如果不使用join方法，就不能保证当执行到start方法后面的某条语句时，这个线程一定会执行完。而使用join方法后，直到这个线程退出，程序才会往下执行</p><h2 id="2-Java中的Lock接口，比起synchronized，优势在哪里？"><a href="#2-Java中的Lock接口，比起synchronized，优势在哪里？" class="headerlink" title="2. Java中的Lock接口，比起synchronized，优势在哪里？"></a>2. Java中的Lock接口，比起synchronized，优势在哪里？</h2><p>如果需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，如何实现？</p><p>Lock接口最大的优势是为读和写分别提供了锁</p><p>读写锁ReadWriteLock拥有更加强大的功能，它可细分为读锁和写锁</p><p>读锁可以允许多个进行读操作的线程同时进入，但不允许写进程进入；写锁只允许一个写进程进入，在这期间任何进程都不能再进入(完全符合题目中允许多个用户读和一个用户写的条件)</p><p>要注意的是每个读写锁都有挂锁和解锁操作，最好将每对挂锁和解锁操作都用try、finally来套入中间的代码，这样就会防止因异常的发生而造成死锁得情况</p><p>下面是一个示例程序<br>ReadWriteLockTest.java</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReadWriteLockTest</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 这是各线程的共享数据</span>    <span class="token keyword">final</span> <span class="token class-name">TheData</span> myData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TheData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 开启3个读线程</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>              <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  myData<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>              <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 开启3个写线程</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>              <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  myData<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>              <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>TheData.java</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReadWriteLock</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantReadWriteLock</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">ExceptionUtils</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TheData</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReadWriteLock</span> rwl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">Object</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读锁开启，读线程均可进入</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 用try finally来防止因异常而造成的死锁</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; is ready to read"</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; have read data &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>      rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读锁解锁</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写锁开启，这时只有一个写线程进入</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; is ready to write"</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; have write data &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>      rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写锁解锁</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="3-java中wait和sleep方法有何不同？"><a href="#3-java中wait和sleep方法有何不同？" class="headerlink" title="3. java中wait和sleep方法有何不同？"></a>3. java中wait和sleep方法有何不同？</h2><p>最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行</p><p>其它不同有</p><ul><li>sleep是Thread类的静态方法，wait是Object方法。</li><li>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用</li><li>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</li></ul><h2 id="4-如何用Java实现阻塞队列？"><a href="#4-如何用Java实现阻塞队列？" class="headerlink" title="4. 如何用Java实现阻塞队列？"></a>4. 如何用Java实现阻塞队列？</h2><p>首先，我们要明确阻塞队列的定义:<br>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素</p><blockquote><p>注：有关生产者——消费者问题，可查阅维基百科网址<a href="https://zh-wikipedia.mirror.wit.im/w/index.php?search=%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98&title=Special:%E6%90%9C%E7%B4%A2">生产者消费者问题</a>和百度百科网址<a href="https://baike.baidu.com/item/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">生产者消费者问题</a></p></blockquote><p>阻塞队列的一个简单实现<br>BlockingQueue.java</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Queue</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockingQueue</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> limit <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">BlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> limit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">=</span> limit<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> item<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">Object</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>在enqueue和dequeue方法内部，只有队列的大小等于上限（limit）或者下限（0）时，才调用notifyAll方法。如果队列的大小既不等于上限，也不等于下限，任何线程调用enqueue或者dequeue方法时，都不会阻塞，都能够正常的往队列中添加或者移除元素</p><h2 id="5-编写Java代码，解决生产者-消费者问题"><a href="#5-编写Java代码，解决生产者-消费者问题" class="headerlink" title="5. 编写Java代码，解决生产者-消费者问题"></a>5. 编写Java代码，解决生产者-消费者问题</h2><p>生产者-消费者问题是研究多线程程序时绕不开的经典问题之一，它描述是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品。</p><p>使用问题4中阻塞队列实现代码来解决。但此不是唯一解决方案。</p><p>解决生产者&#x2F;消费者问题的方法可分为两类:</p><ul><li>采用某种机制保护生产者和消费者之间的同步</li><li>在生产者和消费者之间建立一个管道</li></ul><p>第一种方式有较高的效率，并且易于实现，代码的可控制性较好，属于常用的模式。第二种管道缓冲区不易控制，被传输数据对象不易于封装等，实用性不强。因此建议使用第一种方式来实现。</p><p>同步的核心问题在于: <strong>如何保证同一资源被多个线程并发访问时的完整性？</strong></p><p>常用的同步方法是采用信号或加锁机制，保证资源在任意时刻至多被一个线程访问。Java语言在多线程编程上实现了完全对象化，提供了对同步机制的良好支持。</p><p>在Java中一共有四种方法支持同步，其中前三个是同步方法，一个是管道方法。管道方法不建议使用，阻塞队列方法在问题4已有描述，现只提供前两种实现方法</p><ul><li>wait()&#x2F;notify()方法</li><li>await()&#x2F;signal()方法</li><li>BlockingQueue阻塞队列方法</li><li>PipedInputStream&#x2F;PipedOutputStream</li></ul><p>生产者类(Producer.java)</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>wujunshen<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>producerandconsumer<span class="token punctuation">.</span>notify<span class="token punctuation">.</span></span><span class="token class-name">Storage</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">EqualsAndHashCode</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@EqualsAndHashCode</span><span class="token punctuation">(</span>callSuper <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/** 每次生产的产品数量 */</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>  <span class="token comment">/** 所在放置的仓库 */</span>  <span class="token keyword">private</span> <span class="token class-name">Storage</span> storage<span class="token punctuation">;</span>  <span class="token comment">/**   * 构造函数，设置仓库   *   * @param storage 仓库   */</span>  <span class="token keyword">public</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token class-name">Storage</span> storage<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> storage<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/** 线程run函数 */</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">produce</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/**   * 调用仓库Storage的生产函数   *   * @param num 生产数量   */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    storage<span class="token punctuation">.</span><span class="token function">produce</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>消费者类(Consumer.java)</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>wujunshen<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>producerandconsumer<span class="token punctuation">.</span>notify<span class="token punctuation">.</span></span><span class="token class-name">Storage</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">EqualsAndHashCode</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@EqualsAndHashCode</span><span class="token punctuation">(</span>callSuper <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/** 每次消费的产品数量 */</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>  <span class="token comment">/** 所在放置的仓库 */</span>  <span class="token keyword">private</span> <span class="token class-name">Storage</span> storage<span class="token punctuation">;</span>  <span class="token comment">/**   * 构造函数，设置仓库   *   * @param storage 仓库   */</span>  <span class="token keyword">public</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token class-name">Storage</span> storage<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> storage<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/** 线程run函数 */</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">consume</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/**   * 调用仓库Storage的生产函数   *   * @param num 消费数量   */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    storage<span class="token punctuation">.</span><span class="token function">consume</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>仓库类:（wait&#x2F;notify方法）</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Queue</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">ExceptionUtils</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Storage</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/** 仓库最大存储量 */</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_SIZE <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">/** 仓库存储的载体 */</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/**   * 生产num个产品   *   * @param num 生产数量   */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 同步代码段</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 如果仓库剩余容量不足</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> num <span class="token operator">></span> MAX_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【要生产的产品数量】: &#123;&#125;"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【库存量】: &#123;&#125; 暂时不能执行生产任务!"</span><span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>          list<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 由于条件不满足，生产阻塞</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 生产条件满足情况下，生产num个产品</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【已经生产产品数】: &#123;&#125;"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【现仓储量为】: &#123;&#125;"</span><span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      list<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/**   * 消费num个产品   *   * @param num 消费数量   */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 同步代码段</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 如果仓库存储量不足</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【要消费的产品数量】: &#123;&#125;"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【库存量】: &#123;&#125; 暂时不能执行生产任务!"</span><span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 由于条件不满足，消费阻塞</span>          list<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 消费条件满足情况下，消费num个产品</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【已经消费产品数】: &#123;&#125;"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【现仓储)量为】: &#123;&#125;"</span><span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      list<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>仓库类:（await&#x2F;signal方法）</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Queue</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Condition</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Lock</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantLock</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">ExceptionUtils</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Storage</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/** 仓库最大存储量 */</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_SIZE <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">/** 锁 */</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/** 仓库满的条件变量 */</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> full <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/** 仓库空的条件变量 */</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> empty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/** 仓库存储的载体 */</span>  <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/**   * 生产num个产品   *   * @param num 生产数量   */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获得锁</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果仓库剩余容量不足</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> num <span class="token operator">></span> MAX_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【要生产的产品数量】: &#123;&#125;"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【库存量】: &#123;&#125; 暂时不能执行生产任务!"</span><span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 由于条件不满足，生产阻塞</span>        full<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 生产条件满足情况下，生产num个产品</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【已经生产产品数】: &#123;&#125;"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【现仓储量为】: &#123;&#125;"</span><span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 唤醒其他所有线程</span>    full<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    empty<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放锁</span>    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/**   * 消费num个产品   *   * @param num 消费数量   */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获得锁</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果仓库存储量不足</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【要消费的产品数量】: &#123;&#125;"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【库存量】: &#123;&#125; 暂时不能执行生产任务!"</span><span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 由于条件不满足，消费阻塞</span>        empty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtils</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 消费条件满足情况下，消费num个产品</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【已经消费产品数】: &#123;&#125;"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【现仓储)量为】: &#123;&#125;"</span><span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 唤醒其他所有线程</span>    full<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    empty<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放锁</span>    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁</tag>
      
      <tag>线程</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程</title>
    <link href="/posts/378589723.html"/>
    <url>/posts/378589723.html</url>
    
    <content type="html"><![CDATA[<p>之所以把FP（Function Programming）放在设计模式章节讲，是因为之后说到设计模式，会把某些可以写成fp形式的设计模式讲一下，因此需要有函数式编程基础和思维</p><p>从java8开始引入的函数式编程，主要包括lambda和流式API。现针对常用的一些场景予以说明</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//拿到所有的processNumber</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> processNumbers <span class="token operator">=</span> param<span class="token punctuation">.</span><span class="token function">getListProcessNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">QueryStateData</span><span class="token operator">::</span><span class="token function">getProcessNumber</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>上面代码作用是把<code>List&lt;Object&gt;</code>中需要的一个<code>String</code>字段变成<code>List&lt;String&gt;</code>，map是StringAPI中用来做数据类型转换的，<code>QueryStateData::getProcessNumber</code>是方法引用，作用与<code>object-&gt;object.getProcessNumber();</code>一样，collect是收集器，通过收集器，把流转换成想要的<code>List&lt;String&gt;</code>。</p><h3 id="对List数据进行数据筛选"><a href="#对List数据进行数据筛选" class="headerlink" title="对List数据进行数据筛选"></a>对List数据进行数据筛选</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//获取paymentChange</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GaPaymentChange</span><span class="token punctuation">></span></span> changeOptional <span class="token operator">=</span>     listPaymentChange<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>p <span class="token operator">-></span> p<span class="token punctuation">.</span><span class="token function">getTransferNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>std<span class="token punctuation">.</span><span class="token function">getProcessNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>changeOptional<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">GaPaymentChange</span> paymentChange <span class="token operator">=</span> changeOptional<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>filter的函数式接口中需返回一个boolean值。<code>findFirst</code>是取其中的第一个，可以返回一个<code>Optional</code>对象。通过get方法拿到想要的结果。</p><h3 id="Optional对象的应用"><a href="#Optional对象的应用" class="headerlink" title="Optional对象的应用"></a>Optional对象的应用</h3><p>Optional的出现是为了减少空指针异常</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BigDecimal</span> bigAbmout <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>paymentChange<span class="token punctuation">.</span><span class="token function">getPaymentChangeMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setScale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>当<code>ofNullable</code>值为<code>null</code>时，我们可以给<code>bigAbmout</code>赋一个默认值。<code>orElseGet</code>的传参数是一个函数式接口</p><p>也可以写成下列形式</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>paymentChange<span class="token punctuation">.</span><span class="token function">getPaymentChangeMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setScale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><code>orElse</code>与<code>orElseGet</code>不同的是，它的参数直接是目标对象</p><h3 id="流式API遍历对象"><a href="#流式API遍历对象" class="headerlink" title="流式API遍历对象"></a>流式API遍历对象</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">page<span class="token punctuation">.</span><span class="token function">getRows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>x <span class="token operator">-></span> x<span class="token punctuation">.</span><span class="token function">setOrderTime</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">DateUtils</span><span class="token punctuation">.</span><span class="token function">dateFormat</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">getCreateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">DateUtils</span><span class="token punctuation">.</span>DAT_SHORT_FORMATSS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>把集合对象中<code>orderTime</code>的值做转换</p><h3 id="快速找到集合中想要匹配数据"><a href="#快速找到集合中想要匹配数据" class="headerlink" title="快速找到集合中想要匹配数据"></a>快速找到集合中想要匹配数据</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//是否存在增补单</span><span class="token keyword">boolean</span> match <span class="token operator">=</span> gaPaymentChangeDetailList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>detail <span class="token operator">-></span> <span class="token class-name">GaConstants</span><span class="token punctuation">.</span>SUPPLEMENT_BILL<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>detail<span class="token punctuation">.</span><span class="token function">getIsSupplementBill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p><code>anyMatch</code>配合lambda表达式可以在集合中快速找到想匹配的数据</p><h3 id="List中对象转换"><a href="#List中对象转换" class="headerlink" title="List中对象转换"></a>List中对象转换</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Menu</span><span class="token punctuation">></span></span>menus<span class="token operator">=</span> menuService<span class="token punctuation">.</span><span class="token function">queryMenuList</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MenuTreeVO</span><span class="token punctuation">></span></span> menuTrees <span class="token operator">=</span> menus<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">MenuTreeVO</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>其中<code>map(MenuTreeVO::new)</code>等价于<code>map(menu-&gt;new MenuTreeVO(menu))</code></p><p>所以重写了MenuTreeVO的构造方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">MenuTreeVO</span><span class="token punctuation">(</span><span class="token class-name">Menu</span> menu<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pId <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">getParentId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">open</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="枚举中的应用"><a href="#枚举中的应用" class="headerlink" title="枚举中的应用"></a>枚举中的应用</h3><p>枚举中我们通常会与一个静态方法通过code去获取它对应的枚举，没有FP我们一般是通过for循环实现。看看FP怎么写的</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">OrderStateEnum</span> <span class="token function">getEnum</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">OrderStateEnum</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e<span class="token operator">-></span>e<span class="token punctuation">.</span>code<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><h3 id="lambda实现函数式接口"><a href="#lambda实现函数式接口" class="headerlink" title="lambda实现函数式接口"></a>lambda实现函数式接口</h3><p>new接口的地方。比如MQ发消息，我们传统的做法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">jmsTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageCreator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Message</span> <span class="token function">createMessage</span><span class="token punctuation">(</span><span class="token class-name">Session</span> session<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">JMSException</span> <span class="token punctuation">&#123;</span>                                 <span class="token keyword">return</span> session<span class="token punctuation">.</span><span class="token function">createTextMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>这个函数式接口可以用lambda一行代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">jmsTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>session <span class="token operator">-></span> session<span class="token punctuation">.</span><span class="token function">createTextMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h3 id="去重、求和、最大值、最小值"><a href="#去重、求和、最大值、最小值" class="headerlink" title="去重、求和、最大值、最小值"></a>去重、求和、最大值、最小值</h3><p>流式API的统计方法，实践中可以自己一个个去看源码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Color</span><span class="token punctuation">></span></span> colors <span class="token operator">=</span> skusResult<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Sku</span><span class="token operator">::</span><span class="token function">getColor</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>上面是对<code>List&lt;Color&gt;</code>中的Color对象去重</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://mp.weixin.qq.com/s?__biz=Mzg5NjMxMTYxNQ==&mid=2247486213&idx=1&sn=58705bc516c38620b01537710561ae3c&source=41#wechat_redirect">Java8函数式编程实践精华</a></p><h2 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a><a href="/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">推荐书单</a></h2>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>函数式编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协议</title>
    <link href="/posts/2904319820.html"/>
    <url>/posts/2904319820.html</url>
    
    <content type="html"><![CDATA[<h2 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h2><p><img src="/img/protocol/2D5E4F46C3E42E82B22B615129D1B26C.jpg" alt="OSI七层协议"></p><ul><li>物理层: 利用传输介质为数据链路层提供物理连接，实现比特流的透明传输</li><li>数据链路层: 负责建立和管理节点间的链路</li><li>网络层: 通过路由选择算法，为报文或分组通过通信子网选择最适当的路径</li><li>传输层: 向用户提供可靠的端到端的差多和流量控制，保证报文的正确传输</li><li>会话层: 向两个实体的表示层提供建立和使用连接的方法</li><li>表示层: 处理用户信息的表示问题，如编码、数据格式转换和加密解密等</li><li>应用层: 直接向用户提供服务，完成用户希望在网络上完成的各种工作</li></ul><p>七层各自描述和包含的协议见下图</p><p><img src="/img/protocol/245DEFFD262F59BFAC33556FD8B0206F.jpg" alt="描述和包含的协议"></p><h2 id="TCP-x2F-IP四层协议"><a href="#TCP-x2F-IP四层协议" class="headerlink" title="TCP&#x2F;IP四层协议"></a>TCP&#x2F;IP四层协议</h2><ul><li>数据链路层: 对应OSI的物理层和数据链路层</li><li>网络层: 对应OSI的网络层</li><li>传输层: 对应OSI的传输层</li><li>应用层: 对应OSI的会话、表示、应用层</li></ul><p>对应关系如图<br><img src="/img/protocol/2AEEA3B0FBF32467338D4BE17AFD4009.jpg" alt="对应关系"></p><h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><p>传输层的TCP和UDP是面试常问问题</p><ul><li>TCP: 传输控制协议（Transmission Control Protocol），提供面向连接、可靠的数据传输服务</li><li>UDP: 用户数据协议（User Datagram Protocol），提供无连接，尽最大努力的数据传输服务（不保证数据传输的可靠性）</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>如图</p><p><img src="/img/protocol/A37D65789F145C607D773FFDC54E03E2.jpg" alt="对比"></p><p>TCP提供面向连接服务，传送数据前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。TCP由于在传数据之前，用三次握手来建立连接，传数据过程中有确认、窗口、重传、拥塞控制等级制，传完还会四次挥手断开连接来节约系统资源，因此相对可靠，但是这会增加许多开销，不但使协议数据单元首部大很多，而且还占用了很多资源。它一般用在文件传输、发送、接收邮件、远程登录等场景</p><p>UDP相对没那么多事情，传数据前不需要建立连接、远程主机收到报文后也不需要给出任何确认。它不保证数据传输可靠性，但在语音、视频聊天和直播等属于即时通信场景的情况下，确是一种最有效的工作方式。</p><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="/img/protocol/D6B840BEBE54C39EA99ECE060726C21B.jpg" alt="三次握手"></p><p>如图依次说明</p><blockquote><p>由于全双工模式（Full Duplex，通讯传输的一个术语。允许数据在两个方向上同时传输，可以同时进行A→B且B→A），最开始时客户端和服务器都处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器</p></blockquote><ol><li>TCP服务器进程先创建传输控制块TCB（Transmission Control Block），时刻准备接受客户端进程的连接请求，此时服务器就进入了LISTEN（监听）状态</li><li>TCP客户端进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN&#x3D;1，同时选择一个初始序列号 seq&#x3D;x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN&#x3D;1的报文段）不能携带数据，但需要消耗掉一个序号</li><li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号</li><li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，ack&#x3D;y+1，自己的序列号seq&#x3D;x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号</li><li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了</li></ol><h3 id="三大疑问？"><a href="#三大疑问？" class="headerlink" title="三大疑问？"></a>三大疑问？</h3><h4 id="为啥要三次握手？不能两次么？"><a href="#为啥要三次握手？不能两次么？" class="headerlink" title="为啥要三次握手？不能两次么？"></a>为啥要三次握手？不能两次么？</h4><p>三次握手目的是建立可靠的通信通道，让建立通道的双方确认自己与对方的数据发送、接收功能都是正常的。</p><ul><li>第一次握手: 客户端什么都确认不了，服务器确认对方发送正常，自己接收正常</li><li>第二次握手: 客户端确认自己发送、接收正常，对方发送、接收正常，服务器确认对方发送正常，自己接收正常</li><li>第三次握手：客户端确认自己发送、接收正常，对方发送、接收正常，服务器确认自己发送、接收正常，对方发送、接收正常</li></ul><p>所以三次握手能确认双方收发功能都正常，缺一不可啊~</p><p>如果还不能理解，举个栗子吧</p><p>假设你刚入职了一家公司，在微信上加了个漂亮女同事微信，你向她发微信打招呼</p><ul><li>两次握手只能保证单向连接是畅通的<br>握手1  你 -&gt; 漂亮女同事: 你好啊，美女<br>握手2  你&lt;- 漂亮女同事: 嗯。你也好啊，帅哥<br>这样一来一回，就等于握了两次手，你向女同事发微信并得到了回复，即你向女同事发送了微信消息，她是可以收到的。但是漂亮女同事向你发微信，你却还没回复，她没有收到你的回复，无法确认你是否收到了她发送的微信消息</li><li>只有经过第三次握手，才能确保双向都可接收到对方发送的数据。<br>握手3  你 -&gt; 漂亮女同事: 收到，美女。以后请多指教<br>这样女同事才能确定你也可以收到她发给你的微信消息</li></ul><h4 id="为啥服务器要传回SYN？"><a href="#为啥服务器要传回SYN？" class="headerlink" title="为啥服务器要传回SYN？"></a>为啥服务器要传回SYN？</h4><p>服务器传回客户端SYN，只是为了告诉客户端，我收到的信息的的确确是你发送的信号。</p><p>SYN是建立连接时使用的握手信号。客户端和服务器建立TCP连接时，客户端先发SYN消息，服务器使用SYN-ACK应答表示接收到这个消息，最后客户端再以ACK（acknowledgement）响应。这样客户端和服务器才能建立可靠的TCP连接。这个ACK有点相当于你去便利店买东西，营业员给你的小票，确认你已购买过小票上的商品，并有总计价格。</p><h4 id="传了SYN，为啥还要传ACK？"><a href="#传了SYN，为啥还要传ACK？" class="headerlink" title="传了SYN，为啥还要传ACK？"></a>传了SYN，为啥还要传ACK？</h4><p>传了SYN只是证明客户端到服务器的通道没问题，但是服务器到客户端的通道还需要ACK信号来验证。</p><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="/img/protocol/542D336A5BB392D9C1155D8AE0353F12.jpg" alt="四次挥手"></p><p>如图依次说明</p><blockquote><p>数据传输完，双方都可释放连接。最开始时，客户端和服务器都处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭</p></blockquote><ol><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1）。此时，客户端进入FIN-WAIT-1（终止等待1）状态。<strong>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号</strong></li><li>服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。<strong>TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。</strong>这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（<strong>在这之前还需要接受服务器最后发送的数据</strong>）</li><li>服务器将最后的数据发送完，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。<strong>注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态</strong></li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。<strong>可以看到，服务器结束TCP连接的时间要比客户端早一些</strong></li></ol><h3 id="这次疑问是两个"><a href="#这次疑问是两个" class="headerlink" title="这次疑问是两个"></a>这次疑问是两个</h3><h4 id="为啥挥手一定要四次？"><a href="#为啥挥手一定要四次？" class="headerlink" title="为啥挥手一定要四次？"></a>为啥挥手一定要四次？</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，等待对方确认后进入半关闭状态。当另一方也再没有数据发送时，就会发出连接释放通知，对方确认后才会完全关闭TCP连接</p><p>还是举个栗子吧</p><p>你和你女友约会结束，你把她送到她家楼下，然后准备各回各家时，你说:”今天就到这里吧，我回家了”，你女友说：“哦，我知道了”。但是看她样子可能还想和你呆一会儿，还想说几句话，你总不能说回家就回家，让她跟着你节奏吧？于是你女友可能又和你呆了一会儿，说了一会儿话，最后她也累了，就说:“那我上楼了”，这时你回答“好，再见”，这样才算一次约会结束</p><h4 id="这个MSL是什么鬼？为啥客户端最后还要等待2-MSL这段时间？"><a href="#这个MSL是什么鬼？为啥客户端最后还要等待2-MSL这段时间？" class="headerlink" title="这个MSL是什么鬼？为啥客户端最后还要等待2*MSL这段时间？"></a>这个MSL是什么鬼？为啥客户端最后还要等待2*MSL这段时间？</h4><p>MSL（Maximum Segment Lifetime）。最大报文生命时间。TCP允许不同的实现可以设置不同的MSL值。</p><ol><li>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我响应，应该是我发送的请求断开报文它没收到，于是服务器又会重新发一次，而客户端就能在这个2* MSL时间段内收到这个重传的报文，接着给出响应报文，并会重启2MSL计时器</li><li>如果已关闭的老连接和新连接端口号一样，再加上正好碰到老连接的某些数据仍然还滞留在网络中，那么TCP会认为这些滞留数据是新连接的，这就会发生报文混淆。因此为了防止滞留数据出现在新连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，可使本次老连接持续时间内，所产生的所有报文段都从网络中消失。这样新连接中就不会出现老连接的请求报文</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869">OSI七层模型详解</a></li><li><a href="https://mp.weixin.qq.com/s/Cw2HWukDynYsjNskMkD38A">TCP的三次握手与四次挥手</a></li></ol><h2 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a><a href="/%E5%8D%8F%E8%AE%AE">推荐书单</a></h2>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SOLID设计原则</title>
    <link href="/posts/3081234936.html"/>
    <url>/posts/3081234936.html</url>
    
    <content type="html"><![CDATA[<p>面向对象的设计原则也被称为SOLID。SOLID最初是由Robert C.Martin所提出的，是敏捷软件开发过程的一部分。SOLID原则包括单一职责原则（S）、开闭原则（O）、里氏替换原则（L）、接口隔离原则（I）和依赖倒置原则（D）</p><h2 id="单一职责原则（Single-responsibility-principle）"><a href="#单一职责原则（Single-responsibility-principle）" class="headerlink" title="单一职责原则（Single responsibility principle）"></a>单一职责原则（Single responsibility principle）</h2><p>该原则指出软件模块应该只有一个被修改的理由。在大多数情况下，编写Java代码时都会将单一职责原则应用于类。单一职责原则可被视为使封装工作达到最佳状态的良好实践。<br>更改的理由是：需要修改代码。如果类需要更改的原因不止一个，那么每个类都可能引入影响其他类的更改。当这些更改单独管理但影响同一模块时，一系列更改可能会破坏与其他更改原因相关的功能。<br>另一方面，每个更改的职责&#x2F;理由都会增加新的依赖关系，使代码不那么健壮，更难以修改</p><p>举例假设有个Car类，既有数据库封装API，又包含业务逻辑计算。如图</p><p><img src="/img/solid/AFEACDCA09A8139FA6C1FDEBE790148F.jpg" alt="before"></p><p>create、update、delete、read方法都是数据库封装API，而calculatePrice是个业务逻辑计算API，因此如果更改了数据库，必须也要更改Car代码，这可能会在Car逻辑中产生错误</p><p>解决方案是创建两个类: 一个用于封装Car逻辑，另一个用于负责数据库封装</p><p><img src="/img/solid/A395F4EFDE87F281C96D195CAE2D504C.jpg" alt="after"></p><h2 id="开闭原则（Open-Closed-Principle）"><a href="#开闭原则（Open-Closed-Principle）" class="headerlink" title="开闭原则（Open Closed Principle）"></a>开闭原则（Open Closed Principle）</h2><p>“模块、类和函数应该对扩展开放，对修改关闭”</p><p>一旦开发并测试了一个模块，如果想要改变它，不仅要测试正在改变的功能，还要测试它负责的整个功能。这涉及到许多额外的资源，这些资源可能从一开始就没有估算过，也会带来额外的风险。一个模块中的更改可能会影响其他模块或整体上的功能</p><p>最好的办法是尝试在完成后保持模块不变，并通过<strong>继承</strong>和<strong>多态</strong>来扩展添加新功能。开闭原则是最重要的设计原则之一，是大多数设计模式的基础</p><h2 id="里氏替换原则（Liskov-Substitution-Principle）"><a href="#里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）"></a>里氏替换原则（Liskov Substitution Principle）</h2><p>Barbara Liskov指出，派生类型必须完全可替代其基类型。里氏替换原则（LSP）与子类型多态密切相关。基于面向对象语言中的子类型多态，派生对象可以用其父类型替换。</p><p>比如Car对象，它可以在代码中用作Vehicle</p><p>在设计模块和类时，必须确保派生类型从行为的角度来看是可替代的。当派生类型被其父类型替换时，其余代码就像它是子类型那样使用它。从这个角度来看，派生类型应该像其父类型那样表现，不应该破坏它的行为。这称之为强行为子类型</p><h2 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h2><p>下面这句话从链接 <a href="https://www.oodesign.com/interface-segregation-principle.html">https://www.oodesign.com/interface-segregation-principle.html</a> 得来“客户端不应该依赖于它所不需要的接口”</p><p>接口隔离原则减少了代码耦合，使软件更健壮，更易于维护和扩展。接口隔离原则最初是由Robert Martin提出的，他意识到如果接口隔离原则被破坏，客户端被迫依赖它们不使用的接口时，代码就会变得紧密耦合，几乎不可能为其添加新功能</p><p>举例说明，如图<br><img src="/img/solid/431F4B90578FD26B57932B410F54D054.jpg" alt="before"></p><p>实现一个名为Mechanic（机修工）的类。机修工修理汽车，所以我们增加了修理汽车的方法。在这个例子中，Mechanic类依赖于ICar类，但是，Car类提供的方法超出了Mechanic需要的。Car类的sell方法应该属于汽车销售人员使用的方法，机修工类并不需要这个sell方法。因此ICar接口需要分成两个接口，给机修工使用的接口只要repair方法</p><p><img src="/img/solid/0631ED924A2697CE158BC2E9B2E66229.jpg" alt="after"></p><h2 id="依赖倒置原则（Dependence-Inversion-Principle）"><a href="#依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）"></a>依赖倒置原则（Dependence Inversion Principle）</h2><p>“高级模块不应该依赖低级模块，两者都应该依赖抽象”</p><p>“抽象不应该依赖于细节，细节应该依赖于抽象”</p><p>这里需要解释耦合的概念</p><ul><li>耦合是指软件系统的模块彼此依赖的程度。依赖度越低，维护和扩展系统就越容易</li></ul><p>有不同的方法来解耦系统的组件。其中一个办法是将高级逻辑与低级模块分开，如图</p><p><img src="/img/solid/727DC3888F809870567CC3A34F18F9EC.jpg" alt="依赖倒置"></p><p>这样做时，可尝试让它们都依赖于抽象进而减少二者之间的依赖关系。如此就可替换或扩展其中任何一个模块而不影响其他模块</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://www.oodesign.com/interface-segregation-principle.html">Interface Segregation Principle (ISP)</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch</title>
    <link href="/posts/3565236947.html"/>
    <url>/posts/3565236947.html</url>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>index -&gt; type -&gt; mapping -&gt; document -&gt; field</p><p>对标数据库</p><table><thead><tr><th align="left">ES</th><th align="left">DB</th></tr></thead><tbody><tr><td align="left">index</td><td align="left">schma</td></tr><tr><td align="left">type</td><td align="left">无法对比，ES7.x版本开始移除</td></tr><tr><td align="left">mapping</td><td align="left">DDL定义，也可理解为数据库中一张table</td></tr><tr><td align="left">document</td><td align="left">table中一条数据</td></tr><tr><td align="left">field</td><td align="left">field</td></tr></tbody></table><h2 id="shard分片"><a href="#shard分片" class="headerlink" title="shard分片"></a>shard分片</h2><p>一个index有多个 shard，默认是5个（ES7.x版本开始默认1个），每个 shard 存储部分数据。</p><p>shard 存在意义有两个</p><ol><li>支持横向扩展<br>  假设原来5个shard。若数据量增加，可重建一个有 6 个 shard 的索引，将数据导进去</li><li>提高性能:<br>  数据分布在多个 shard，即多台服务器上。 所有操作，会在多台机器上并行分布式执行，提高吞吐量和性能。</li></ol><p>shard 数据有多个备份，每个 shard 有一个 primary shard，负责写入数据，还有几个 replica shard。primary shard 写入数据后，将数据同步到其他几个 replica shard 上。</p><p>ES集群情况下，推荐是一个node有一个primary shard，它的几个 replica shard分配在其他node。在某个node挂机情况下，还可以保证数据的完整性。</p><p>会有一个节点为 master 节点，负责管理工作，比如维护索引元数据、负责切换 primary shard 和 replica shard 身份等。如果 master 节点挂机了，会重新选举一个节点为 master 节点。</p><p>如果非 master节点挂机了， master 节点，让挂机节点的 primary shard 的身份转移到其他机器上的 replica shard。修复后重启，master 节点会将缺失的 replica shard 分配到被修复节点，同步后续修改的数据，让集群恢复正常。</p><blockquote><p>修复后的节点不再是 primary shard，而是 replica shard</p></blockquote><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>每个 document 都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。</p><p>倒排索引就是关键词到文档 ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。</p><table><thead><tr><th align="left">关键词</th><th align="left">文档 ID</th></tr></thead><tbody><tr><td align="left">google</td><td align="left">1,2,3,4,5</td></tr><tr><td align="left">java</td><td align="left">1,2,4,5</td></tr><tr><td align="left">kotlin</td><td align="left">3</td></tr><tr><td align="left">python</td><td align="left">2,3,5</td></tr></tbody></table><p>实用的倒排索引还记录文档频率信息，表示文档集合中有多少个文档包含某个关键词。</p><p>这样搜索引擎可以很方便地响应用户的查询。比如用户输入查询 google，搜索系统查找倒排索引，从中读出包含这个关键词的文档，这些文档就是提供给用户的搜索结果。</p><p>要注意倒排索引的两个重要细节</p><ol><li>倒排索引中的所有词项对应一个或多个文档；</li><li>倒排索引中的词项根据字典顺序升序排列</li></ol><h2 id="CRUD过程"><a href="#CRUD过程" class="headerlink" title="CRUD过程"></a>CRUD过程</h2><h3 id="create（写数据）"><a href="#create（写数据）" class="headerlink" title="create（写数据）"></a>create（写数据）</h3><ol><li>客户端选择一个 node 发送请求过去，这个 node 就是 coordinating node（协调节点）</li><li>coordinating node 对 document 进行路由，将请求转发给对应的 node（有 primary shard）</li><li>实际的 node 的 primary shard 处理请求，然后将数据同步到 replica node</li><li>coordinating node 如果发现 primary node 和所有 replica node 都搞定之后，就返回响应结果给客户端</li></ol><p><img src="/img/es/377B48909775D4564B3121146AFB9E8A.jpg" alt="写过程"></p><h4 id="写底层原理"><a href="#写底层原理" class="headerlink" title="写底层原理"></a>写底层原理</h4><p><img src="/img/es/7205E7671F902AEC2DAE65AB68FDB1CE.jpg" alt="写原理"></p><p>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</p><p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 refresh 到一个新的 segment file 中，但是此时数据不是直接进入 segment file 磁盘文件，而是先进入 os cache 。这个过程就是 refresh。</p><p>每隔 1 秒钟，es 将 buffer 中的数据写入一个新的 segment file，每秒钟会产生一个新的磁盘文件 segment file，这个 segment file 中就存储最近 1 秒内 buffer 中写入的数据。</p><p>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p><p>操作系统里面，磁盘文件其实都有一个东西，叫做 os cache，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 os cache，先进入操作系统级别的一个内存缓存中去。只要 buffer 中的数据被 refresh 操作刷入 os cache中，这个数据就可被搜索到了。</p><p>为什么叫 es 是准实时的？ NRT，全称 near real-time。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的 restful api 或者 java api，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 os cache中，让数据立马就可以被搜索到。只要数据被输入 os cache 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p><p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 buffer 数据写入一个又一个新的 segment file 中去，每次 refresh 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 commit 操作。</p><p>commit 操作发生第一步，就是将 buffer 中现有数据 refresh 到 os cache 中去，清空 buffer。然后，将一个 commit point 写入磁盘文件，里面标识着这个 commit point 对应的所有 segment file，同时强行将 os cache 中目前所有的数据都 fsync 到 segment file 磁盘文件中去。最后清空 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p><p>这个 commit 操作叫做 flush。默认 30 分钟自动执行一次 flush，但如果 translog 过大，也会触发 flush。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p><p>translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 translog 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p><p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以 es 是准实时的，从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中</p><blockquote><p>数据写入 segment file 之后，同时建好了倒排索引</p></blockquote><h3 id="requery（读数据）"><a href="#requery（读数据）" class="headerlink" title="requery（读数据）"></a>requery（读数据）</h3><p>根据 doc id 进行 hash，判断出来当时把 doc id 分配到了哪个 shard 上面去，从那个 shard 去查询。</p><ol><li>客户端发送请求到任意一个 node，成为 coordinate node</li><li>coordinate node 对 doc id 进行哈希路由，将请求转发到对应的 node，此时会使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡</li><li>接收请求的 node 返回 document 给 coordinate node</li><li>coordinate node 返回 document 给客户端</li></ol><h3 id="update-x2F-delete-更新-x2F-删除数据"><a href="#update-x2F-delete-更新-x2F-删除数据" class="headerlink" title="update&#x2F;delete(更新&#x2F;删除数据)"></a>update&#x2F;delete(更新&#x2F;删除数据)</h3><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>就是将原来的 doc 标识为 deleted 状态，然后新写入一条数据。</p><h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><p>commit 的时候会生成一个 .del 文件，里面将某个 doc 标识为 deleted 状态，那么搜索的时候根据 .del 文件就知道这个 doc 是否被删除了</p><h4 id="物理删除"><a href="#物理删除" class="headerlink" title="物理删除"></a>物理删除</h4><p>buffer 每 refresh 一次，就会产生一个 segment file，所以默认情况下是 1 秒钟一个 segment file，这样下来 segment file 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 segment file 合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉，然后将新的 segment file 写入磁盘，这里会写一个 commit point，标识所有新的 segment file，然后打开 segment file 供搜索使用，同时删除旧的 segment file</p><h4 id="全文检索（full-text-search）"><a href="#全文检索（full-text-search）" class="headerlink" title="全文检索（full-text search）"></a>全文检索（full-text search）</h4><ol><li>客户端发送请求到一个 coordinate node</li><li>协调节点将搜索请求转发到所有的 shard 对应的 primary shard 或 replica shard，都可以</li><li>query phase:每个 shard 将自己的搜索结果（其实就是一些 doc id）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果</li><li>fetch phase:接着由协调节点根据 doc id 去各个节点上拉取实际的 document 数据，最终返回给客户端</li></ol><blockquote><p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法</p></blockquote><h2 id="调优指南"><a href="#调优指南" class="headerlink" title="调优指南"></a>调优指南</h2><h3 id="filesystem-cache"><a href="#filesystem-cache" class="headerlink" title="filesystem cache"></a>filesystem cache</h3><p>你往 es 里写的数据，实际都写到磁盘文件里去了，查询的时候，操作系统会将磁盘文件里的数据自动缓存到 filesystem cache 里面去。</p><p><img src="/img/es/280A6A711E43D74F32D492EA0A660F00.jpg" alt="filesystem cache"></p><p>es 的搜索引擎严重依赖于底层的 filesystem cache，你如果给 filesystem cache 更多的内存，尽量让内存可以容纳所有的 idx segment file 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</p><p>归根结底，要让 es 性能好，最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。</p><p>如果内存留给 filesystem cache 的是 100G，将索引数据控制在 100G 以内，这样数据几乎全部走内存来搜索，性能非常之高，一般可以在 1 秒以内。</p><p>假设现在有一行数据。id,name,age …. 30 个字段。但是现在搜索，只需要根据 id,name,age 三个字段来搜索。如果傻乎乎往 es 里写入一行数据所有的字段，就会导致说 90% 的数据是不用来搜索的，结果硬是占据了 es 机器上的 filesystem cache 的空间，<strong>单条数据的数据量越大，就会导致 filesystem cahce 能缓存的数据就越少</strong>。其实，仅仅写入 es 中要用来检索的少数几个字段就可以，比如说就写入 id,name,age 三个字段，然后你可把其他的字段数据存在 mysql&#x2F;hbase 里，一般建议用 es + hbase 架构。</p><p>hbase 的特点是适用于海量数据的在线存储，对 hbase 可以写入海量数据，但是不要做复杂的搜索，做很简单的一些根据 id 或者范围进行查询的这么一个操作就可以了。从 es 中根据 name 和 age 去搜索，拿到的结果可能就 20 个 doc id，然后根据 doc id 到 hbase 里去查询每个 doc id 对应的完整数据，返回给前端。</p><p>写入 es 的数据最好小于等于，或者是略微大于 es 的 filesystem cache 的内存容量。然后你从 es 检索可能就花费 20ms，然后再根据 es 返回的 id 去 hbase 里查询，查 20 条数据，可能也就耗费个 30ms，如果1T 数据都放 es，会每次查询都是 5~10s，现在性能就会很高，每次查询就是 50ms。</p><h3 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h3><p>如果 es 集群中每个 node 写入的数据量还是超过了 filesystem cache 一倍，就可以做数据预热。<br>对于热点数据，自己后台搞个系统，每隔一会儿，后台系统去搜索一下热数据，刷到 filesystem cache 里去，后面用户实际上看热数据时，他们直接从内存里搜索了，就很快。</p><p>对于觉得比较热的、经常会有人访问的数据，最好做一个专门的缓存预热子系统，就是对热数据每隔一段时间，提前访问一下，让数据进入 filesystem cache 里面去。这样下次别人访问的时候，性能一定会好很多。</p><h3 id="冷热分离"><a href="#冷热分离" class="headerlink" title="冷热分离"></a>冷热分离</h3><p>es 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将冷数据写入一个索引中，然后热数据写入另外一个索引中，这样可以确保热数据在被预热之后，尽量都让他们留在 filesystem os cache 里，别让冷数据给冲掉。</p><h3 id="document-模型设计"><a href="#document-模型设计" class="headerlink" title="document 模型设计"></a>document 模型设计</h3><p>对于 MySQL，我们经常有一些复杂的关联查询。在 es 里面的复杂的关联查询尽量别用，一旦用了性能一般都不太好。<br>最好是在 Java 系统里就完成关联，将关联好的数据直接写入 es 中。搜索的时候，就不需要利用 es 的搜索语法来完成 join 之类的关联搜索。<br>另外对于一些太复杂的操作，比如 join&#x2F;nested&#x2F;parent-child 搜索都要尽量避免，性能都很差的。</p><h3 id="分页性能优化"><a href="#分页性能优化" class="headerlink" title="分页性能优化"></a>分页性能优化</h3><p>es 的分页较坑的。假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p><p>解决方案</p><p><strong>不允许深度分页（默认深度分页性能很差）</strong></p><p><strong>类似于抖音视频不断下拉出一页一页视频数据</strong></p><p>scroll 会一次性生成所有数据的一个快照，然后每次滑动向后翻页就是通过游标 scroll_id 移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。<br>但是，唯一注意的一点就是，不能随意跳到任何一页。不能先进入第 10 页，然后去第 120 页，然后又回到第 58 页，不能随意乱跳页。<br>初始化时必须指定 scroll 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。<br>除了用 scroll api，你也可以用 search_after 来做，search_after 的思想是使用前一页的结果来帮助检索下一页的数据，这种方式也不允许随意翻页，只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://gitee.com/shishan100/Java-Interview-Advanced">中华石杉–互联网Java进阶面试训练营</a></p><p>2.<a href="https://elasticsearch.cn/article/6202">Elasticsearch性能调优</a></p><h2 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a><a href="/ElasticSearch">推荐书单</a></h2>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>ElasticSearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/posts/3732689918.html"/>
    <url>/posts/3732689918.html</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一般情况下，客户端传入任务，需要服务端快速处理并返回结果。如果服务端每接受到一个任务，就创建一个线程，这种方式将会创建数以万记的线程。使操作系统频繁的进行线程上下文切换，无故增加系统负载，而线程的创建和消亡都是需要耗费系统资源，也无疑浪费了系统资源。<br>线程池能很好地解决这个问题，它预先创建了若干数量的线程，并且不由用户直接对线程的创建进行控制，在此前提下重复使用固定或较为固定数目的线程来完成任务的执行。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>提高线程复用能力</li><li>消除了频繁创建和销毁线程的系统资源开销</li><li>避免创建过多的线程耗尽进程内存空间，同时减少线程上下文切换次数</li><li>充分利用CPU多核资源，最大限度的利用多核提升应用程序性能</li></ul><h2 id="java线程池详解"><a href="#java线程池详解" class="headerlink" title="java线程池详解"></a>java线程池详解</h2><p>java5中增加了内置线程池实现ThreadPoolExecutor，构造方法如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>      <span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>      <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>      <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>      <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>      <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">,</span>      <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>      <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 。。。</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>corePoolSize: 最大核心线程数</li><li>maximumPoolSize: 最大线程数</li><li>keepAliveTime: 非核心线程空闲存活时间</li><li>unit: 空闲存活时间单位</li><li>workQueue: 存放任务的阻塞队列</li><li>threadFactory: 创建新线程的工厂，所有线程都通过该工厂创建，有默认实现。可自定义线程名字，但是默认线程名称格式为**pool-&lt;线程池编号&gt;-thread-&lt;线程编号&gt;**，这对于监控和日志输出并不明显，所以最好自定义线程名（见<a href="3732689918.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a>2）</li><li>handler: 拒绝执行任务策略</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>创建完ThreadPoolExecutor，当有任务提交时，使用execute或submit方法来执行相关线程池操作</p><p>执行流程图如下</p><p><img src="/img/threadpool/FDE05A3DF247E9795B312677C58A5CC9.jpg" alt="线程池执行流程"></p><ol><li>如果线程池中存活的核心线程数小于最大核心线程数corePoolSize，线程池创建一个核心线程去处理提交的任务</li><li>如果线程池中核心线程数已满，即线程数已等于corePoolSize，当有一个新提交的任务时，会被放进任务队列workQueue排队等待执行</li><li>当线程池里面存活的线程数已等于corePoolSize,且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即判断最大线程数是否已满，如果没满，创建一个非核心线程执行提交的任务</li><li>如果当前线程数达到了maximumPoolSize，还有新的任务要执行，直接采用拒绝策略处理</li></ol><h4 id="execute与submit的区别"><a href="#execute与submit的区别" class="headerlink" title="execute与submit的区别"></a>execute与submit的区别</h4><ul><li>execute适用于不需要关注返回值的场景</li><li>submit方法适用于需要关注返回值的场景</li></ul><p>下面有几个注意点，非常重要，无论你是面试官还是候选人都必须很清楚下列这些概念和原理</p><h3 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h3><p>可通过自定义ThreadPoolExecutor或用jdk内置的Executors来创建一系列的线程池（不推荐使用内置的Executors创建，建议自定义ThreadPoolExecutor，后面会详细说明这一点）</p><ul><li>newFixedThreadPool<br>创建固定线程数量的线程池，用于已知并发压力情况下，对线程数做限制的场景，比较适合执行时间长的任务</li><li>newSingleThreadExecutor<br>创建只有一个线程的线程池，用于需要保证顺序执行的场景，并只有一个线程在执行，比较适合一个任务接一个任务执行的场景</li><li>newCachedThreadPool<br>创建线程数量会自动扩容, 自动销毁的线程池。可无限扩大，比较适合处理执行时间较短的任务</li><li>newScheduledThreadPool<br>创建支持定时任务的线程池。可延时启动，定时启动，用于需要多个后台线程执行周期任务的场景</li><li>newWorkStealingPool<br>Java8开始才有的，内部会构建ForkJoinPool并行处理任务，不保证处理顺序。拥有多个任务队列，可减少连接数，创建当前可用cpu数量的线程来并行执行。适合使用在很耗时的任务中</li></ul><p>相应的源码实现在Executors类中</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Executors<span class="token punctuation">.</span>FinalizableDelegatedExecutorService</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newWorkStealingPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> parallelism<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span>parallelism<span class="token punctuation">,</span>    <span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span>defaultForkJoinWorkerThreadFactory<span class="token punctuation">,</span>    <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>ScheduledThreadPoolExecutor类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>              DEFAULT_KEEPALIVE_MILLIS<span class="token punctuation">,</span> MILLISECONDS<span class="token punctuation">,</span>              <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>ForkJoinPool类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> parallelism<span class="token punctuation">,</span>       <span class="token class-name">ForkJoinWorkerThreadFactory</span> factory<span class="token punctuation">,</span>       <span class="token class-name">UncaughtExceptionHandler</span> handler<span class="token punctuation">,</span>       <span class="token keyword">boolean</span> asyncMode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>parallelism<span class="token punctuation">,</span> factory<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> asyncMode<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> MAX_CAP<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> DEFAULT_KEEPALIVE<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="为啥不建议使用Executors创建线程池"><a href="#为啥不建议使用Executors创建线程池" class="headerlink" title="为啥不建议使用Executors创建线程池"></a>为啥不建议使用Executors创建线程池</h4><p>弊端如下</p><ul><li>FixedThreadPool和SingleThreadExecutor<br>看上述源码，使用的队列为LinkedBlockingQueue，该队列允许的队列最大长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li><li>CachedThreadPool和ScheduledThreadPool<br>还是看上述源码，允许创建的线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM</li></ul><p>所以在有大量请求的线程池场景中, 更推荐自定义ThreadPoolExecutor来创建线程池</p><h3 id="核心线程"><a href="#核心线程" class="headerlink" title="核心线程"></a>核心线程</h3><p>默认情况</p><ul><li>核心线程不会预先创建，只有在有任务时才会创建。</li><li>核心线程不会因为空闲而被终止，keepAliveTime参数不适用于它</li></ul><p>但是ThreadPoolExecutor类中有如下方法，可以改变这些默认情况</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//预先创建所有核心线程</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">prestartAllCoreThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//创建一个核心线程，若所有核心线程都已创建，则返回false</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">prestartCoreThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//方法参数设定为true，则keepAliveTime参数也适用于核心线程</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">allowCoreThreadTimeOut</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3><p>非核心线程执行任务完毕，并不是马上被销毁，而是等待一段时间，再被销毁<br>目的有两方面</p><ul><li>如果执行任务完毕，线程不被销毁，也没有keepAliveTime，那么此线程会永远堆积在线程池中，一旦这样的线程数量达到maximumPoolSize上限，这样任务队列workQueue中正在排队等待的任务永远不会进入线程池被执行，而是会被拒绝策略直接处理掉。所以要及时销毁，让线程池中的线程数不会达到maximumPoolSize，方便任务队列workQueue中正在排队等待的任务进线程池，被新创建的非核心线程执行，而不是让这些正在等待的任务被拒绝策略处理</li><li>见前述，线程池目的是减少频繁创建和销毁线程开销。空闲等待的线程如果还没到keepAliveTime，此时任务队列workQueue中正在排队等待的任务可以进入线程池被此线程执行，这样就最大化利用已有线程进行任务操作。如果马上销毁，任务进线程池后还需要重新创建一个非核心线程执行提交的任务，增加了创建和销毁线程开销。任务队列workQueue中如果没有正在排队等待的任务，则在达到keepAliveTime后，马上被销毁</li></ul><h3 id="常见任务队列workQueue"><a href="#常见任务队列workQueue" class="headerlink" title="常见任务队列workQueue"></a>常见任务队列workQueue</h3><p>先描述<a href="3732689918.html#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E5%9E%8B">线程池类型</a>源码中出现的几个队列</p><ul><li><p>LinkedBlockingQueue<br>可设置容量队列，基于链表结构的阻塞队列，按FIFO排序，容量可自行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。默认无界。newFixedThreadPool线程池使用此队列</p></li><li><p>SynchronousQueue<br>一个不存储元素，没有实际存储空间的同步阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene。newCachedThreadPool线程池使用此队列</p></li><li><p>DelayedWorkQueue<br>延迟队列，是一个任务定时周期的延迟执行队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用此队列</p></li></ul><p>ThreadPoolExecutor还支持自定义队列来实现，主要会用到下面这两个</p><ul><li>ArrayBlockingQueue<br>有界队列，是一个用数组实现的有界阻塞队列，按FIFO排序量</li><li>PriorityBlockingQueue<br>优先级队列，是具有优先级的，基于堆的无界阻塞队列</li></ul><p><strong>注意: 由前文<a href="3732689918.html#%E4%B8%BA%E5%95%A5%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0">为啥不建议使用Executors创建线程池</a>可知，无界队列允许的队列最大长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM，因此不建议自定义队列使用无界队列，怕没设置队列长度引发OOM。<br>这也是不建议使用Executors的最重要原因</strong></p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>JDK内置4种线程池拒绝策略，但是最好还是自定义拒绝策略</p><ol><li>CallerRunsPolicy（调用者运行策略）</li></ol><ul><li>概念<br>只要线程池没有关闭，就由提交任务的当前线程处理。</li><li>使用场景<br>一般在不允许失败、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但由于是调用者线程自己执行，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就低了</li></ul><ol start="2"><li>AbortPolicy（中止策略）</li></ol><ul><li>概念<br>直接抛出拒绝执行的异常，意思也就是打断当前执行流程</li><li>使用场景<br>没有特殊场景，但要正确处理抛出的异常</li></ul><blockquote><p>ThreadPoolExecutor中默认的策略就是AbortPolicy</p></blockquote><ol start="3"><li>DiscardPolicy（丢弃策略）</li></ol><ul><li>概念<br>直接丢弃任务，不触发任何动作</li><li>使用场景<br>没有。如果提交的任务无关紧要，可以使用这个策略。毫无声息的丢弃任务。但是基本上提交的任务都是有用的，所以这个策略基本不会被用到</li></ul><ol start="4"><li>DiscardOldestPolicy（丢弃最老策略）</li></ol><ul><li>概念<br>如果线程池未关闭，就弹出任务队列workQueue头部的任务元素，然后尝试执行</li><li>使用场景<br>这个策略也会丢弃任务，而且也是毫无声息的丢弃任务，但特点是丢弃的是任务是排队等待的任务中最老的那个任务，而且会等待执行优先级较高的任务</li></ul><ol start="5"><li>自定义拒绝策略<br>实现RejectedExecutionHandler接口，编写自定义的RejectHandler 。来实现自己的拒绝策略</li></ol><h4 id="建议自定义拒绝策略原因"><a href="#建议自定义拒绝策略原因" class="headerlink" title="建议自定义拒绝策略原因"></a>建议自定义拒绝策略原因</h4><ol><li>使用默认AbortPolicy时，抛出的拒绝执行的异常是RejectedExecutionException。这是个运行时异常，对于运行时异常编译器并不强制catch它，所以<strong>默认拒绝策略要慎重使用</strong>。所以在线程池处理的任务非常重要时，建议自定义拒绝策略</li><li>执行execute方法时，如果任务在执行过程中出现运行时异常，会导致当前执行任务的线程自动终止；但最致命的是任务虽然异常了，但是却获取不到任何通知，这会让人误以为任务都执行正常。虽然线程池提供了很多用于异常处理的方法，但是最稳妥和简单的方案还是捕获所有异常并按需处理。详见《Java 并发编程实战》7.3节“处理非正常的线程终止”，详细介绍了异常处理的方案</li></ol><h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><p>调用shutdownNow和shutdown两个方法来实现</p><ul><li>shutdownNow<br>对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表</li><li>shutdown<br>调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务</li></ul><p>关闭线程池之后，可用isTerminated来判断所有的线程是否执行完成，千万不要用isShutdown，isShutdown只是返回是否调用过shutdown的结果</p><h2 id="线程池大小选择策略"><a href="#线程池大小选择策略" class="headerlink" title="线程池大小选择策略"></a>线程池大小选择策略</h2><p>线程池大小不合适，太多或太少，都会导致麻烦，需要去考虑一个合适的线程池大小。</p><p>一般思路</p><ul><li><p>CPU密集型<br>如果任务主要是进行计算，那就意味着CPU的处理能力是稀缺的资源，不能通过大量增加线程数提高计算能力，因为如果线程太多，反而会导致大量的上下文切换开销。所以，通常建议线程池大小按照CPU核的数目N或者N+1设置</p></li><li><p>IO密集型<br>如果是需要较多等待的任务，比如I&#x2F;O操作较多，可考虑的计算方法</p><p><strong>线程数 &#x3D; CPU核数 × 目标CPU利用率 ×（1 + 平均等待时间&#x2F;平均工作时间）</strong></p></li></ul><p>但是这些都不是精准预计，需要根据测试或者分析进行计算，在实际中验证和调整</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://mp.weixin.qq.com/s/nb8V_RXC8bklAviEsR4cjw">Java线程池必知的8大拒绝策略</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/PmfP3r2VhJ7AzQzC7owZnQ">创建线程以及线程池时候要指定与业务相关的名字，以便于追溯问题</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程</title>
    <link href="/posts/368864908.html"/>
    <url>/posts/368864908.html</url>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><ul><li><p>进程（Process）<br>机器内存中运行的应用程序，应用程序启动后系统会分配一块内存空间给这个进程，进程与进程间相互独立，即内存不共享。一个进程允许启动N个线程，例如Windows系统中一个后缀是.exe 程序就是一个进程。进程是系统资源分配的基本单位</p></li><li><p>线程（Thread）<br>进程中的某个执行流程，一个进程允许启动N个线程，例如java进程中可以运行N个线程。进程和线程的关系是一对多，线程与线程之间共享进程的内存。线程是调度器（即 CPU）调度的基本单位</p></li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>进程是资源分配的最小单位，线程是程序执行的最小单位</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此 CPU<br>切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC）进行。但是如何处理好同步与互斥是编写多线程程序的难点</li><li>多进程程序更健壮，多线程程序只要一个线程死掉，整个进程虽然不会死掉，但是功能会受影响，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间</li></ul><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul><li><p>并发<br>当我们的计算机硬件资源只有一个CPU也就是处理器时，执行多个线程时实际上是将多个线程按时间段进行分割，每个时间段执行一个线程。比如上午10点56分执行线程一，10点58分执行线程二，这样的执行方式就是并发</p></li><li><p>并行<br>并行就完全相反，它是计算机有两个或两个以上CPU时，执行多线程时，cpu1执行线程1、cpu2执行线程2，这样的执行就是并行的方式。</p></li></ul><p>由上两个概念解析可知，并发是多个线程执行时没有时间上的重叠，而并行是可以有时间上的重叠</p><p>打个比方<br><b><br>你吃饭吃到一半，电话来了，你放下筷子接了电话，接完后继续拿起筷子吃饭，这就是并发<br>你吃饭吃到一半，电话来了，你边打电话边吃饭，这就是并行<br></b></p><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>目前已知应该一共4种方式</p><h3 id="1-继承Thread类重写run方法"><a href="#1-继承Thread类重写run方法" class="headerlink" title="1.继承Thread类重写run方法"></a>1.继承Thread类重写run方法</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadExample</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>MyThread类继承Thread类，重写run方法，然后调用start方法启动线程，当创建完thread对象后该线程并没有被启动执行.</p><p>调用了start方法后才是真正启动了线程。其实当调用start方法时，线程是处于就绪状态，就绪状态是表明该线程已获取了除CPU资源外的其它资源，等获取CPU资源后才会真正处于运行状态</p><p>run方法执行完，线程就处于终止状态。</p><ul><li>优点<br>run方法内获取当前线程直接使用this就行了，无须使用Thread.currentThread()方法</li><li>缺点<br>Java不支持多继承，如果继承了Thread类，就不能再继承其它类，另外任务与代码没有分离，当多个线程执行一样的任务时候需要多份任务代码，而Runable没有这个限制。而且任务没有返回值</li></ul><p><strong>注意: 线程执行顺序与创建顺序无关</strong></p><h3 id="2-实现Runnable接口的run方法"><a href="#2-实现Runnable接口的run方法" class="headerlink" title="2.实现Runnable接口的run方法"></a>2.实现Runnable接口的run方法</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadExample</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">RunnableTask</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RunnableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">RunnableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>两个线程公用同一个task代码逻辑。RunableTask还可以添加参数进行任务区分</p><ul><li>优点<br>RunableTask可继承其他类</li><li>缺点<br>任务没有返回值</li></ul><h3 id="3-实现Callable接口使用FutureTask"><a href="#3-实现Callable接口使用FutureTask" class="headerlink" title="3.实现Callable接口使用FutureTask"></a>3.实现Callable接口使用FutureTask</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadExample</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建异步任务</span>    <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CallerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 等待任务执行完毕，并返回结果</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CallerTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token string">"hello world!"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ul><li>优点<br>有返回值</li><li>缺点<br>futureTask.get()是一个阻塞方法。要想不阻塞，只能在futureTask.get()代码之前，加上下列代码</li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>futureTask<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//检查是否完成，如果没完成，那可以让主线程去做其他操作，不会被阻塞</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><h3 id="4-使用线程池"><a href="#4-使用线程池" class="headerlink" title="4.使用线程池"></a>4.使用线程池</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadExample</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ThreadPoolTask</span> threadPoolTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ExecutorService</span> fixedThreadPool <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>            <span class="token number">5</span><span class="token punctuation">,</span>            <span class="token number">10</span><span class="token punctuation">,</span>            <span class="token number">0L</span><span class="token punctuation">,</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      fixedThreadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>threadPoolTask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    fixedThreadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程名："</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\nhello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>对于线程池的说明可见<a href="3732689918.html">线程池篇</a>，相关的注意措施都已在那篇说明</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>线程在代码中执行时，会根据具体操作步骤时刻变化自己的状态。整个线程执行过程就是它的生命周期</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>线程状态一共有7种状态，但是分为6大类，详见Thread类中的内部枚举类State</p><p>源码(java11)如下:</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">&#123;</span>       NEW<span class="token punctuation">,</span>       RUNNABLE<span class="token punctuation">,</span>       BLOCKED<span class="token punctuation">,</span>       WAITING<span class="token punctuation">,</span>       TIMED_WAITING<span class="token punctuation">,</span>       TERMINATED<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>如下列表对这些状态进行说明</p><table><thead><tr><th align="left">线程状态分类</th><th align="left">简单说明</th></tr></thead><tbody><tr><td align="left">NEW</td><td align="left">前述线程创建方式中已说明，线程创建完就处于此状态，只有调用start方法才会到下一状态</td></tr><tr><td align="left">RUNNABLE</td><td align="left">运行状态其实包含running和ready两个状态</td></tr><tr><td align="left">BLOCKED</td><td align="left">线程被锁（之后会详细说明锁相关知识）阻塞</td></tr><tr><td align="left">WAITING</td><td align="left">线程处于此状态时候，还需要其他状态对它进行通知或中断等操作，否则会一直处于这个等待状态</td></tr><tr><td align="left">TIME_WAITING</td><td align="left">和上列不同之处在于它有时间限制，当在指定时间过后还没等到其他线程通知或中断等操作，就不等了，直接返回</td></tr><tr><td align="left">TERMINATED</td><td align="left">线程执行结束后状态</td></tr></tbody></table><p>如果有过线上调优经验，在导出的dump文件里会发现每个线程都有这些线程状态说明，从而方便我们定位线上系统性能问题发生的具体原因</p><h4 id="为啥running和ready两个状态可以合并成runnable状态？"><a href="#为啥running和ready两个状态可以合并成runnable状态？" class="headerlink" title="为啥running和ready两个状态可以合并成runnable状态？"></a>为啥running和ready两个状态可以合并成runnable状态？</h4><p>之前线程创建方式中已说明: 就绪状态(ready)是表明该线程已获取了除CPU资源外的其它资源,获取CPU资源后才会真正处于运行状态(running)<br>。在JVM层面，它隐藏了这两个状态，只能看到runnable状态（其实部分wating状态也被隐藏了）</p><p>示意图如下</p><p><img src="/img/thread/EB20E11803B109A5EAC207E8F172B405.jpg" alt="状态合并了"></p><p>这样做的原因是因为</p><ul><li>操作系统的线程状态是围绕着cpu这一核心与JVM侧重点不同</li><li>JVM线程状态的改变通常只与<strong>自身显式引入机制</strong>有关，就是说线程状态的改变，通常是自身机制引发<br>比如后面要说的synchronize让线程进入BLOCKED状态，sleep，wait等方法则让它进入WATING状态</li></ul><h3 id="生命周期过程"><a href="#生命周期过程" class="headerlink" title="生命周期过程"></a>生命周期过程</h3><p>见下图，该图参考了参考书单2的4.1.4小节（个人认为状态描述正确，但是触发状态变化的方法持保留意见）</p><p><img src="/img/thread/31DBCCB46DD640361030DEEB1B62B1A1.jpg" alt="线程生命周期过程"></p><ol><li>创建好线程，它处于NEW状态</li><li>调用start方法后，开始运行，进入READY状态。当获取cpu资源后，处于RUNNING状态。统称为RUNNABLE状态</li><li>执行wait方法后，进入WAITING转态。前述列表中已说，其他线程通知或中断操作后，它才能返回到RUNNABLE状态</li><li>如果执行wait（long）或sleep（long）等带超时时间参数的方法后，线程进入TIMED_WAITING状态。超时时间一过就不等了，直接返回到RUNNABLE状态</li><li>线程调用同步方法，在获取不到锁时，会进入到BLOCKED状态（锁知识会在之后详细说明）</li><li>执行run或interrupt方法后，就进入TERMINATED状态。整个线程执行完毕，生命周期终结</li></ol><p><strong>注意: 如图所示，状态变化不一定就执行上述这些方法，还可以执行图中展示的其他方法</strong></p><h3 id="触发线程状态变化的方法说明"><a href="#触发线程状态变化的方法说明" class="headerlink" title="触发线程状态变化的方法说明"></a>触发线程状态变化的方法说明</h3><h4 id="Thread类方法"><a href="#Thread类方法" class="headerlink" title="Thread类方法"></a>Thread类方法</h4><ul><li>Thread.start()<br>其实已经写了很多遍了，通过这个方法线程开始进入RUNNABLE状态</li><li>Thread.yield()<br>线程获取的cpu资源用完之后，调用此方法从RUNNING状态切换为READY状态。所以上图中也称为<strong>系统调度</strong></li><li>Thread.sleep(long)<br>static方法，线程类和线程实例调用，效果一样</li><li>Thread.join()和Thread.join(long)<br>让父线程等待子线程结束之后才继续运行。其实是调用join方法的线程（父线程）进入TIMED_WAITING状态，等待join方法所属的线程（子线程）结束后再继续运行</li><li>Thread.run()<br>执行操作，完毕后线程操作结束</li><li>Thread.interrupt()<br>将线程的中断标志位设置为true，并没有中断线程，它只是向线程发送一个中断信号</li><li>Thread.isInterrupted()<br>判断线程是否中断，不改变标志位</li><li>Thread.interrupted()<br>判断当前线程是否中断，如果是true，表明线程已中断，返回true，返回前将标志位设置为false</li></ul><p>其他方法</p><ul><li>Thread.currentThread()<br>获取当前线程</li><li>Thread.isAlive()<br>某个线程实例是否存活</li></ul><h4 id="Object类方法"><a href="#Object类方法" class="headerlink" title="Object类方法"></a>Object类方法</h4><ul><li>Object.wait()和Object.wait(long)<br>把持有对象线程的控制权交出去，然后处于等待状态,wait()是转换为WAITING状态，wait(long)是转换为TIMED_WAITING状态</li><li>Object.notify()<br>通知某个正在等待对象控制权的线程可以继续运行</li><li>Object.nofifyAll()<br>通知所有等待这个对象控制权的线程继续运行，如果有多个正在等待该对象控制权的线程时，具体唤醒哪个线程由操作系统进行调度</li></ul><h5 id="为什么wait和notify、notifyAll是Object类的方法而不是Thread类？"><a href="#为什么wait和notify、notifyAll是Object类的方法而不是Thread类？" class="headerlink" title="为什么wait和notify、notifyAll是Object类的方法而不是Thread类？"></a>为什么wait和notify、notifyAll是Object类的方法而不是Thread类？</h5><p>wait和notify、notifyAll这几个方法都会涉及到并发编程中的锁机制。因为锁是每个对象都具备的特性，因此操作锁的方法必然和对象有关，Object类是java里所有对象基类，因此这些方法是Object类方法，而不是Thread类特有的。</p><p>说穿了，它们都和对象的监视器锁有关。也就是前述的对象控制权。它们几个在被执行时，都必须保证当前运行的线程取得了对象控制权（监视器锁）。wait一般是挂起自己，释放对象的监视器锁，让其他线程可以获得，还把自己加入等待对象控制权的线程中，直到其他线程调用了Object的notify、notifyAll方法，自身才会被唤醒（如果是调用wait（long）方法就是加了等待时间），而notify、notifyAll是在释放监视器锁同时，唤醒正在等待对象控制权的线程。如果调用的是notify，则哪个线程取得对象控制权是随机不确定的，如果是notifyAll，则是所有等待对象控制权的线程一起被唤醒，哪个线程取得对象控制权要看操作系统的调度</p><p>后续章节会对java的锁机制进行进一步的说明</p><h4 id="LockSupport类方法"><a href="#LockSupport类方法" class="headerlink" title="LockSupport类方法"></a>LockSupport类方法</h4><p>LockSupport类是一个线程阻塞工具类，所有方法都是静态方法，可以让线程在任意位置阻塞，当然阻塞之后肯定会有唤醒</p><ul><li>LockSupport.park()<br>使当前线程挂起，进入线程WAITING状态，且操作系统不再会对它进行调度，直到其他线程调用了unpark方法<br>park不同于Thread.yield(), yield只是告诉操作系统可以先让其他线程运行，但自己依然是可运行状态，而park会放弃调度资格，使线程进入WAITING状态</li><li>LockSupport.unpark(Thread)<br>使参数传入的线程恢复成RUNNABLE状态，解除阻塞方法</li><li>LockSupport.parkNanos(long nanos)<br>阻塞当前线程，最长不超过纳秒数，只是在park基础上增加了超时返回时间</li><li>LockSupport.parkUntil(long deadline)<br>也是阻塞当前线程。参数是绝对时间，时间单位为毫秒，是从1970-01-01开始到现在某个时间点换算为毫秒后相减的值</li></ul><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="Thread-sleep和Object-wait的异同点"><a href="#Thread-sleep和Object-wait的异同点" class="headerlink" title="Thread.sleep和Object.wait的异同点?"></a>Thread.sleep和Object.wait的异同点?</h4><ul><li><strong>sleep不释放监视器锁，wait释放</strong></li><li>都可以暂停线程执行</li><li>sleep用于暂停执行线程，wait用于线程之间通信和交互</li><li>sleep执行完，线程会被自动唤醒。wait只能使用Object.wait(long)使线程自动被唤醒。否则只能让其他线程调用同一个Object的notify和notifyAll方法唤醒</li></ul><h4 id="notify和notifyALL的异同点"><a href="#notify和notifyALL的异同点" class="headerlink" title="notify和notifyALL的异同点?"></a>notify和notifyALL的异同点?</h4><ul><li>notify唤醒1个线程，notifyAll唤醒所有线程</li><li>notify唤醒哪个线程随机，notifyAll是所有线程参与获取监视器锁的竞争，竞争成功就执行，不成功就等锁下一次被释放，然后继续参与竞争</li></ul><h4 id="为啥要调用Thread-start-开始执行run方法，不能直接调用run么？"><a href="#为啥要调用Thread-start-开始执行run方法，不能直接调用run么？" class="headerlink" title="为啥要调用Thread.start()开始执行run方法，不能直接调用run么？"></a>为啥要调用Thread.start()开始执行run方法，不能直接调用run么？</h4><p>线程启动后，是进入ready状态，虽然从jvm层面看是runnable状态（见前述）。但是它需要在运行前，获取到CPU时间片，做好线程运行的准备。这件事情是由start方法来执行，然后再自动执行run方法，进行真正的操作。直接执行run方法对于Thread来说只是一个普通方法，并不会在线程中执行，这样就不是多线程操作了</p><p>简而言之，start方法会启动线程，并让线程进入ready状态，进行线程操作的准备工作。而run方法只是一个普通方法调用，还是在main主线程执行。另外多嘴一句:<br>start方法只能被调用一次，多次被调用会抛IllegalThreadStateException异常。run可以被重复调用很多次</p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>又称Daemon Thread,在java中线程可分为守护线程和应用线程。程序员用自己写的代码创建的线程就是应用线程</p><p>正如它的名字，守护线程是系统的守护者，在后台默默地完成一些系统性的服务，比如垃圾回收线程。而应用线程可认为是系统的工作线程，它会完成这个程序应该要完成的相关操作。如果应用线程全部结束，则意味着这个程序实际上已无事可做。守护线程要守护的对象已经不存在，那么整个应用程序就该结束。因此，当一个java应用只有守护线程时，Java虚拟机就会自然退出</p><p>java类的main方法创建的线程都是main线程的子线程。父线程是守护线程，则子线程也是守护线程。父线程是应用线程（非守护线程），则子线程就是应用线程</p><p>父线程在创建子线程，且启动子线程之前，可用setDaemon(true)方法，将相应的线程设置为守护或应用线程（非守护线程）。如果没有手动设置某线程的优先级，那么该线程的优先级默认值和其父线程相同</p><p>父子线程的生命周期没有必然联系，任何一个线程先结束，都不会影响其父或子线程的生命周期</p><p>守护线程优先级较低，只是用来为系统中其他对象和线程提供服务的</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>每个线程都会被分配CPU时间片来执行自身的任务，当某个线程在执行完CPU时间片，切换到另外一个线程前会保存自身状态，以便下次再切换回来时候可以再加载自身状态，这种从保存到再加载过程就被称为一次上下文切换</p><p>上下文切换是计算密集型的，每次切换需要纳秒量级时间，所以对系统来说意味着大量CPU时间的被消耗。而且可能是操作系统中消耗时间最多的操作</p><h2 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>提高吞吐率</li><li>提高响应速度</li><li>利用多核</li><li>最小化系统资源的使用</li><li>简化程序结构</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>安全问题</li><li>活性问题。死锁、活锁、饥饿</li><li>上下文切换产生的系统时间消耗</li><li>可靠性。单进程多线程，进程死则所有线程都死！</li></ul>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Istio</title>
    <link href="/posts/3498159868.html"/>
    <url>/posts/3498159868.html</url>
    
    <content type="html"><![CDATA[<h1 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>服务网格是一个负责微服务之间网络通信的基础设施层，提供了管理、控制和监控网络通信的功能，本质上是Sidecar模式的网络拓扑形态</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>动态路由</li><li>故障注入</li><li>熔断</li><li>安全</li><li>多语言支持</li><li>多协议支持</li><li>指标和分布式追踪</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>可见性（Visibility）<br>运行时指标<strong>遥测</strong>、分布式跟踪</li><li>可管理性（Manage Ability）<br>服务发现、负载均衡、运行时动态路由</li><li>健壮性（Resilience）<br>超时、重试、熔断等弹性能力</li><li>安全性（Security）<br>服务间访问控制、TLS加密通信</li></ul><blockquote><p>遥测（Telemetry）是工业上常用的一种术语，是指从远程设备中收集数据，并传输到接收设备进行监测。在软件开发中，遥测的含义引申为对各种指标（metric）数据进行收集，并监控、分析这些指标</p></blockquote><h1 id="Istio架构"><a href="#Istio架构" class="headerlink" title="Istio架构"></a>Istio架构</h1><p>业务代码无侵入和网络层的全权代理是服务网格重要的优势，从逻辑上分成数据平面（Data Plane）和控制平面（Control Plane）</p><ul><li><p>数据平面<br>由一组和业务服务成对出现的Sidecar代理（Envoy）构成，它的主要功能是接管服务的进出流量，传递并控制服务和Mixer组件的所有网络通信（Mixer稍后会介绍）</p></li><li><p>控制平面<br>主要包括Pilot、Mixer、Citadel和Galley4个组件，主要功能是通过配置和管理Sidecar代理来进行流量控制，并配置Mixer去执行策略和收集遥测数据</p></li></ul><p><img src="/img/istio/2ECC92ED-B776-4C12-B79F-B112C0995D7D.png" alt="架构图"></p><p>Istio追求尽可能的透明，通过各种解耦设计让系统对内对外都没有依赖。同时，还提供了高度的扩展性。Istio认为随着应用的增长和服务的增多，<strong>扩展策略系统是最主要的需求</strong>，因此它被设计为以<strong>增量</strong>的方式进行扩展。可移植也是Istio在设计中充分考虑的因素，它被设计为支持多种平台，以便服务可以被方便地迁移到不同的云环境中</p><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><h2 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h2><p>Envoy作为Sidecar代理本质上是一个为面向服务的架构而设计的7层代理和通信总线。基于C++11开发而成。除了具有强大的网络控制能力外，Envoy还可以将流量行为和数据提取出来发送给Mixer组件，用以进行监控</p><p> 主要功能</p><ul><li>HTTP七层路由</li><li>支持gRPC、HTTP&#x2F;2</li><li>服务发现和动态配置</li><li>健康检查</li></ul><h2 id="Pilot"><a href="#Pilot" class="headerlink" title="Pilot"></a>Pilot</h2><p>Pilot是Istio实现流量管理的核心组件<br>主要作用是配置和管理Envoy代理。比如可以为代理之间设置特定的流量规则，或者配置超时、重试、熔断这样的弹性能力。<br>Pilot会将控制流量行为的路由规则转换为Envoy的配置，并在运行时将它们广播到Envoy。<br>另外，Pilot还能够把服务发现机制抽象出来并转换成API分发给Envoy，使得后者具有服务发现的能力</p><p> 主要功能</p><ul><li>从平台（如Kubernetes）获取服务信息，完成服务发现</li><li>获取Istio的各项配置，转换成Envoy代理可读的格式并分发</li></ul><p><img src="/img/istio/43520D0D-3D2F-44BA-8DE9-46256242EA07.png" alt="架构图"></p><p>维护一套独立于平台的服务规则，并提供了一个平台适配器，以便接入各种不同的平台。规则API对运维人员开放，使得他们可以设置想要的流量规则，Pilot会把这些配置好的规则通过Envoy API分发给Envoy代理，以使其执行指定的规则，还公开了用于服务发现并且可以动态更新负载均衡和路由表的API</p><h2 id="Mixer"><a href="#Mixer" class="headerlink" title="Mixer"></a>Mixer</h2><p>主要功能是提供策略控制，并从Envoy代理收集遥测数据。<br>每次网络通信时Envoy都会向Mixer发出预检要求，用来检测调用者的合法性。调用之后Envoy代理会发送遥测数据供Mixer收集。一般情况下Envoy可以缓存这些数据，不需要频繁地调用Mixer。</p><p>个人理解就是在网络通信之前提供API网关作用，通信之后，提供服务监控功能。并且有自己的缓存，不需要Enovy频繁调用它</p><p><img src="/img/istio/02621BB7-1FF4-48F7-8AE3-747D6D97B549.png" alt="和Envoy交互图"></p><p>适配器是Mixer的重要组成部分，本质上是一个插件模型，每个插件叫作适配器。这项特性使得Mixer可以接入几乎任意的（只要定义好接口）后端基础设施。比如可以选择接入不同的日志收集器、监控工具和授权工具等；可以在运行时切换不同的适配器或者是打开（关闭）它们；还可以自定义适配器以满足特定需求。适配器极大提高了Mixer的扩展性，它让Istio的功能拥有了更多可能性</p><h2 id="Citadel"><a href="#Citadel" class="headerlink" title="Citadel"></a>Citadel</h2><p>与安全相关的组件，主要负责密钥和证书的管理。它可以提供服务间和终端用户的身份认证，还可以加密服务网格中的流量（不是Istio重点）</p><h2 id="Galley"><a href="#Galley" class="headerlink" title="Galley"></a>Galley</h2><p>2019年3月份发布的1.1版本中的新组件，现在是Istio主要的配置管理组件。</p><p>负责配置的获取、处理和分发。使用了一种叫作MCP（Mesh Configuration Protocol，网格配置协议）的协议与其他组件进行通信</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Istio架构分为数据平面和控制平面，使各个组件充分解耦，各司其职，这就是被称为第二代服务网格产品的原因。<br>数据平面即Envoy代理，负责流量的接管；<br>控制平面包含了Pilot、Mixer、Citadel和Galley，它们分别负责流量控制、策略控制、安全加固和数据收集。</p><p>通过这些组件的协同工作，Istio顺利地完成了<strong>流量管理、策略和遥测、可视化和安全</strong>这4大功能</p><h1 id="Pilot流量管理配置"><a href="#Pilot流量管理配置" class="headerlink" title="Pilot流量管理配置"></a>Pilot流量管理配置</h1><table><thead><tr><th align="left">配置资源</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">虚拟服务<br/>VirtualService</td><td align="left">用来定义路由规则，控制请求如何被路由的服务</td></tr><tr><td align="left">目标规则<br/>DestinationRule</td><td align="left">用来配置请求的策略</td></tr><tr><td align="left">服务入口<br/>ServiceEntry</td><td align="left">主要用来定义从外部如何访问服务网格</td></tr><tr><td align="left">网关<br/>Gateway</td><td align="left">在网格入口设置负载、控制流量等</td></tr></tbody></table><h2 id="VirtualService"><a href="#VirtualService" class="headerlink" title="VirtualService"></a>VirtualService</h2><p> 主要功能<br>定义路由规则，使请求（流量）可以依据这些规则被分发到对应的服务。路由的方式也有很多种，可以根据请求的源或目标地址路由，也可以根据路径、头信息，或者服务版本进行路由</p><p>下面介绍一下一些配置</p><ul><li><p>目标主机<br>VirtualService中的目标主机定义使用hosts关键字。除了定义域名外，也可以直接定义可路由的服务</p><p><img src="/img/istio/826A6A8F-7A86-426A-957A-F46D3975C516.png" alt="目标主机配置"></p></li><li><p>根据不同的版本对服务流量进行拆分<br>在Istio中服务版本依靠标签进行区分，可以定义不同种类的标签（如版本号、平台），对流量以不同的维度进行灵活的分配。拆分流量使用weight关键字来设置</p><p><img src="/img/istio/A6196787-6DC5-4160-81BC-13E431E25C2B.png" alt="流量拆分"></p></li><li><p>subset（子集）关键字<br>subset其实就是特定版本的标签，它和标签的映射关系定义在DestinationRule里。比如在subset中设置标签为“version:v1”，代表只有附带这个标签的Pod才能接受流量。Istio强制要求Pod设置带有version的标签，以此来实现流量控制和指标收集等功能</p></li><li><p>timeout关键字设置请求的超时时间</p><p><img src="/img/istio/5D702153-3D34-4F5E-887C-95DCCD30C081.png" alt="timeout关键字设置请求的超时时间"></p><p>访问ratings服务的请求设置10s超时</p></li><li><p>retries关键字设置重试</p><p><img src="/img/istio/5AA48379-D969-4479-AE99-CCA0B84071DE.png" alt="retries关键字设置重试"></p><p>表示最多重试3次，每次的超时时间为2s</p></li><li><p>fault关键字来设置故障注入</p><p><img src="/img/istio/B8FAD230-AA64-4940-A943-E680B10D7F0B.png" alt="fault关键字来设置故障注入"></p><p>注入了一个延迟故障，使得ratings服务10%的响应会出现5s的延迟。除了延迟，还可以设置终止或者返回HTTP故障码</p></li><li><p>通过match关键字定义匹配条件。</p><p><img src="/img/istio/4FF20965-52D8-4134-9204-4FA1AF75955F.png" alt="通过match关键字定义匹配条件"></p><p>对特定的URL进行匹配<br>可以同时设置多个匹配项。匹配的策略有很多，比如头信息、标签等<br>如图</p><p><img src="/img/istio/78D21B51-361D-4FAD-9372-82A5DC5A925D.png" alt="对特定的URL进行匹配"></p><p>VirtualService的路由配置规则有优先级。如果配置中定义了多条规则，则按照顺序优先匹配第一条，但是Header条件除外。如果匹配规则中设置了Header，则它具有最高优先级</p></li></ul><h2 id="DestinationRule"><a href="#DestinationRule" class="headerlink" title="DestinationRule"></a>DestinationRule</h2><p>DestinationRule通常都和VirtualService成对出现</p><p> 主要功能<br>当VirtualService的路由生效后，配置一些策略并应用到请求中。</p><p>另外，subset和标签的对应关系也被定义在DestinationRule中</p><ul><li><p>DestinationRule的配置，除定义VirtualService中要用的两个subset外，还设置以随机的方式对reviews服务进行负载均衡</p><p><img src="/img/istio/CFFE16FE-82E7-42E6-9F8E-13A08589CFAA.png" alt="DestinationRule的配置"></p></li><li><p>熔断（Circuit Breaker），一种服务降级处理的方式。当某个服务出现故障后，为了不影响下游服务而对其设置断流操作。可以在DestinationRule中实现这个功能</p></li></ul><p><img src="/img/istio/D10657FE-1FE8-45F7-8900-B83B7D20C36B.png" alt="熔断"></p><p>对reviews服务的最大连接只能有100个，如果超过这个数字就会熔断</p><blockquote><p>如果特定的subset定义了策略，但没有定义对应的VirtualService，则该策略并不会执行。此时，Istio会以默认的方式（轮询）将请求发送给目标服务的全部版本。因此官方推荐方式是给每个服务都定义路由规则，避免这种情况发生</p></blockquote><h2 id="ServiceEntry"><a href="#ServiceEntry" class="headerlink" title="ServiceEntry"></a>ServiceEntry</h2><p>如果有需求让服务能够访问外部系统，就需要用到ServiceEntry。它也是一种配置资源，用来给服务网格内的服务提供访问外部URL的能力。<br>Istio中的服务发现功能主要是依靠服务注册表实现的，ServiceEntry能够在注册表中添加外部服务，使得内部服务可以访问这些被添加的URL。所以，通过ServiceEntry就可以实现访问外部服务的能力。<br>个人理解就是流量对外的网关</p><p><img src="/img/istio/3E1513EE-ED49-44F6-90F7-35F3CD99DBE7.png" alt="ServiceEntry"></p><p>如图，配置一个外部的URL“*.foo.com”，使得网格内部的服务可以通过HTTP协议的80端口来访问它</p><h2 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h2><p>和ServiceEntry相反，外部请求想要访问网格内的服务就要用到Gateway。Gateway为进入网格的请求配置了一个负载均衡器，把VirtualService绑定到Gateway，这样就可以设置规则来控制进入的流量。<br>个人理解就是springcloud体系里的zuul和gateway，是个对内网关</p><p><img src="/img/istio/17ADD6E9-4C10-4D38-A6F9-36404547B65F.png" alt="Gateway"></p><p>如图，为从外部进入Bookinfo网站的HTTPS流量配置了一个Gateway</p><p>要实现路由，还要定义一个VirtualService与网关绑定。</p><p><img src="/img/istio/3855240D-C58A-46A2-9205-5954CAA31056.png" alt="VirtualService"></p><p>如图，在hosts中对之前定义的bookinfo-gateway的Gateway进行绑定</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>Istio中流量控制主要是由这4个配置资源共同协作完成。</p><ol><li>确认请求的主机（host）在VirtualService中是否有路由规则，</li><li>若有，则将请求发往对应的subset。</li><li>如果发现当前的subset在DestinationRule中定义了策略，则执行此策略。</li><li>同时，设置Gateway负责负载均衡以及为服务定义出口</li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Istio的流量管理功能主要是依靠Pilot组件和Envoy代理协作完成。</p><p>流量管理的规则配置由4个配置资源完成</p><ul><li>VirtualService定义路由规则</li><li>DestinationRule在路由生效后定义对于请求的策略</li><li>ServiceEntry提供了网格内服务访问外界服务的能力</li><li>Gateway让外部服务调用网格内服务</li></ul><h1 id="Mixer-1"><a href="#Mixer-1" class="headerlink" title="Mixer"></a>Mixer</h1><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><ul><li>先决条件检查<br>可简单地理解为是对服务调用者的权限检查，比如调用者的身份验证是否正确、调用者是否在白名单里和是否达到了调用限制等</li><li>配额管理<br>允许服务在多个维度上分配和释放配额</li><li>遥测报告<br>生成日志记录、监控、追踪数据</li></ul><p>个人理解有点像zuul、zipkin的结合体</p><h2 id="如何实现功能？"><a href="#如何实现功能？" class="headerlink" title="如何实现功能？"></a>如何实现功能？</h2><p>Sidecar代理在每次发送请求时都会调用Mixer，此时Mixer可根据发送方的信息进行检查，确认它是否有权限进行下游服务的调用。<br>请求过后，Sidecar仍然会调用Mixer，将定义的遥测数据交给Mixer收集起来，Mixer再把收集到的数据交给后端接入的系统进行分析、监控。<br>这些由Sidecar发送给Mixer的数据被称作属性（Attribute），用来描述请求和与请求相关的环境或系统（如请求路径、目的服务和主机IP）</p><p>将收集的属性交给后端基础设施进行处理的流程图</p><p><img src="/img/istio/A8F8FAED-07F1-4044-819A-6CEA256E66AF.png" alt="处理流程图"></p><h2 id="如何集成后端设施？"><a href="#如何集成后端设施？" class="headerlink" title="如何集成后端设施？"></a>如何集成后端设施？</h2><p>Mixer的一个重要特性: 配置模型。</p><p>配置模型基于以下两个部分</p><ul><li>适配器（Adapter）<br>后端设施的接口</li><li>模板（Template）<br>定义了属性和适配器输入的映射关系</li></ul><p>配置模型包括3种资源</p><ul><li>处理器（Handler）<br>用于确定正在使用的适配器及其操作方式</li><li>实例（Instance）<br>描述如何将请求属性映射到适配器输入，实例表示一个或多个适配器将操作的各种数据</li><li>规则（Rule）<br>定义了实例和处理器的映射关系，规则包含match表达式和action标签，match表达式控制何时调用适配器，而action决定了要提供给适配器的一组实例</li></ul><h2 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h2><p><img src="/img/istio/54F893CE-75F5-42D8-B8D2-51DD69780A2B.png" alt="流程"></p><ol><li>Envoy调用Mixer时，规则配置进行检查，确定调用哪个处理器，并将要处理的实例发送给处理器</li><li>处理器确定对应的后端适配器以及操作方式，将解析实例中的数据作为适配器的输入</li><li>适配器调用后端设施完成整个流程</li></ol><h1 id="Citadel-安全"><a href="#Citadel-安全" class="headerlink" title="Citadel(安全)"></a>Citadel(安全)</h1><p>Istio中的认证有两种</p><ul><li><p>传输认证（Transport Authentication）<br>也叫作服务到服务认证，验证直接客户端连接，提供双向TLS验证</p></li><li><p>身份认证（OriginAuthentication）<br>也叫作终端用户认证，验证终端用户或设备，比较常见的是通过JWT验证</p></li></ul><h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><p>TLS实现了将应用层的报文进行加密后再交由TCP进行传输的功能</p><p>该协议由两层组成</p><ol><li>TLS记录（TLS Record）协议</li><li>TLS握手（TLS Handshake）协议</li></ol><p>前身是SSL，即安全套接层（Secure Sockets Layer）</p><p>所谓的双向TLS（mutual TLS，mTLS）认证，是客户端和服务端都需要彼此进行验证</p><p>在Istio中，客户端和服务端的Envoy会建立一个双向TLS连接，由代理完成验证，授权后再转发到服务本身。它还提供了一个宽容模式的mTLS，即同时允许纯文本流量和加密流量验证。这个功能使得Istio的安全架构具有了极大的兼容性</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT是一种基于客户端的解决方案</p><p> 工作原理</p><p>用户登录后服务器生成一个令牌给客户端，由客户端保存；发送请求时带着令牌，服务器根据签名规则验证令牌的合法性和身份。一个完整的JWT包括3个部分：头部（Header）、负载（Payload）和签名（Signature）。头部负责定义JWT的元数据，负载存放实际需要传递的信息，签名是通过签名算法对前两部分进行编码而生成的字符串，可防止数据被篡改。这3部分组成一个Token，中间用点隔开，下图为示例</p><p><img src="/img/istio/2F113C67-23AB-40C8-80B3-3CFA9D3A2967.png" alt="工作原理"></p><p>使用的时候通常都被添加在请求头里，设置如下<br><img src="/img/istio/1C7120FD-3B5D-4FA6-B2F4-C0C6865249AA.png" alt="添加在请求头"></p><p>Istio的身份认证目前只支持JWT授权方式</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://github.com/CNCF123/Document/tree/master/Istio/huaweicloud/pdf">华为云Istio入门教程</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1vt411H755?from=search&seid=9658571065723447167">Istio教程</a></p></li></ol><h1 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a><a href="/Istio">推荐书单</a></h1>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云原生</tag>
      
      <tag>Istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
